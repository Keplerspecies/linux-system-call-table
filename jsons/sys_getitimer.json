{"Man page": "<pre><br><span class=\"headline\">GETITIMER(2)              Linux Programmer's Manual             GETITIMER(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       getitimer, setitimer - get or set value of an interval timer<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/time.h&gt;</b><br><br>       <b>int getitimer(int </b><i>which</i><b>, struct itimerval *</b><i>curr_value</i><b>);</b><br>       <b>int setitimer(int </b><i>which</i><b>, const struct itimerval *</b><i>new_value</i><b>,</b><br>                     <b>struct itimerval *</b><i>old_value</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The system provides each process with three interval timers, each<br>       decrementing in a distinct time domain.  When a timer expires, a<br>       signal is sent to the process, and the timer is reset to the<br>       specified interval (if nonzero).<br><br>       <b>ITIMER_REAL    </b>decrements in real time, and delivers <b>SIGALRM </b>upon<br>                      expiration.<br><br>       <b>ITIMER_VIRTUAL </b>decrements only when the process is executing, and<br>                      delivers <b>SIGVTALRM </b>upon expiration.<br><br>       <b>ITIMER_PROF    </b>decrements both when the process executes and when the<br>                      system is executing on behalf of the process.  Coupled<br>                      with <b>ITIMER_VIRTUAL</b>, this timer is usually used to<br>                      profile the time spent by the application in user and<br>                      kernel space.  <b>SIGPROF </b>is delivered upon expiration.<br><br>       Timer values are defined by the following structures:<br><br>           struct itimerval {<br>               struct timeval it_interval; /* Interval for periodic timer */<br>               struct timeval it_value;    /* Time until next expiration */<br>           };<br><br>           struct timeval {<br>               time_t      tv_sec;         /* seconds */<br>               suseconds_t tv_usec;        /* microseconds */<br>           };<br><br>       The function <b>getitimer</b>() fills the structure pointed to by <i>curr_value</i><br>       with the current value (i.e., the amount of time remaining until the<br>       next expiration) of the timer specified by <i>which</i> (one of <b>ITIMER_REAL</b>,<br>       <b>ITIMER_VIRTUAL</b>, or <b>ITIMER_PROF</b>).  The subfields of the field <i>it_value</i><br>       are set to the amount of time remaining on the timer, or zero if the<br>       timer is disabled.  The <i>it_interval</i> field is set to the timer<br>       interval (period); a value of zero returned in (both subfields of)<br>       this field indicates that this is a single-shot timer.<br><br>       The function <b>setitimer</b>() sets the specified timer to the value in<br>       <i>new_value</i>.  If <i>old_value</i> is non-NULL, the old value of the timer<br>       (i.e., the same information as returned by <b>getitimer</b>()) is stored<br>       there.<br><br>       Timers decrement from <i>it_value</i> to zero, generate a signal, and reset<br>       to <i>it_interval</i>.  A timer which is set to zero (<i>it_value</i> is zero or<br>       the timer expires and <i>it_interval</i> is zero) stops.<br><br>       Both <i>tv_sec</i> and <i>tv_usec</i> are significant in determining the duration<br>       of a timer.<br><br>       Timers will never expire before the requested time, but may expire<br>       some (short) time afterward, which depends on the system timer<br>       resolution and on the system load; see time(7).  (But see BUGS<br>       below.)  Upon expiration, a signal will be generated and the timer<br>       reset.  If the timer expires while the process is active (always true<br>       for <b>ITIMER_VIRTUAL</b>), the signal will be delivered immediately when<br>       generated.  Otherwise, the delivery will be offset by a small time<br>       dependent on the system loading.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, zero is returned.  On error, -1 is returned, and <i>errno</i> is<br>       set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EFAULT </b><i>new_value</i>, <i>old_value</i>, or <i>curr_value</i> is not valid a pointer.<br><br>       <b>EINVAL </b><i>which</i> is not one of <b>ITIMER_REAL</b>, <b>ITIMER_VIRTUAL</b>, or<br>              <b>ITIMER_PROF</b>; or (since Linux 2.6.22) one of the <i>tv_usec</i> fields<br>              in the structure pointed to by <i>new_value</i> contains a value<br>              outside the range 0 to 999999.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, SVr4, 4.4BSD (this call first appeared in 4.2BSD).<br>       POSIX.1-2008 marks <b>getitimer</b>() and <b>setitimer</b>() obsolete, recommending<br>       the use of the POSIX timers API (timer_gettime(2), timer_settime(2),<br>       etc.) instead.<br></pre><br><h2>NOTES  </h2><pre><br>       A child created via fork(2) does not inherit its parent's interval<br>       timers.  Interval timers are preserved across an execve(2).<br><br>       POSIX.1 leaves the interaction between <b>setitimer</b>() and the three<br>       interfaces alarm(2), sleep(3), and usleep(3) unspecified.<br><br>       The standards are silent on the meaning of the call:<br><br>           setitimer(which, NULL, &amp;old_value);<br><br>       Many systems (Solaris, the BSDs, and perhaps others) treat this as<br>       equivalent to:<br><br>           getitimer(which, &amp;old_value);<br><br>       In Linux, this is treated as being equivalent to a call in which the<br>       <i>new_value</i> fields are zero; that is, the timer is disabled.  <i>Don't use</i><br>       <i>this Linux misfeature</i>: it is nonportable and unnecessary.<br></pre><br><h2>BUGS  </h2><pre><br>       The generation and delivery of a signal are distinct, and only one<br>       instance of each of the signals listed above may be pending for a<br>       process.  Under very heavy loading, an <b>ITIMER_REAL </b>timer may expire<br>       before the signal from a previous expiration has been delivered.  The<br>       second signal in such an event will be lost.<br><br>       On Linux kernels before 2.6.16, timer values are represented in<br>       jiffies.  If a request is made set a timer with a value whose jiffies<br>       representation exceeds <b>MAX_SEC_IN_JIFFIES </b>(defined in<br>       <i>include/linux/jiffies.h</i>), then the timer is silently truncated to<br>       this ceiling value.  On Linux/i386 (where, since Linux 2.6.13, the<br>       default jiffy is 0.004 seconds), this means that the ceiling value<br>       for a timer is approximately 99.42 days.  Since Linux 2.6.16, the<br>       kernel uses a different internal representation for times, and this<br>       ceiling is removed.<br><br>       On certain systems (including i386), Linux kernels before version<br>       2.6.12 have a bug which will produce premature timer expirations of<br>       up to one jiffy under some circumstances.  This bug is fixed in<br>       kernel 2.6.12.<br><br>       POSIX.1-2001 says that <b>setitimer</b>() should fail if a <i>tv_usec</i> value is<br>       specified that is outside of the range 0 to 999999.  However, in<br>       kernels up to and including 2.6.21, Linux does not give an error, but<br>       instead silently adjusts the corresponding seconds value for the<br>       timer.  From kernel 2.6.22 onward, this nonconformance has been<br>       repaired: an improper <i>tv_usec</i> value results in an <b>EINVAL </b>error.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       gettimeofday(2), sigaction(2), signal(2), timer_create(2),<br>       timerfd_create(2), time(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2014-07-08                     GETITIMER(2)</span><br></pre><br>"}