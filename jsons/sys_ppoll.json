{"Man page": "<pre><br><span class=\"headline\">POLL(2)                   Linux Programmer's Manual                  POLL(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       poll, ppoll - wait for some event on a file descriptor<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;poll.h&gt;</b><br><br>       <b>int poll(struct pollfd *</b><i>fds</i><b>, nfds_t </b><i>nfds</i><b>, int </b><i>timeout</i><b>);</b><br><br>       <b>#define _GNU_SOURCE         </b>/* See feature_test_macros(7) */<br>       <b>#include &lt;signal.h&gt;</b><br>       <b>#include &lt;poll.h&gt;</b><br><br>       <b>int ppoll(struct pollfd *</b><i>fds</i><b>, nfds_t </b><i>nfds</i><b>,</b><br>               <b>const struct timespec *</b><i>timeout_ts</i><b>, const sigset_t *</b><i>sigmask</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>poll</b>() performs a similar task to select(2): it waits for one of a<br>       set of file descriptors to become ready to perform I/O.<br><br>       The set of file descriptors to be monitored is specified in the <i>fds</i><br>       argument, which is an array of structures of the following form:<br><br>           struct pollfd {<br>               int   fd;         /* file descriptor */<br>               short events;     /* requested events */<br>               short revents;    /* returned events */<br>           };<br><br>       The caller should specify the number of items in the <i>fds</i> array in<br>       <i>nfds</i>.<br><br>       The field <i>fd</i> contains a file descriptor for an open file.  If this<br>       field is negative, then the corresponding <i>events</i> field is ignored and<br>       the <i>revents</i> field returns zero.  (This provides an easy way of<br>       ignoring a file descriptor for a single <b>poll</b>() call: simply negate<br>       the <i>fd</i> field.  Note, however, that this technique can't be used to<br>       ignore file descriptor 0.)<br><br>       The field <i>events</i> is an input parameter, a bit mask specifying the<br>       events the application is interested in for the file descriptor <i>fd</i>.<br>       This field may be specified as zero, in which case the only events<br>       that can be returned in <i>revents</i> are <b>POLLHUP</b>, <b>POLLERR</b>, and <b>POLLNVAL</b><br>       (see below).<br><br>       The field <i>revents</i> is an output parameter, filled by the kernel with<br>       the events that actually occurred.  The bits returned in <i>revents</i> can<br>       include any of those specified in <i>events</i>, or one of the values<br>       <b>POLLERR</b>, <b>POLLHUP</b>, or <b>POLLNVAL</b>.  (These three bits are meaningless in<br>       the <i>events</i> field, and will be set in the <i>revents</i> field whenever the<br>       corresponding condition is true.)<br><br>       If none of the events requested (and no error) has occurred for any<br>       of the file descriptors, then <b>poll</b>() blocks until one of the events<br>       occurs.<br><br>       The <i>timeout</i> argument specifies the number of milliseconds that <b>poll</b>()<br>       should block waiting for a file descriptor to become ready.  The call<br>       will block until either:<br><br>       *  a file descriptor becomes ready;<br><br>       *  the call is interrupted by a signal handler; or<br><br>       *  the timeout expires.<br><br>       Note that the <i>timeout</i> interval will be rounded up to the system clock<br>       granularity, and kernel scheduling delays mean that the blocking<br>       interval may overrun by a small amount.  Specifying a negative value<br>       in <i>timeout</i> means an infinite timeout.  Specifying a <i>timeout</i> of zero<br>       causes <b>poll</b>() to return immediately, even if no file descriptors are<br>       ready.<br><br>       The bits that may be set/returned in <i>events</i> and <i>revents</i> are defined<br>       in <i>&lt;poll.h&gt;</i>:<br><br>              <b>POLLIN </b>There is data to read.<br><br>              <b>POLLPRI</b><br>                     There is urgent data to read (e.g., out-of-band data on<br>                     TCP socket; pseudoterminal master in packet mode has<br>                     seen state change in slave).<br><br>              <b>POLLOUT</b><br>                     Writing is now possible, though a write larger that the<br>                     available space in a socket or pipe will still block<br>                     (unless <b>O_NONBLOCK </b>is set).<br><br>              <b>POLLRDHUP </b>(since Linux 2.6.17)<br>                     Stream socket peer closed connection, or shut down<br>                     writing half of connection.  The <b>_GNU_SOURCE </b>feature<br>                     test macro must be defined (before including <i>any</i> header<br>                     files) in order to obtain this definition.<br><br>              <b>POLLERR</b><br>                     Error condition (only returned in <i>revents</i>; ignored in<br>                     <i>events</i>).<br><br>              <b>POLLHUP</b><br>                     Hang up (only returned in <i>revents</i>; ignored in <i>events</i>).<br>                     Note that when reading from a channel such as a pipe or<br>                     a stream socket, this event merely indicates that the<br>                     peer closed its end of the channel.  Subsequent reads<br>                     from the channel will return 0 (end of file) only after<br>                     all outstanding data in the channel has been consumed.<br><br>              <b>POLLNVAL</b><br>                     Invalid request: <i>fd</i> not open (only returned in <i>revents</i>;<br>                     ignored in <i>events</i>).<br><br>       When compiling with <b>_XOPEN_SOURCE </b>defined, one also has the<br>       following, which convey no further information beyond the bits listed<br>       above:<br><br>              <b>POLLRDNORM</b><br>                     Equivalent to <b>POLLIN</b>.<br><br>              <b>POLLRDBAND</b><br>                     Priority band data can be read (generally unused on<br>                     Linux).<br><br>              <b>POLLWRNORM</b><br>                     Equivalent to <b>POLLOUT</b>.<br><br>              <b>POLLWRBAND</b><br>                     Priority data may be written.<br><br>       Linux also knows about, but does not use <b>POLLMSG</b>.<br><br>   <b>ppoll()</b><br>       The relationship between <b>poll</b>() and <b>ppoll</b>() is analogous to the<br>       relationship between select(2) and pselect(2): like pselect(2),<br>       <b>ppoll</b>() allows an application to safely wait until either a file<br>       descriptor becomes ready or until a signal is caught.<br><br>       Other than the difference in the precision of the <i>timeout</i> argument,<br>       the following <b>ppoll</b>() call:<br><br>           ready = ppoll(&amp;fds, nfds, timeout_ts, &amp;sigmask);<br><br>       is equivalent to <i>atomically</i> executing the following calls:<br><br>           sigset_t origmask;<br>           int timeout;<br><br>           timeout = (timeout_ts == NULL) ? -1 :<br>                     (timeout_ts.tv_sec * 1000 + timeout_ts.tv_nsec / 1000000);<br>           pthread_sigmask(SIG_SETMASK, &amp;sigmask, &amp;origmask);<br>           ready = poll(&amp;fds, nfds, timeout);<br>           pthread_sigmask(SIG_SETMASK, &amp;origmask, NULL);<br><br>       See the description of pselect(2) for an explanation of why <b>ppoll</b>()<br>       is necessary.<br><br>       If the <i>sigmask</i> argument is specified as NULL, then no signal mask<br>       manipulation is performed (and thus <b>ppoll</b>() differs from <b>poll</b>() only<br>       in the precision of the <i>timeout</i> argument).<br><br>       The <i>timeout_ts</i> argument specifies an upper limit on the amount of<br>       time that <b>ppoll</b>() will block.  This argument is a pointer to a<br>       structure of the following form:<br><br>           struct timespec {<br>               long    tv_sec;         /* seconds */<br>               long    tv_nsec;        /* nanoseconds */<br>           };<br><br>       If <i>timeout_ts</i> is specified as NULL, then <b>ppoll</b>() can block<br>       indefinitely.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, a positive number is returned; this is the number of<br>       structures which have nonzero <i>revents</i> fields (in other words, those<br>       descriptors with events or errors reported).  A value of 0 indicates<br>       that the call timed out and no file descriptors were ready.  On<br>       error, -1 is returned, and <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EFAULT </b>The array given as argument was not contained in the calling<br>              program's address space.<br><br>       <b>EINTR  </b>A signal occurred before any requested event; see signal(7).<br><br>       <b>EINVAL </b>The <i>nfds</i> value exceeds the <b>RLIMIT_NOFILE </b>value.<br><br>       <b>ENOMEM </b>There was no space to allocate file descriptor tables.<br></pre><br><h2>VERSIONS  </h2><pre><br>       The <b>poll</b>() system call was introduced in Linux 2.1.23.  On older<br>       kernels that lack this system call, the glibc (and the old Linux<br>       libc) <b>poll</b>() wrapper function provides emulation using select(2).<br><br>       The <b>ppoll</b>() system call was added to Linux in kernel 2.6.16.  The<br>       <b>ppoll</b>() library call was added in glibc 2.4.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>poll</b>() conforms to POSIX.1-2001 and POSIX.1-2008.  <b>ppoll</b>() is Linux-<br>       specific.<br></pre><br><h2>NOTES  </h2><pre><br>       Some implementations define the nonstandard constant <b>INFTIM </b>with the<br>       value -1 for use as a <i>timeout</i> for <b>poll</b>().  This constant is not<br>       provided in glibc.<br><br>       For a discussion of what may happen if a file descriptor being<br>       monitored by <b>poll</b>() is closed in another thread, see select(2).<br><br>   <b>C library/kernel differences</b><br>       The Linux <b>ppoll</b>() system call modifies its <i>timeout_ts</i> argument.<br>       However, the glibc wrapper function hides this behavior by using a<br>       local variable for the timeout argument that is passed to the system<br>       call.  Thus, the glibc <b>ppoll</b>() function does not modify its<br>       <i>timeout_ts</i> argument.<br><br>       The raw <b>ppoll</b>() system call has a fifth argument, <i>size_t sigsetsize</i>,<br>       which specifies the size in bytes of the <i>sigmask</i> argument.  The glibc<br>       <b>ppoll</b>() wrapper function specifies this argument as a fixed value<br>       (equal to <i>sizeof(sigset_t)</i>).<br></pre><br><h2>BUGS  </h2><pre><br>       See the discussion of spurious readiness notifications under the BUGS<br>       section of select(2).<br></pre><br><h2>SEE ALSO  </h2><pre><br>       restart_syscall(2), select(2), select_tut(2), epoll(7), time(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                          POLL(2)</span><br></pre><br>"}