{"Man page": "<pre><br><span class=\"headline\">BIND(2)                   Linux Programmer's Manual                  BIND(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       bind - bind a name to a socket<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/types.h&gt;          </b>/* See NOTES */<br>       <b>#include &lt;sys/socket.h&gt;</b><br><br>       <b>int bind(int </b><i>sockfd</i><b>, const struct sockaddr *</b><i>addr</i><b>,</b><br>                <b>socklen_t </b><i>addrlen</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       When a socket is created with socket(2), it exists in a name space<br>       (address family) but has no address assigned to it.  <b>bind</b>() assigns<br>       the address specified by <i>addr</i> to the socket referred to by the file<br>       descriptor <i>sockfd</i>.  <i>addrlen</i> specifies the size, in bytes, of the<br>       address structure pointed to by <i>addr</i>.  Traditionally, this operation<br>       is called &#8220;assigning a name to a socket&#8221;.<br><br>       It is normally necessary to assign a local address using <b>bind</b>()<br>       before a <b>SOCK_STREAM </b>socket may receive connections (see accept(2)).<br><br>       The rules used in name binding vary between address families.<br>       Consult the manual entries in Section 7 for detailed information.<br>       For <b>AF_INET </b>see ip(7), for <b>AF_INET6 </b>see ipv6(7), for <b>AF_UNIX </b>see<br>       unix(7), for <b>AF_APPLETALK </b>see ddp(7), for <b>AF_PACKET </b>see packet(7),<br>       for <b>AF_X25 </b>see x25(7) and for <b>AF_NETLINK </b>see netlink(7).<br><br>       The actual structure passed for the <i>addr</i> argument will depend on the<br>       address family.  The <i>sockaddr</i> structure is defined as something like:<br><br>           struct sockaddr {<br>               sa_family_t sa_family;<br>               char        sa_data[14];<br>           }<br><br>       The only purpose of this structure is to cast the structure pointer<br>       passed in <i>addr</i> in order to avoid compiler warnings.  See EXAMPLE<br>       below.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, zero is returned.  On error, -1 is returned, and <i>errno</i> is<br>       set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EACCES </b>The address is protected, and the user is not the superuser.<br><br>       <b>EADDRINUSE</b><br>              The given address is already in use.<br><br>       <b>EADDRINUSE</b><br>              (Internet domain sockets) The port number was specified as<br>              zero in the socket address structure, but, upon attempting to<br>              bind to an ephemeral port, it was determined that all port<br>              numbers in the ephemeral port range are currently in use.  See<br>              the discussion of <i>/proc/sys/net/ipv4/ip_local_port_range</i><br>              ip(7).<br><br>       <b>EBADF  </b><i>sockfd</i> is not a valid descriptor.<br><br>       <b>EINVAL </b>The socket is already bound to an address.<br><br>       <b>EINVAL </b><i>addrlen</i> is wrong, or <i>addr</i> is not a valid address for<br>              this socket's domain.<br><br>       <b>ENOTSOCK</b><br>              <i>sockfd</i> is a descriptor for a file, not a socket.<br><br>       The following errors are specific to UNIX domain (<b>AF_UNIX</b>)<br>       sockets:<br><br>       <b>EACCES </b>Search permission is denied on a component of the path<br>              prefix.  (See also path_resolution(7).)<br><br>       <b>EADDRNOTAVAIL</b><br>              A nonexistent interface was requested or the requested<br>              address was not local.<br><br>       <b>EFAULT </b><i>addr</i> points outside the user's accessible address<br>              space.<br><br>       <b>ELOOP  </b>Too many symbolic links were encountered in resolving<br>              <i>addr</i>.<br><br>       <b>ENAMETOOLONG</b><br>              <i>addr</i> is too long.<br><br>       <b>ENOENT </b>The file does not exist.<br><br>       <b>ENOMEM </b>Insufficient kernel memory was available.<br><br>       <b>ENOTDIR</b><br>              A component of the path prefix is not a directory.<br><br>       <b>EROFS  </b>The socket inode would reside on a read-only<br>              filesystem.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (<b>bind</b>() first<br>       appeared in 4.2BSD).<br></pre><br><h2>NOTES  </h2><pre><br>       POSIX.1 does not require the inclusion of <i>&lt;sys/types.h&gt;</i>, and<br>       this header file is not required on Linux.  However, some<br>       historical (BSD) implementations required this header file,<br>       and portable applications are probably wise to include it.<br><br>       The third argument of <b>bind</b>() is in reality an <i>int</i> (and this is<br>       what 4.x BSD and libc4 and libc5 have).  Some POSIX confusion<br>       resulted in the present <i>socklen_t</i>, also used by glibc.  See<br>       also accept(2).<br></pre><br><h2>BUGS  </h2><pre><br>       The transparent proxy options are not described.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       An example of the use of <b>bind</b>() with Internet domain sockets<br>       can be found in getaddrinfo(3).<br><br>       The following example shows how to bind a stream socket in the<br>       UNIX (<b>AF_UNIX</b>) domain, and accept connections:<br><br>       #include &lt;sys/socket.h&gt;<br>       #include &lt;sys/un.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;string.h&gt;<br><br>       #define MY_SOCK_PATH \"/somepath\"<br>       #define LISTEN_BACKLOG 50<br><br>       #define handle_error(msg) \\<br>           do { perror(msg); exit(EXIT_FAILURE); } while (0)<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           int sfd, cfd;<br>           struct sockaddr_un my_addr, peer_addr;<br>           socklen_t peer_addr_size;<br><br>           sfd = socket(AF_UNIX, SOCK_STREAM, 0);<br>           if (sfd == -1)<br>               handle_error(\"socket\");<br><br>           memset(&amp;my_addr, 0, sizeof(struct sockaddr_un));<br>                               /* Clear structure */<br>           my_addr.sun_family = AF_UNIX;<br>           strncpy(my_addr.sun_path, MY_SOCK_PATH,<br>                   sizeof(my_addr.sun_path) - 1);<br><br>           if (bind(sfd, (struct sockaddr *) &amp;my_addr,<br>                   sizeof(struct sockaddr_un)) == -1)<br>               handle_error(\"bind\");<br><br>           if (listen(sfd, LISTEN_BACKLOG) == -1)<br>               handle_error(\"listen\");<br><br>           /* Now we can accept incoming connections one<br>              at a time using accept(2) */<br><br>           peer_addr_size = sizeof(struct sockaddr_un);<br>           cfd = accept(sfd, (struct sockaddr *) &amp;peer_addr,<br>                        &amp;peer_addr_size);<br>           if (cfd == -1)<br>               handle_error(\"accept\");<br><br>           /* Code to deal with incoming connection(s)... */<br><br>           /* When no longer required, the socket pathname, MY_SOCK_PATH<br>              should be deleted using unlink(2) or remove(3) */<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       accept(2), connect(2), getsockname(2), listen(2), socket(2),<br>       getaddrinfo(3), getifaddrs(3), ip(7), ipv6(7),<br>       path_resolution(7), socket(7), unix(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i><br>       project.  A description of the project, information about<br>       reporting bugs, and the latest version of this page, can be<br>       found at http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-08-08                          BIND(2)</span><br></pre><br>"}