{"Man page": "<pre><br><span class=\"headline\">UNSHARE(2)                Linux Programmer's Manual               UNSHARE(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       unshare - disassociate parts of the process execution context<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sched.h&gt;</b><br><br>       <b>int unshare(int </b><i>flags</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>unshare</b>():<br>           Since glibc 2.14:<br>               _GNU_SOURCE<br>           Before glibc 2.14:<br>               _BSD_SOURCE || _SVID_SOURCE<br>                   /* _GNU_SOURCE also suffices */<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>unshare</b>() allows a process (or thread) to disassociate parts of its<br>       execution context that are currently being shared with other<br>       processes (or threads).  Part of the execution context, such as the<br>       mount namespace, is shared implicitly when a new process is created<br>       using fork(2) or vfork(2), while other parts, such as virtual memory,<br>       may be shared by explicit request when creating a process or thread<br>       using clone(2).<br><br>       The main use of <b>unshare</b>() is to allow a process to control its shared<br>       execution context without creating a new process.<br><br>       The <i>flags</i> argument is a bit mask that specifies which parts of the<br>       execution context should be unshared.  This argument is specified by<br>       ORing together zero or more of the following constants:<br><br>       <b>CLONE_FILES</b><br>              Reverse the effect of the clone(2) <b>CLONE_FILES </b>flag.  Unshare<br>              the file descriptor table, so that the calling process no<br>              longer shares its file descriptors with any other process.<br><br>       <b>CLONE_FS</b><br>              Reverse the effect of the clone(2) <b>CLONE_FS </b>flag.  Unshare<br>              filesystem attributes, so that the calling process no longer<br>              shares its root directory (chroot(2)), current directory<br>              (chdir(2)), or umask (umask(2)) attributes with any other<br>              process.<br><br>       <b>CLONE_NEWIPC </b>(since Linux 2.6.19)<br>              This flag has the same effect as the clone(2) <b>CLONE_NEWIPC</b><br>              flag.  Unshare the IPC namespace, so that the calling process<br>              has a private copy of the IPC namespace which is not shared<br>              with any other process.  Specifying this flag automatically<br>              implies <b>CLONE_SYSVSEM </b>as well.  Use of <b>CLONE_NEWIPC </b>requires<br>              the <b>CAP_SYS_ADMIN </b>capability.<br><br>       <b>CLONE_NEWNET </b>(since Linux 2.6.24)<br>              This flag has the same effect as the clone(2) <b>CLONE_NEWNET</b><br>              flag.  Unshare the network namespace, so that the calling<br>              process is moved into a new network namespace which is not<br>              shared with any previously existing process.  Use of<br>              <b>CLONE_NEWNET </b>requires the <b>CAP_SYS_ADMIN </b>capability.<br><br>       <b>CLONE_NEWNS</b><br>              This flag has the same effect as the clone(2) <b>CLONE_NEWNS</b><br>              flag.  Unshare the mount namespace, so that the calling<br>              process has a private copy of its namespace which is not<br>              shared with any other process.  Specifying this flag<br>              automatically implies <b>CLONE_FS </b>as well.  Use of <b>CLONE_NEWNS</b><br>              requires the <b>CAP_SYS_ADMIN </b>capability.<br><br>       <b>CLONE_NEWPID </b>(since Linux 3.8)<br>              This flag has the same effect as the clone(2) <b>CLONE_NEWPID</b><br>              flag.  Unshare the PID namespace, so that the calling process<br>              has a new PID namespace for its children which is not shared<br>              with any previously existing process.  The calling process is<br>              <i>not</i> moved into the new namespace.  The first child created by<br>              the calling process will have the process ID 1 and will assume<br>              the role of init(1) in the new namespace.  <b>CLONE_NEWPID</b><br>              automatically implies <b>CLONE_THREAD </b>as well.  Use of<br>              <b>CLONE_NEWPID </b>requires the <b>CAP_SYS_ADMIN </b>capability.  For<br>              further information, see pid_namespaces(7).<br><br>       <b>CLONE_NEWUSER </b>(since Linux 3.8)<br>              This flag has the same effect as the clone(2) <b>CLONE_NEWUSER</b><br>              flag.  Unshare the user namespace, so that the calling process<br>              is moved into a new user namespace which is not shared with<br>              any previously existing process.  As with the child process<br>              created by clone(2) with the <b>CLONE_NEWUSER </b>flag, the caller<br>              obtains a full set of capabilities in the new namespace.<br><br>              <b>CLONE_NEWUSER </b>requires that the calling process is not<br>              threaded; specifying <b>CLONE_NEWUSER </b>automatically implies<br>              <b>CLONE_THREAD</b>.  Since Linux 3.9, <b>CLONE_NEWUSER </b>also<br>              automatically implies <b>CLONE_FS</b>.  <b>CLONE_NEWUSER </b>requires that<br>              the user ID and group ID of the calling process are mapped to<br>              user IDs and group IDs in the user namespace of the calling<br>              process at the time of the call.<br><br>              For further information on user namespaces, see<br>              user_namespaces(7).<br><br>       <b>CLONE_NEWUTS </b>(since Linux 2.6.19)<br>              This flag has the same effect as the clone(2) <b>CLONE_NEWUTS</b><br>              flag.  Unshare the UTS IPC namespace, so that the calling<br>              process has a private copy of the UTS namespace which is not<br>              shared with any other process.  Use of <b>CLONE_NEWUTS </b>requires<br>              the <b>CAP_SYS_ADMIN </b>capability.<br><br>       <b>CLONE_SYSVSEM </b>(since Linux 2.6.26)<br>              This flag reverses the effect of the clone(2) <b>CLONE_SYSVSEM</b><br>              flag.  Unshare System V semaphore adjustment (<i>semadj</i>) values,<br>              so that the calling process has a new empty <i>semadj</i> list that<br>              is not shared with any other process.  If this is the last<br>              process that has a reference to the process's current <i>semadj</i><br>              list, then the adjustments in that list are applied to the<br>              corresponding semaphores, as described in semop(2).<br><br>       In addition, <b>CLONE_THREAD</b>, <b>CLONE_SIGHAND</b>, and <b>CLONE_VM </b>can be<br>       specified in <i>flags</i> if the caller is single threaded (i.e., it is not<br>       sharing its address space with another process or thread).  In this<br>       case, these flags have no effect.  (Note also that specifying<br>       <b>CLONE_THREAD </b>automatically implies <b>CLONE_VM</b>, and specifying <b>CLONE_VM</b><br>       automatically implies <b>CLONE_SIGHAND</b>.)  If the process is<br>       multithreaded, then the use of these flags results in an error.<br><br>       If <i>flags</i> is specified as zero, then <b>unshare</b>() is a no-op; no changes<br>       are made to the calling process's execution context.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, zero returned.  On failure, -1 is returned and <i>errno</i> is<br>       set to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EINVAL </b>An invalid bit was specified in <i>flags</i>.<br><br>       <b>EINVAL CLONE_THREAD</b>, <b>CLONE_SIGHAND</b>, or <b>CLONE_VM </b>was specified in<br>              <i>flags</i>, and the caller is multithreaded.<br><br>       <b>ENOMEM </b>Cannot allocate sufficient memory to copy parts of caller's<br>              context that need to be unshared.<br><br>       <b>EPERM  </b>The calling process did not have the required privileges for<br>              this operation.<br><br>       <b>EPERM  CLONE_NEWUSER </b>was specified in <i>flags</i>, but either the effective<br>              user ID or the effective group ID of the caller does not have<br>              a mapping in the parent namespace (see user_namespaces(7)).<br><br>       <b>EPERM </b>(since Linux 3.9)<br>              <b>CLONE_NEWUSER </b>was specified in <i>flags</i> and the caller is in a<br>              chroot environment (i.e., the caller's root directory does not<br>              match the root directory of the mount namespace in which it<br>              resides).<br><br>       <b>EUSERS </b>(since Linux 3.11)<br>              <b>CLONE_NEWUSER </b>was specified in <i>flags</i>, and the call would cause<br>              the limit on the number of nested user namespaces to be<br>              exceeded.  See user_namespaces(7).<br></pre><br><h2>VERSIONS  </h2><pre><br>       The <b>unshare</b>() system call was added to Linux in kernel 2.6.16.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       The <b>unshare</b>() system call is Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       Not all of the process attributes that can be shared when a new<br>       process is created using clone(2) can be unshared using <b>unshare</b>().<br>       In particular, as at kernel 3.8, <b>unshare</b>() does not implement flags<br>       that reverse the effects of <b>CLONE_SIGHAND</b>, <b>CLONE_THREAD</b>, or <b>CLONE_VM</b>.<br>       Such functionality may be added in the future, if required.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The program below provides a simple implementation of the unshare(1)<br>       command, which unshares one or more namespaces and executes the<br>       command supplied in its command-line arguments.  Here's an example of<br>       the use of this program, running a shell in a new mount namespace,<br>       and verifying that the original shell and the new shell are in<br>       separate mount namespaces:<br><br>           $ <b>readlink /proc/$$/ns/mnt</b><br>           mnt:[4026531840]<br>           $ <b>sudo ./unshare -m /bin/bash</b><br>           [sudo] password for cecilia:<br>           # <b>readlink /proc/$$/ns/mnt</b><br>           mnt:[4026532325]<br><br>       The differing output of the two readlink(1) commands shows that the<br>       two shells are in different mount namespaces.<br><br>   <b>Program source</b><br><br>       /* unshare.c<br><br>          A simple implementation of the unshare(1) command: unshare<br>          namespaces and execute a command.<br>       */<br>       #define _GNU_SOURCE<br>       #include &lt;sched.h&gt;<br>       #include &lt;unistd.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;stdio.h&gt;<br><br>       /* A simple error-handling function: print an error message based<br>          on the value in 'errno' and terminate the calling process */<br><br>       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\<br>                               } while (0)<br><br>       static void<br>       usage(char *pname)<br>       {<br>           fprintf(stderr, \"Usage: %s [options] program [arg...]\\n\", pname);<br>           fprintf(stderr, \"Options can be:\\n\");<br>           fprintf(stderr, \"    -i   unshare IPC namespace\\n\");<br>           fprintf(stderr, \"    -m   unshare mount namespace\\n\");<br>           fprintf(stderr, \"    -n   unshare network namespace\\n\");<br>           fprintf(stderr, \"    -p   unshare PID namespace\\n\");<br>           fprintf(stderr, \"    -u   unshare UTS namespace\\n\");<br>           fprintf(stderr, \"    -U   unshare user namespace\\n\");<br>           exit(EXIT_FAILURE);<br>       }<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           int flags, opt;<br><br>           flags = 0;<br><br>           while ((opt = getopt(argc, argv, \"imnpuU\")) != -1) {<br>               switch (opt) {<br>               case 'i': flags |= CLONE_NEWIPC;        break;<br>               case 'm': flags |= CLONE_NEWNS;         break;<br>               case 'n': flags |= CLONE_NEWNET;        break;<br>               case 'p': flags |= CLONE_NEWPID;        break;<br>               case 'u': flags |= CLONE_NEWUTS;        break;<br>               case 'U': flags |= CLONE_NEWUSER;       break;<br>               default:  usage(argv[0]);<br>               }<br>           }<br><br>           if (optind &gt;= argc)<br>               usage(argv[0]);<br><br>           if (unshare(flags) == -1)<br>               errExit(\"unshare\");<br><br>           execvp(argv[optind], &amp;argv[optind]);<br>           errExit(\"execvp\");<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       unshare(1), clone(2), fork(2), kcmp(2), setns(2), vfork(2),<br>       namespaces(7)<br><br>       <i>Documentation/unshare.txt</i> in the Linux kernel source tree<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-04-19                       UNSHARE(2)</span><br></pre><br>"}