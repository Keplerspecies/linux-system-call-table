{"Man page": "<pre><br><span class=\"headline\">MSGOP(2)                  Linux Programmer's Manual                 MSGOP(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       msgrcv, msgsnd - System V message queue operations<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/types.h&gt;</b><br>       <b>#include &lt;sys/ipc.h&gt;</b><br>       <b>#include &lt;sys/msg.h&gt;</b><br><br>       <b>int msgsnd(int </b><i>msqid</i><b>, const void *</b><i>msgp</i><b>, size_t </b><i>msgsz</i><b>, int </b><i>msgflg</i><b>);</b><br><br>       <b>ssize_t msgrcv(int </b><i>msqid</i><b>, void *</b><i>msgp</i><b>, size_t </b><i>msgsz</i><b>, long </b><i>msgtyp</i><b>,</b><br>                      <b>int </b><i>msgflg</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>msgsnd</b>() and <b>msgrcv</b>() system calls are used, respectively, to<br>       send messages to, and receive messages from, a System V message<br>       queue.  The calling process must have write permission on the message<br>       queue in order to send a message, and read permission to receive a<br>       message.<br><br>       The <i>msgp</i> argument is a pointer to a caller-defined structure of the<br>       following general form:<br><br>           struct msgbuf {<br>               long mtype;       /* message type, must be &gt; 0 */<br>               char mtext[1];    /* message data */<br>           };<br><br>       The <i>mtext</i> field is an array (or other structure) whose size is<br>       specified by <i>msgsz</i>, a nonnegative integer value.  Messages of zero<br>       length (i.e., no <i>mtext</i> field) are permitted.  The <i>mtype</i> field must<br>       have a strictly positive integer value.  This value can be used by<br>       the receiving process for message selection (see the description of<br>       <b>msgrcv</b>() below).<br><br>   <b>msgsnd()</b><br>       The <b>msgsnd</b>() system call appends a copy of the message pointed to by<br>       <i>msgp</i> to the message queue whose identifier is specified by <i>msqid</i>.<br><br>       If sufficient space is available in the queue, <b>msgsnd</b>() succeeds<br>       immediately.  The queue capacity is governed by the <i>msg_qbytes</i> field<br>       in the associated data structure for the message queue.  During queue<br>       creation this field is initialized to <b>MSGMNB </b>bytes, but this limit<br>       can be modified using msgctl(2).  A message queue is considered to be<br>       full if either of the following conditions is true:<br><br>       * Adding a new message to the queue would cause the total number of<br>         bytes in the queue to exceed the queue's maximum size (the<br>         <i>msg_qbytes</i> field).<br><br>       * Adding another message to the queue would cause the total number of<br>         messages in the queue to exceed the queue's maximum size (the<br>         <i>msg_qbytes</i> field).  This check is necessary to prevent an unlimited<br>         number of zero-length messages being placed on the queue.  Although<br>         such messages contain no data, they nevertheless consume (locked)<br>         kernel memory.<br><br>       If insufficient space is available in the queue, then the default<br>       behavior of <b>msgsnd</b>() is to block until space becomes available.  If<br>       <b>IPC_NOWAIT </b>is specified in <i>msgflg</i>, then the call instead fails with<br>       the error <b>EAGAIN</b>.<br><br>       A blocked <b>msgsnd</b>() call may also fail if:<br><br>       * the queue is removed, in which case the system call fails with<br>         <i>errno</i> set to <b>EIDRM</b>; or<br><br>       * a signal is caught, in which case the system call fails with <i>errno</i><br>         set to <b>EINTR</b>;<b>see signal</b>(7).  (<b>msgsnd</b>() is never automatically<br>         restarted after being interrupted by a signal handler, regardless<br>         of the setting of the <b>SA_RESTART </b>flag when establishing a signal<br>         handler.)<br><br>       Upon successful completion the message queue data structure is<br>       updated as follows:<br><br>              <i>msg_lspid</i> is set to the process ID of the calling process.<br><br>              <i>msg_qnum</i> is incremented by 1.<br><br>              <i>msg_stime</i> is set to the current time.<br><br>   <b>msgrcv()</b><br>       The <b>msgrcv</b>() system call removes a message from the queue specified<br>       by <i>msqid</i> and places it in the buffer pointed to by <i>msgp</i>.<br><br>       The argument <i>msgsz</i> specifies the maximum size in bytes for the member<br>       <i>mtext</i> of the structure pointed to by the <i>msgp</i> argument.  If the<br>       message text has length greater than <i>msgsz</i>, then the behavior depends<br>       on whether <b>MSG_NOERROR </b>is specified in <i>msgflg</i>.  If <b>MSG_NOERROR </b>is<br>       specified, then the message text will be truncated (and the truncated<br>       part will be lost); if <b>MSG_NOERROR </b>is not specified, then the message<br>       isn't removed from the queue and the system call fails returning -1<br>       with <i>errno</i> set to <b>E2BIG</b>.<br><br>       Unless <b>MSG_COPY </b>is specified in <i>msgflg</i> (see below), the <i>msgtyp</i><br>       argument specifies the type of message requested, as follows:<br><br>       * If <i>msgtyp</i> is 0, then the first message in the queue is read.<br><br>       * If <i>msgtyp</i> is greater than 0, then the first message in the queue of<br>         type <i>msgtyp</i> is read, unless <b>MSG_EXCEPT </b>was specified in <i>msgflg</i>, in<br>         which case the first message in the queue of type not equal to<br>         <i>msgtyp</i> will be read.<br><br>       * If <i>msgtyp</i> is less than 0, then the first message in the queue with<br>         the lowest type less than or equal to the absolute value of <i>msgtyp</i><br>         will be read.<br><br>       The <i>msgflg</i> argument is a bit mask constructed by ORing together zero<br>       or more of the following flags:<br><br>       <b>IPC_NOWAIT</b><br>              Return immediately if no message of the requested type is in<br>              the queue.  The system call fails with <i>errno</i> set to <b>ENOMSG</b>.<br><br>       <b>MSG_COPY </b>(since Linux 3.8)<br>              Nondestructively fetch a copy of the message at the ordinal<br>              position in the queue specified by <i>msgtyp</i> (messages are<br>              considered to be numbered starting at 0).<br><br>              This flag must be specified in conjunction with <b>IPC_NOWAIT</b>,<br>              with the result that, if there is no message available at the<br>              given position, the call fails immediately with the error<br>              <b>ENOMSG</b>.  Because they alter the meaning of <i>msgtyp</i> in<br>              orthogonal ways, <b>MSG_COPY </b>and <b>MSG_EXCEPT </b>may not both be<br>              specified in <i>msgflg</i>.<br><br>              The <b>MSG_COPY </b>flag was added for the implementation of the<br>              kernel checkpoint-restore facility and is available only if<br>              the kernel was built with the <b>CONFIG_CHECKPOINT_RESTORE</b><br>              option.<br><br>       <b>MSG_EXCEPT</b><br>              Used with <i>msgtyp</i> greater than 0 to read the first message in<br>              the queue with message type that differs from <i>msgtyp</i>.<br><br>       <b>MSG_NOERROR</b><br>              To truncate the message text if longer than <i>msgsz</i> bytes.<br><br>       If no message of the requested type is available and <b>IPC_NOWAIT </b>isn't<br>       specified in <i>msgflg</i>, the calling process is blocked until one of the<br>       following conditions occurs:<br><br>       * A message of the desired type is placed in the queue.<br><br>       * The message queue is removed from the system.  In this case, the<br>         system call fails with <i>errno</i> set to <b>EIDRM</b>.<br><br>       * The calling process catches a signal.  In this case, the system<br>         call fails with <i>errno</i> set to <b>EINTR</b>.  (<b>msgrcv</b>() is never<br>         automatically restarted after being interrupted by a signal<br>         handler, regardless of the setting of the <b>SA_RESTART </b>flag when<br>         establishing a signal handler.)<br><br>       Upon successful completion the message queue data structure is<br>       updated as follows:<br><br>              <i>msg_lrpid</i> is set to the process ID of the calling process.<br><br>              <i>msg_qnum</i> is decremented by 1.<br><br>              <i>msg_rtime</i> is set to the current time.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On failure both functions return -1 with <i>errno</i> indicating the error,<br>       otherwise <b>msgsnd</b>() returns 0 and <b>msgrcv</b>() returns the number of bytes<br>       actually copied into the <i>mtext</i> array.<br></pre><br><h2>ERRORS  </h2><pre><br>       When <b>msgsnd</b>() fails, <i>errno</i> will be set to one among the following<br>       values:<br><br>       <b>EACCES </b>The calling process does not have write permission on the<br>              message queue, and does not have the <b>CAP_IPC_OWNER </b>capability.<br><br>       <b>EAGAIN </b>The message can't be sent due to the <i>msg_qbytes</i> limit for the<br>              queue and <b>IPC_NOWAIT </b>was specified in <i>msgflg</i>.<br><br>       <b>EFAULT </b>The address pointed to by <i>msgp</i> isn't accessible.<br><br>       <b>EIDRM  </b>The message queue was removed.<br><br>       <b>EINTR  </b>Sleeping on a full message queue condition, the process caught<br>              a signal.<br><br>       <b>EINVAL </b>Invalid <i>msqid</i> value, or nonpositive <i>mtype</i> value, or invalid<br>              <i>msgsz</i> value (less than 0 or greater than the system value<br>              <b>MSGMAX</b>).<br><br>       <b>ENOMEM </b>The system does not have enough memory to make a copy of the<br>              message pointed to by <i>msgp</i>.<br><br>       When <b>msgrcv</b>() fails, <i>errno</i> will be set to one among the following<br>       values:<br><br>       <b>E2BIG  </b>The message text length is greater than <i>msgsz</i> and <b>MSG_NOERROR</b><br>              isn't specified in <i>msgflg</i>.<br><br>       <b>EACCES </b>The calling process does not have read permission on the<br>              message queue, and does not have the <b>CAP_IPC_OWNER </b>capability.<br><br>       <b>EFAULT </b>The address pointed to by <i>msgp</i> isn't accessible.<br><br>       <b>EIDRM  </b>While the process was sleeping to receive a message, the<br>              message queue was removed.<br><br>       <b>EINTR  </b>While the process was sleeping to receive a message, the<br>              process caught a signal; see signal(7).<br><br>       <b>EINVAL </b><i>msgqid</i> was invalid, or <i>msgsz</i> was less than 0.<br><br>       <b>EINVAL </b>(since Linux 3.14)<br>              <i>msgflg</i> specified <b>MSG_COPY</b>, but not <b>IPC_NOWAIT</b>.<br><br>       <b>EINVAL </b>(since Linux 3.14)<br>              <i>msgflg</i> specified both <b>MSG_COPY </b>and <b>MSG_EXCEPT</b>.<br><br>       <b>ENOMSG IPC_NOWAIT </b>was specified in <i>msgflg</i> and no message of the<br>              requested type existed on the message queue.<br><br>       <b>ENOMSG IPC_NOWAIT </b>and <b>MSG_COPY </b>were specified in <i>msgflg</i> and the queue<br>              contains less than <i>msgtyp</i> messages.<br><br>       <b>ENOSYS </b>(since Linux 3.8)<br>              <i>MSG_COPY</i> was specified in <i>msgflg</i>, and this kernel was<br>              configured without <b>CONFIG_CHECKPOINT_RESTORE</b>.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008, SVr4.<br><br>       The <b>MSG_EXCEPT </b>and <b>MSG_COPY </b>flags are Linux-specific; their<br>       definitions can be obtained by defining the <b>_GNU_SOURCE </b>feature test<br>       macro.<br></pre><br><h2>NOTES  </h2><pre><br>       The inclusion of <i>&lt;sys/types.h&gt;</i> and <i>&lt;sys/ipc.h&gt;</i> isn't required on<br>       Linux or by any version of POSIX.  However, some old implementations<br>       required the inclusion of these header files, and the SVID also<br>       documented their inclusion.  Applications intended to be portable to<br>       such old systems may need to include these header files.<br><br>       The <i>msgp</i> argument is declared as <i>struct msgbuf *</i> in glibc 2.0 and<br>       2.1.  It is declared as <i>void *</i> in glibc 2.2 and later, as required by<br>       SUSv2 and SUSv3.<br><br>       The following limits on message queue resources affect the <b>msgsnd</b>()<br>       call:<br><br>       <b>MSGMAX </b>Maximum size of a message text, in bytes (default value: 8192<br>              bytes).  On Linux, this limit can be read and modified via<br>              <i>/proc/sys/kernel/msgmax</i>.<br><br>       <b>MSGMNB </b>Maximum number of bytes that can be held in a message queue<br>              (default value: 16384 bytes).  On Linux, this limit can be<br>              read and modified via <i>/proc/sys/kernel/msgmnb</i>.  A privileged<br>              process (Linux: a process with the <b>CAP_SYS_RESOURCE</b><br>              capability) can increase the size of a message queue beyond<br>              <b>MSGMNB </b>using the msgctl(2) <b>IPC_SET </b>operation.<br><br>       The implementation has no intrinsic system-wide limits on the number<br>       of message headers (<b>MSGTQL</b>) and the number of bytes in the message<br>       pool (<b>MSGPOOL</b>).<br></pre><br><h2>BUGS  </h2><pre><br>       In Linux 3.13 and earlier, if <b>msgrcv</b>() was called with the <b>MSG_COPY</b><br>       flag, but without <b>IPC_NOWAIT</b>, and the message queue contained less<br>       than <i>msgtyp</i> messages, then the call would block until the next<br>       message is written to the queue.  At that point, the call would<br>       return a copy of the message, <i>regardless</i> of whether that message was<br>       at the ordinal position <i>msgtyp</i>.  This bug is fixed in Linux 3.14.<br><br>       Specifying both <b>MSG_COPY </b>and <b>MSC_EXCEPT </b>in <i>msgflg</i> is a logical error<br>       (since these flags impose different interpretations on <i>msgtyp</i>).  In<br>       Linux 3.13 and earlier, this error was not diagnosed by <b>msgrcv</b>().<br>       This bug is fixed in Linux 3.14.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The program below demonstrates the use of <b>msgsnd</b>() and <b>msgrcv</b>().<br><br>       The example program is first run with the <b>-s </b>option to send a message<br>       and then run again with the <b>-r </b>option to receive a message.<br><br>       The following shell session shows a sample run of the program:<br><br>           $ <b>./a.out -s</b><br>           sent: a message at Wed Mar  4 16:25:45 2015<br><br>           $ <b>./a.out -r</b><br>           message received: a message at Wed Mar  4 16:25:45 2015<br><br>   <b>Program source</b><br><br>       #include &lt;stdio.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;string.h&gt;<br>       #include &lt;time.h&gt;<br>       #include &lt;unistd.h&gt;<br>       #include &lt;errno.h&gt;<br>       #include &lt;sys/types.h&gt;<br>       #include &lt;sys/ipc.h&gt;<br>       #include &lt;sys/msg.h&gt;<br><br>       struct msgbuf {<br>           long mtype;<br>           char mtext[80];<br>       };<br><br>       static void<br>       usage(char *prog_name, char *msg)<br>       {<br>           if (msg != NULL)<br>               fputs(msg, stderr);<br><br>           fprintf(stderr, \"Usage: %s [options]\\n\", prog_name);<br>           fprintf(stderr, \"Options are:\\n\");<br>           fprintf(stderr, \"-s        send message using msgsnd()\\n\");<br>           fprintf(stderr, \"-r        read message using msgrcv()\\n\");<br>           fprintf(stderr, \"-t        message type (default is 1)\\n\");<br>           fprintf(stderr, \"-k        message queue key (default is 1234)\\n\");<br>           exit(EXIT_FAILURE);<br>       }<br><br>       static void<br>       send_msg(int qid, int msgtype)<br>       {<br>           struct msgbuf msg;<br>           time_t t;<br><br>           msg.mtype = msgtype;<br><br>           time(&amp;t);<br>           snprintf(msg.mtext, sizeof(msg.mtext), \"a message at %s\",<br>                   ctime(&amp;t));<br><br>           if (msgsnd(qid, (void *) &amp;msg, sizeof(msg.mtext),<br>                       IPC_NOWAIT) == -1) {<br>               perror(\"msgsnd error\");<br>               exit(EXIT_FAILURE);<br>           }<br>           printf(\"sent: %s\\n\", msg.mtext);<br>       }<br><br>       static void<br>       get_msg(int qid, int msgtype)<br>       {<br>           struct msgbuf msg;<br><br>           if (msgrcv(qid, (void *) &amp;msg, sizeof(msg.mtext), msgtype,<br>                      MSG_NOERROR | IPC_NOWAIT) == -1) {<br>               if (errno != ENOMSG) {<br>                   perror(\"msgrcv\");<br>                   exit(EXIT_FAILURE);<br>               }<br>               printf(\"No message available for msgrcv()\\n\");<br>           } else<br>               printf(\"message received: %s\\n\", msg.mtext);<br>       }<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           int qid, opt;<br>           int mode = 0;               /* 1 = send, 2 = receive */<br>           int msgtype = 1;<br>           int msgkey = 1234;<br><br>           while ((opt = getopt(argc, argv, \"srt:k:\")) != -1) {<br>               switch (opt) {<br>               case 's':<br>                   mode = 1;<br>                   break;<br>               case 'r':<br>                   mode = 2;<br>                   break;<br>               case 't':<br>                   msgtype = atoi(optarg);<br>                   if (msgtype &lt;= 0)<br>                       usage(argv[0], \"-t option must be greater than 0\\n\");<br>                   break;<br>               case 'k':<br>                   msgkey = atoi(optarg);<br>                   break;<br>               default:<br>                   usage(argv[0], \"Unrecognized option\\n\");<br>               }<br>           }<br><br>           if (mode == 0)<br>               usage(argv[0], \"must use either -s or -r option\\n\");<br><br>           qid = msgget(msgkey, IPC_CREAT | 0666);<br><br>           if (qid == -1) {<br>               perror(\"msgget\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           if (mode == 2)<br>               get_msg(qid, msgtype);<br>           else<br>               send_msg(qid, msgtype);<br><br>           exit(EXIT_SUCCESS);<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       msgctl(2), msgget(2), capabilities(7), mq_overview(7), svipc(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-08-08                         MSGOP(2)</span><br></pre><br>"}