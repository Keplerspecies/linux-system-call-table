{"Man page": "<pre><br><span class=\"headline\">KEXEC_LOAD(2)             Linux Programmer's Manual            KEXEC_LOAD(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       kexec_load, kexec_file_load - load a new kernel for later execution<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;linux/kexec.h&gt;</b><br><br>       <b>long kexec_load(unsigned long </b><i>entry</i><b>, unsigned long </b><i>nr_segments</i><b>,</b><br>                       <b>struct kexec_segment *</b><i>segments</i><b>, unsigned long </b><i>flags</i><b>);</b><br><br>       <b>long kexec_file_load(int </b><i>kernel_fd</i><b>, int </b><i>initrd_fd</i><b>,</b><br>                           <b>unsigned long </b><i>cmdline_len</i><b>, const char *</b><i>cmdline</i><b>,</b><br>                           <b>unsigned long </b><i>flags</i><b>);</b><br><br>       <i>Note</i>: There are no glibc wrappers for these system calls; see NOTES.<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>kexec_load</b>() system call loads a new kernel that can be executed<br>       later by reboot(2).<br><br>       The <i>flags</i> argument is a bit mask that controls the operation of the<br>       call.  The following values can be specified in <i>flags</i>:<br><br>       <b>KEXEC_ON_CRASH </b>(since Linux 2.6.13)<br>              Execute the new kernel automatically on a system crash.  This<br>              \"crash kernel\" is loaded into an area of reserved memory that<br>              is determined at boot time using the <i>craskkernel</i> kernel<br>              command-line parameter.  The location of this reserved memory<br>              is exported to user space via the <i>/proc/iomem</i> file, in an<br>              entry labeled \"Crash kernel\".  A user-space application can<br>              parse this file and prepare a list of segments (see below)<br>              that specify this reserved memory as destination.  If this<br>              flag is specified, the kernel checks that the target segments<br>              specified in <i>segments</i> fall within the reserved region.<br><br>       <b>KEXEC_PRESERVE_CONTEXT </b>(since Linux 2.6.27)<br>              Preserve the system hardware and software states before<br>              executing the new kernel.  This could be used for system<br>              suspend.  This flag is available only if the kernel was<br>              configured with <b>CONFIG_KEXEC_JUMP</b>, and is effective only if<br>              <i>nr_segments</i> is greater than 0.<br><br>       The high-order bits (corresponding to the mask 0xffff0000) of <i>flags</i><br>       contain the architecture of the to-be-executed kernel.  Specify (OR)<br>       the constant <b>KEXEC_ARCH_DEFAULT </b>to use the current architecture, or<br>       one of the following architecture constants <b>KEXEC_ARCH_386</b>,<br>       <b>KEXEC_ARCH_68K</b>, <b>KEXEC_ARCH_X86_64</b>, <b>KEXEC_ARCH_PPC</b>, <b>KEXEC_ARCH_PPC64</b>,<br>       <b>KEXEC_ARCH_IA_64</b>, <b>KEXEC_ARCH_ARM</b>, <b>KEXEC_ARCH_S390</b>, <b>KEXEC_ARCH_SH</b>,<br>       <b>KEXEC_ARCH_MIPS</b>, and <b>KEXEC_ARCH_MIPS_LE</b>.  The architecture must be<br>       executable on the CPU of the system.<br><br>       The <i>entry</i> argument is the physical entry address in the kernel image.<br>       The <i>nr_segments</i> argument is the number of segments pointed to by the<br>       <i>segments</i> pointer; the kernel imposes an (arbitrary) limit of 16 on<br>       the number of segments.  The <i>segments</i> argument is an array of<br>       <i>kexec_segment</i> structures which define the kernel layout:<br><br>           struct kexec_segment {<br>               void   *buf;        /* Buffer in user space */<br>               size_t  bufsz;      /* Buffer length in user space */<br>               void   *mem;        /* Physical address of kernel */<br>               size_t  memsz;      /* Physical address length */<br>           };<br><br>       The kernel image defined by <i>segments</i> is copied from the calling<br>       process into the kernel either in regular memory or in reserved<br>       memory (if <b>KEXEC_ON_CRASH </b>is set).  The kernel first performs various<br>       sanity checks on the information passed in <i>segments</i>.  If these checks<br>       pass, the kernel copies the segment data to kernel memory.  Each<br>       segment specified in <i>segments</i> is copied as follows:<br><br>       *  <i>buf</i> and <i>bufsz</i> identify a memory region in the caller's virtual<br>          address space that is the source of the copy.  The value in <i>bufsz</i><br>          may not exceed the value in the <i>memsz</i> field.<br><br>       *  <i>mem</i> and <i>memsz</i> specify a physical address range that is the target<br>          of the copy.  The values specified in both fields must be<br>          multiples of the system page size.<br><br>       *  <i>bufsz</i> bytes are copied from the source buffer to the target kernel<br>          buffer.  If <i>bufsz</i> is less than <i>memsz</i>, then the excess bytes in the<br>          kernel buffer are zeroed out.<br><br>       In case of a normal kexec (i.e., the <b>KEXEC_ON_CRASH </b>flag is not set),<br>       the segment data is loaded in any available memory and is moved to<br>       the final destination at kexec reboot time (e.g., when the kexec(8)<br>       command is executed with the <i>-e</i> option).<br><br>       In case of kexec on panic (i.e., the <b>KEXEC_ON_CRASH </b>flag is set), the<br>       segment data is loaded to reserved memory at the time of the call,<br>       and, after a crash, the kexec mechanism simply passes control to that<br>       kernel.<br><br>       The <b>kexec_load</b>() system call is available only if the kernel was<br>       configured with <b>CONFIG_KEXEC</b>.<br><br>   <b>kexec_file_load()</b><br>       The <b>kexec_file_load</b>() system call is similar to <b>kexec_load</b>(), but it<br>       takes a different set of arguments.  It reads the kernel to be loaded<br>       from the file referred to by the descriptor <i>kernel_fd</i>, and the initrd<br>       (initial RAM disk) to be loaded from file referred to by the<br>       descriptor <i>initrd_fd</i>.  The <i>cmdline</i> argument is a pointer to a buffer<br>       containing the command line for the new kernel.  The <i>cmdline_len</i><br>       argument specifies size of the buffer.  The last byte in the buffer<br>       must be a null byte ('\\0').<br><br>       The <i>flags</i> argument is a bit mask which modifies the behavior of the<br>       call.  The following values can be specified in <i>flags</i>:<br><br>       <b>KEXEC_FILE_UNLOAD</b><br>              Unload the currently loaded kernel.<br><br>       <b>KEXEC_FILE_ON_CRASH</b><br>              Load the new kernel in the memory region reserved for the<br>              crash kernel (as for <b>KEXEC_ON_CRASH).  </b>This kernel is booted<br>              if the currently running kernel crashes.<br><br>       <b>KEXEC_FILE_NO_INITRAMFS</b><br>              Loading initrd/initramfs is optional.  Specify this flag if no<br>              initramfs is being loaded.  If this flag is set, the value<br>              passed in <i>initrd_fd</i> is ignored.<br><br>       The <b>kexec_file_load</b>() system call was added to provide support for<br>       systems where \"kexec\" loading should be restricted to only kernels<br>       that are signed.  This system call is available only if the kernel<br>       was configured with <b>CONFIG_KEXEC_FILE</b>.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, these system calls returns 0.  On error, -1 is returned<br>       and <i>errno</i> is set to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EADDRNOTAVAIL</b><br>              The <b>KEXEC_ON_CRASH </b>flags was specified, but the region<br>              specified by the <i>mem</i> and <i>memsz</i> fields of one of the <i>segments</i><br>              entries lies outside the range of memory reserved for the<br>              crash kernel.<br><br>       <b>EADDRNOTAVAIL</b><br>              The value in a <i>mem</i> or <i>memsz</i> field in one of the <i>segments</i><br>              entries is not a multiple of the system page size.<br><br>       <b>EBADF  </b><i>kernel_fd</i> or <i>initrd_fd</i> is not a valid file descriptor.<br><br>       <b>EBUSY  </b>Another crash kernel is already being loaded or a crash kernel<br>              is already in use.<br><br>       <b>EINVAL </b><i>flags</i> is invalid.<br><br>       <b>EINVAL </b>The value of a <i>bufsz</i> field in one of the <i>segments</i> entries<br>              exceeds the value in the corresponding <i>memsz</i> field.<br><br>       <b>EINVAL </b><i>nr_segments</i> exceeds <b>KEXEC_SEGMENT_MAX </b>(16).<br><br>       <b>EINVAL </b>Two or more of the kernel target buffers overlap.<br><br>       <b>EINVAL </b>The value in <i>cmdline[cmdline_len-1]</i> is not '\\0'.<br><br>       <b>EINVAL </b>The file referred to by <i>kernel_fd</i> or <i>initrd_fd</i> is empty<br>              (length zero).<br><br>       <b>ENOMEM </b>Could not allocate memory.<br><br>       <b>ENOEXEC</b><br>              <i>kernel_fd</i> does not refer to an open file, or the kernel can't<br>              load this file.  Currently, the file must be a bzImage and<br>              contain an x86 kernel that is loadable above 4GiB in memory<br>              (see the kernel source file <i>Documentation/x86/boot.txt</i>).<br><br>       <b>EPERM  </b>The caller does not have the <b>CAP_SYS_BOOT </b>capability.<br></pre><br><h2>VERSIONS  </h2><pre><br>       The <b>kexec_load</b>() system call first appeared in Linux 2.6.13.  The<br>       <b>kexec_file_load</b>() system call first appeared in Linux 3.17.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       These system calls are Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       Currently, there is no glibc support for these system calls.  Call<br>       them using syscall(2).<br></pre><br><h2>SEE ALSO  </h2><pre><br>       reboot(2), syscall(2), kexec(8)<br><br>       The kernel source files <i>Documentation/kdump/kdump.txt</i> and<br>       <i>Documentation/kernel-parameters.txt</i>.<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-02-01                    KEXEC_LOAD(2)</span><br></pre><br>"}