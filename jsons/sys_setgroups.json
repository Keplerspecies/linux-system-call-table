{"Man page": "<pre><br><span class=\"headline\">GETGROUPS(2)              Linux Programmer's Manual             GETGROUPS(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       getgroups, setgroups - get/set list of supplementary group IDs<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/types.h&gt;</b><br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>int getgroups(int </b><i>size</i><b>, gid_t </b><i>list</i><b>[]);</b><br><br>       <b>#include &lt;grp.h&gt;</b><br><br>       <b>int setgroups(size_t </b><i>size</i><b>, const gid_t *</b><i>list</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>setgroups</b>(): _BSD_SOURCE<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>getgroups</b>() returns the supplementary group IDs of the calling<br>       process in <i>list</i>.  The argument <i>size</i> should be set to the maximum<br>       number of items that can be stored in the buffer pointed to by <i>list</i>.<br>       If the calling process is a member of more than <i>size</i> supplementary<br>       groups, then an error results.  It is unspecified whether the<br>       effective group ID of the calling process is included in the returned<br>       list.  (Thus, an application should also call getegid(2) and add or<br>       remove the resulting value.)<br><br>       If <i>size</i> is zero, <i>list</i> is not modified, but the total number of<br>       supplementary group IDs for the process is returned.  This allows the<br>       caller to determine the size of a dynamically allocated <i>list</i> to be<br>       used in a further call to <b>getgroups</b>().<br><br>       <b>setgroups</b>() sets the supplementary group IDs for the calling process.<br>       Appropriate privileges (Linux: the <b>CAP_SETGID </b>capability) are<br>       required.  The <i>size</i> argument specifies the number of supplementary<br>       group IDs in the buffer pointed to by <i>list</i>.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>getgroups</b>() returns the number of supplementary group<br>       IDs.  On error, -1 is returned, and <i>errno</i> is set appropriately.<br><br>       On success, <b>setgroups</b>() returns 0.  On error, -1 is returned, and<br>       <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EFAULT </b><i>list</i> has an invalid address.<br><br>       <b>getgroups</b>() can additionally fail with the following error:<br><br>       <b>EINVAL </b><i>size</i> is less than the number of supplementary group IDs, but<br>              is not zero.<br><br>       <b>setgroups</b>() can additionally fail with the following errors:<br><br>       <b>EINVAL </b><i>size</i> is greater than <b>NGROUPS_MAX </b>(32 before Linux 2.6.4; 65536<br>              since Linux 2.6.4).<br><br>       <b>ENOMEM </b>Out of memory.<br><br>       <b>EPERM  </b>The calling process has insufficient privilege (it does not<br>              have the <b>CAP_SETGID </b>capability).<br><br>       <b>EPERM </b>(since Linux 3.19)<br>              The use of <b>setgroups</b>() is denied in this user namespace.  See<br>              the description of <i>/proc/[pid]/setgroups</i> in<br>              user_namespaces(7).<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       SVr4, 4.3BSD.  The <b>getgroups</b>() function is in POSIX.1-2001 and<br>       POSIX.1-2008.  Since <b>setgroups</b>() requires privilege, it is not<br>       covered by POSIX.1.<br></pre><br><h2>NOTES  </h2><pre><br>       A process can have up to <b>NGROUPS_MAX </b>supplementary group IDs in<br>       addition to the effective group ID.  The constant <b>NGROUPS_MAX </b>is<br>       defined in <i>&lt;limits.h&gt;</i>.  The set of supplementary group IDs is<br>       inherited from the parent process, and preserved across an execve(2).<br><br>       The maximum number of supplementary group IDs can be found at run<br>       time using sysconf(3):<br><br>           long ngroups_max;<br>           ngroups_max = sysconf(_SC_NGROUPS_MAX);<br><br>       The maximum return value of <b>getgroups</b>() cannot be larger than one<br>       more than this value.  Since Linux 2.6.4, the maximum number of<br>       supplementary group IDs is also exposed via the Linux-specific read-<br>       only file, <i>/proc/sys/kernel/ngroups_max</i>.<br><br>       The original Linux <b>getgroups</b>() system call supported only 16-bit<br>       group IDs.  Subsequently, Linux 2.4 added <b>getgroups32</b>(), supporting<br>       32-bit IDs.  The glibc <b>getgroups</b>() wrapper function transparently<br>       deals with the variation across kernel versions.<br><br>   <b>C library/kernel differences</b><br>       At the kernel level, user IDs and group IDs are a per-thread<br>       attribute.  However, POSIX requires that all threads in a process<br>       share the same credentials.  The NPTL threading implementation<br>       handles the POSIX requirements by providing wrapper functions for the<br>       various system calls that change process UIDs and GIDs.  These<br>       wrapper functions (including the one for <b>setgroups</b>()) employ a<br>       signal-based technique to ensure that when one thread changes<br>       credentials, all of the other threads in the process also change<br>       their credentials.  For details, see nptl(7).<br></pre><br><h2>SEE ALSO  </h2><pre><br>       getgid(2), setgid(2), getgrouplist(3), group_member(3),<br>       initgroups(3), capabilities(7), credentials(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                     GETGROUPS(2)</span><br></pre><br>"}