{"Man page": "<pre><br><span class=\"headline\">CLOCK_NANOSLEEP(2)        Linux Programmer's Manual       CLOCK_NANOSLEEP(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       clock_nanosleep - high-resolution sleep with specifiable clock<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;time.h&gt;</b><br><br>       <b>int clock_nanosleep(clockid_t </b><i>clock_id</i><b>, int </b><i>flags</i><b>,</b><br>                           <b>const struct timespec *</b><i>request</i><b>,</b><br>                           <b>struct timespec *</b><i>remain</i><b>);</b><br><br>       Link with <i>-lrt</i> (only for glibc versions before 2.17).<br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>clock_nanosleep</b>():<br>           _XOPEN_SOURCE &gt;= 600 || _POSIX_C_SOURCE &gt;= 200112L<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       Like nanosleep(2), <b>clock_nanosleep</b>() allows the calling thread to<br>       sleep for an interval specified with nanosecond precision.  It<br>       differs in allowing the caller to select the clock against which the<br>       sleep interval is to be measured, and in allowing the sleep interval<br>       to be specified as either an absolute or a relative value.<br><br>       The time values passed to and returned by this call are specified<br>       using <i>timespec</i> structures, defined as follows:<br><br>           struct timespec {<br>               time_t tv_sec;        /* seconds */<br>               long   tv_nsec;       /* nanoseconds [0 .. 999999999] */<br>           };<br><br>       The <i>clock_id</i> argument specifies the clock against which the sleep<br>       interval is to be measured.  This argument can have one of the<br>       following values:<br><br>       <b>CLOCK_REALTIME   </b>A settable system-wide real-time clock.<br><br>       <b>CLOCK_MONOTONIC  </b>A nonsettable, monotonically increasing clock that<br>                        measures time since some unspecified point in the<br>                        past that does not change after system startup.<br><br>       <b>CLOCK_PROCESS_CPUTIME_ID</b><br>                        A settable per-process clock that measures CPU time<br>                        consumed by all threads in the process.<br><br>       See clock_getres(2) for further details on these clocks.  In<br>       addition, the CPU clock IDs returned by clock_getcpuclockid(3) and<br>       pthread_getcpuclockid(3) can also be passed in <i>clock_id</i>.<br><br>       If <i>flags</i> is 0, then the value specified in <i>request</i> is interpreted as<br>       an interval relative to the current value of the clock specified by<br>       <i>clock_id</i>.<br><br>       If <i>flags</i> is <b>TIMER_ABSTIME</b>, then <i>request</i> is interpreted as an absolute<br>       time as measured by the clock, <i>clock_id</i>.  If <i>request</i> is less than or<br>       equal to the current value of the clock, then <b>clock_nanosleep</b>()<br>       returns immediately without suspending the calling thread.<br><br>       <b>clock_nanosleep</b>() suspends the execution of the calling thread until<br>       either at least the time specified by <i>request</i> has elapsed, or a<br>       signal is delivered that causes a signal handler to be called or that<br>       terminates the process.<br><br>       If the call is interrupted by a signal handler, <b>clock_nanosleep</b>()<br>       fails with the error <b>EINTR</b>.  In addition, if <i>remain</i> is not NULL, and<br>       <i>flags</i> was not <b>TIMER_ABSTIME</b>, it returns the remaining unslept time in<br>       <i>remain</i>.  This value can then be used to call <b>clock_nanosleep</b>() again<br>       and complete a (relative) sleep.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On successfully sleeping for the requested interval,<br>       <b>clock_nanosleep</b>() returns 0.  If the call is interrupted by a signal<br>       handler or encounters an error, then it returns one of the positive<br>       error number listed in ERRORS.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EFAULT </b><i>request</i> or <i>remain</i> specified an invalid address.<br><br>       <b>EINTR  </b>The sleep was interrupted by a signal handler.<br><br>       <b>EINVAL </b>The value in the <i>tv_nsec</i> field was not in the range 0 to<br>              999999999 or <i>tv_sec</i> was negative.<br><br>       <b>EINVAL </b><i>clock_id</i> was invalid.  (<b>CLOCK_THREAD_CPUTIME_ID </b>is not a<br>              permitted value for <i>clock_id</i>.)<br></pre><br><h2>VERSIONS  </h2><pre><br>       The <b>clock_nanosleep</b>() system call first appeared in Linux 2.6.<br>       Support is available in glibc since version 2.1.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008.<br></pre><br><h2>NOTES  </h2><pre><br>       If the interval specified in <i>request</i> is not an exact multiple of the<br>       granularity underlying clock (see time(7)), then the interval will be<br>       rounded up to the next multiple.  Furthermore, after the sleep<br>       completes, there may still be a delay before the CPU becomes free to<br>       once again execute the calling thread.<br><br>       Using an absolute timer is useful for preventing timer drift problems<br>       of the type described in nanosleep(2).  (Such problems are<br>       exacerbated in programs that try to restart a relative sleep that is<br>       repeatedly interrupted by signals.)  To perform a relative sleep that<br>       avoids these problems, call clock_gettime(2) for the desired clock,<br>       add the desired interval to the returned time value, and then call<br>       <b>clock_nanosleep</b>() with the <b>TIMER_ABSTIME </b>flag.<br><br>       <b>clock_nanosleep</b>() is never restarted after being interrupted by a<br>       signal handler, regardless of the use of the sigaction(2) <b>SA_RESTART</b><br>       flag.<br><br>       The <i>remain</i> argument is unused, and unnecessary, when <i>flags</i> is<br>       <b>TIMER_ABSTIME</b>.  (An absolute sleep can be restarted using the same<br>       <i>request</i> argument.)<br><br>       POSIX.1 specifies that <b>clock_nanosleep</b>() has no effect on signals<br>       dispositions or the signal mask.<br><br>       POSIX.1 specifies that after changing the value of the <b>CLOCK_REALTIME</b><br>       clock via clock_settime(2), the new clock value shall be used to<br>       determine the time at which a thread blocked on an absolute<br>       <b>clock_nanosleep</b>() will wake up; if the new clock value falls past the<br>       end of the sleep interval, then the <b>clock_nanosleep</b>() call will<br>       return immediately.<br><br>       POSIX.1 specifies that changing the value of the <b>CLOCK_REALTIME </b>clock<br>       via clock_settime(2) shall have no effect on a thread that is blocked<br>       on a relative <b>clock_nanosleep</b>().<br></pre><br><h2>SEE ALSO  </h2><pre><br>       clock_getres(2), nanosleep(2), restart_syscall(2), timer_create(2),<br>       sleep(3), usleep(3), time(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-08-08               CLOCK_NANOSLEEP(2)</span><br></pre><br>"}