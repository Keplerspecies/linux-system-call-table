{"Man page": "<pre><br><span class=\"headline\">BPF(2)                    Linux Programmer's Manual                   BPF(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       bpf - perform a command on an extended BPF map or program<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;linux/bpf.h&gt;</b><br><br>       <b>int bpf(int </b><i>cmd</i><b>, union bpf_attr *</b><i>attr</i><b>, unsigned int </b><i>size</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>bpf</b>() system call performs a range of operations related to<br>       extended Berkeley Packet Filters.  Extended BPF (or eBPF) is similar<br>       to the original (\"classic\") BPF (cBPF) used to filter network<br>       packets.  For both cBPF and eBPF programs, the kernel statically<br>       analyzes the programs before loading them, in order to ensure that<br>       they cannot harm the running system.<br><br>       eBPF extends cBPF in multiple ways, including the ability to call a<br>       fixed set of in-kernel helper functions (via the <b>BPF_CALL </b>opcode<br>       extension provided by eBPF) and access shared data structures such as<br>       eBPF maps.<br><br>   <b>Extended BPF Design/Architecture</b><br>       eBPF maps are a generic data structure for storage of different data<br>       types.  Data types are generally treated as binary blobs, so a user<br>       just specifies the size of the key and the size of the value at map-<br>       creation time.  In other words, a key/value for a given map can have<br>       an arbitrary structure.<br><br>       A user process can create multiple maps (with key/value-pairs being<br>       opaque bytes of data) and access them via file descriptors.<br>       Different eBPF programs can access the same maps in parallel.  It's<br>       up to the user process and eBPF program to decide what they store<br>       inside maps.<br><br>       There's one special map type, called a program array.  This type of<br>       map stores file descriptors referring to other eBPF programs.  When a<br>       lookup in the map is performed, the program flow is redirected in-<br>       place to the beginning of another eBPF program and does not return<br>       back to the calling program.  The level of nesting has a fixed limit<br>       of 32, so that infinite loops cannot be crafted.  At runtime, the<br>       program file descriptors stored in the map can be modified, so<br>       program functionality can be altered based on specific requirements.<br>       All programs referred to in a program-array map must have been<br>       previously loaded into the kernel via <b>bpf</b>().  If a map lookup fails,<br>       the current program continues its execution.  See<br>       <b>BPF_MAP_TYPE_PROG_ARRAY </b>below for further details.<br><br>       Generally, eBPF programs are loaded by the user process and<br>       automatically unloaded when the process exits.  In some cases, for<br>       example, tc-bpf(8), the program will continue to stay alive inside<br>       the kernel even after the the process that loaded the program exits.<br>       In that case, the tc subsystem holds a reference to the eBPF program<br>       after the file descriptor has been closed by the user-space program.<br>       Thus, whether a specific program continues to live inside the kernel<br>       depends on how it is further attached to a given kernel subsystem<br>       after it was loaded via <b>bpf</b>().<br><br>       Each eBPF program is a set of instructions that is safe to run until<br>       its completion.  An in-kernel verifier statically determines that the<br>       eBPF program terminates and is safe to execute.  During verification,<br>       the kernel increments reference counts for each of the maps that the<br>       eBPF program uses, so that the attached maps can't be removed until<br>       the program is unloaded.<br><br>       eBPF programs can be attached to different events.  These events can<br>       be the arrival of network packets, tracing events, classification<br>       events by network queueing  disciplines (for eBPF programs attached<br>       to a tc(8) classifier), and other types that may be added in the<br>       future.  A new event triggers execution of the eBPF program, which<br>       may store information about the event in eBPF maps.  Beyond storing<br>       data, eBPF programs may call a fixed set of in-kernel helper<br>       functions.<br><br>       The same eBPF program can be attached to multiple events and<br>       different eBPF programs can access the same map:<br><br>           tracing     tracing    tracing    packet      packet     packet<br>           event A     event B    event C    on eth0     on eth1    on eth2<br>            |             |         |          |           |          ^<br>            |             |         |          |           v          |<br>            --&gt; tracing &lt;--     tracing      socket    tc ingress   tc egress<br>                 prog_1          prog_2      prog_3    classifier    action<br>                 |  |              |           |         prog_4      prog_5<br>              |---  -----|  |------|          map_3        |           |<br>            map_1       map_2                              --| map_4 |--<br><br>   <b>Arguments</b><br>       The operation to be performed by the <b>bpf</b>() system call is determined<br>       by the <i>cmd</i> argument.  Each operation takes an accompanying argument,<br>       provided via <i>attr</i>, which is a pointer to a union of type <i>bpf_attr</i><br>       (see below).  The <i>size</i> argument is the size of the union pointed to<br>       by <i>attr</i>.<br><br>       The value provided in <i>cmd</i> is one of the following:<br><br>       <b>BPF_MAP_CREATE</b><br>              Create a map and return a file descriptor that refers to the<br>              map.<br><br>       <b>BPF_MAP_LOOKUP_ELEM</b><br>              Look up an element by key in a specified map and return its<br>              value.<br><br>       <b>BPF_MAP_UPDATE_ELEM</b><br>              Create or update an element (key/value pair) in a specified<br>              map.<br><br>       <b>BPF_MAP_DELETE_ELEM</b><br>              Look up and delete an element by key in a specified map.<br><br>       <b>BPF_MAP_GET_NEXT_KEY</b><br>              Look up an element by key in a specified map and return the<br>              key of the next element.<br><br>       <b>BPF_PROG_LOAD</b><br>              Verify and load an eBPF program, returning a new file<br>              descriptor associated with the program.<br><br>       The <i>bpf_attr</i> union consists of various anonymous structures that are<br>       used by different <b>bpf</b>() commands:<br><br>           union bpf_attr {<br>               struct {    /* Used by BPF_MAP_CREATE */<br>                   __u32         map_type;<br>                   __u32         key_size;    /* size of key in bytes */<br>                   __u32         value_size;  /* size of value in bytes */<br>                   __u32         max_entries; /* maximum number of entries<br>                                                 in a map */<br>               };<br><br>               struct {    /* Used by BPF_MAP_*_ELEM and BPF_MAP_GET_NEXT_KEY<br>                              commands */<br>                   __u32         map_fd;<br>                   __aligned_u64 key;<br>                   union {<br>                       __aligned_u64 value;<br>                       __aligned_u64 next_key;<br>                   };<br>                   __u64         flags;<br>               };<br><br>               struct {    /* Used by BPF_PROG_LOAD */<br>                   __u32         prog_type;<br>                   __u32         insn_cnt;<br>                   __aligned_u64 insns;      /* 'const struct bpf_insn *' */<br>                   __aligned_u64 license;    /* 'const char *' */<br>                   __u32         log_level;  /* verbosity level of verifier */<br>                   __u32         log_size;   /* size of user buffer */<br>                   __aligned_u64 log_buf;    /* user supplied 'char *'<br>                                                buffer */<br>                   __u32         kern_version;<br>                                             /* checked when prog_type=kprobe<br>                                                (since Linux 4.1) */<br>               };<br>           } __attribute__((aligned(8)));<br><br>   <b>eBPF maps</b><br>       Maps are a generic data structure for storage of different types of<br>       data.  They allow sharing of data between eBPF kernel programs, and<br>       also between kernel and user-space applications.<br><br>       Each map type has the following attributes:<br><br>       *  type<br>       *  maximum number of elements<br>       *  key size in bytes<br>       *  value size in bytes<br><br>       The following wrapper functions demonstrate how various <b>bpf</b>()<br>       commands can be used to access the maps.  The functions use the <i>cmd</i><br>       argument to invoke different operations.<br><br>       <b>BPF_MAP_CREATE</b><br>              The <b>BPF_MAP_CREATE </b>command creates a new map, returning a new<br>              file descriptor that refers to the map.<br><br>                  int<br>                  bpf_create_map(enum bpf_map_type map_type,<br>                                 unsigned int key_size,<br>                                 unsigned int value_size,<br>                                 unsigned int max_entries)<br>                  {<br>                      union bpf_attr attr = {<br>                          .map_type    = map_type,<br>                          .key_size    = key_size,<br>                          .value_size  = value_size,<br>                          .max_entries = max_entries<br>                      };<br><br>                      return bpf(BPF_MAP_CREATE, &amp;attr, sizeof(attr));<br>                  }<br><br>              The new map has the type specified by <i>map_type</i>, and attributes<br>              as specified in <i>key_size</i>, <i>value_size</i>, and <i>max_entries</i>.  On<br>              success, this operation returns a file descriptor.  On error,<br>              -1 is returned and <i>errno</i> is set to <b>EINVAL</b>, <b>EPERM</b>, or <b>ENOMEM</b>.<br><br>              The <i>key_size</i> and <i>value_size</i> attributes will be used by the<br>              verifier during program loading to check that the program is<br>              calling <b>bpf_map_*_elem</b>() helper functions with a correctly<br>              initialized <i>key</i> and to check that the program doesn't access<br>              the map element <i>value</i> beyond the specified <i>value_size</i>.  For<br>              example, when a map is created with a <i>key_size</i> of 8 and the<br>              eBPF program calls<br><br>                  bpf_map_lookup_elem(map_fd, fp - 4)<br><br>              the program will be rejected, since the in-kernel helper<br>              function<br><br>                  bpf_map_lookup_elem(map_fd, void *key)<br><br>              expects to read 8 bytes from the location pointed to by <i>key</i>,<br>              but the <i>fp - 4</i> (where <i>fp</i> is the top of the stack) starting<br>              address will cause out-of-bounds stack access.<br><br>              Similarly, when a map is created with a <i>value_size</i> of 1 and<br>              the eBPF program contains<br><br>                  value = bpf_map_lookup_elem(...);<br>                  *(u32 *) value = 1;<br><br>              the program will be rejected, since it accesses the <i>value</i><br>              pointer beyond the specified 1 byte <i>value_size</i> limit.<br><br>              Currently, the following values are supported for <i>map_type</i>:<br><br>                  enum bpf_map_type {<br>                      BPF_MAP_TYPE_UNSPEC,  /* Reserve 0 as invalid map type */<br>                      BPF_MAP_TYPE_HASH,<br>                      BPF_MAP_TYPE_ARRAY,<br>                      BPF_MAP_TYPE_PROG_ARRAY,<br>                  };<br><br>              <i>map_type</i> selects one of the available map implementations in<br>              the kernel.  For all map types, eBPF programs access maps with<br>              the same <b>bpf_map_lookup_elem</b>() and <b>bpf_map_update_elem</b>()<br>              helper functions.  Further details of the various map types<br>              are given below.<br><br>       <b>BPF_MAP_LOOKUP_ELEM</b><br>              The <b>BPF_MAP_LOOKUP_ELEM </b>command looks up an element with a<br>              given <i>key</i> in the map referred to by the file descriptor <i>fd</i>.<br><br>                  int<br>                  bpf_lookup_elem(int fd, const void *key, void *value)<br>                  {<br>                      union bpf_attr attr = {<br>                          .map_fd = fd,<br>                          .key    = ptr_to_u64(key),<br>                          .value  = ptr_to_u64(value),<br>                      };<br><br>                      return bpf(BPF_MAP_LOOKUP_ELEM, &amp;attr, sizeof(attr));<br>                  }<br><br>              If an element is found, the operation returns zero and stores<br>              the element's value into <i>value</i>, which must point to a buffer<br>              of <i>value_size</i> bytes.<br><br>              If no element is found, the operation returns -1 and sets<br>              <i>errno</i> to <b>ENOENT</b>.<br><br>       <b>BPF_MAP_UPDATE_ELEM</b><br>              The <b>BPF_MAP_UPDATE_ELEM </b>command creates or updates an element<br>              with a given <i>key/value</i> in the map referred to by the file<br>              descriptor <i>fd</i>.<br><br>                  int<br>                  bpf_update_elem(int fd, const void *key, const void *value,<br>                                  uint64_t flags)<br>                  {<br>                      union bpf_attr attr = {<br>                          .map_fd = fd,<br>                          .key    = ptr_to_u64(key),<br>                          .value  = ptr_to_u64(value),<br>                          .flags  = flags,<br>                      };<br><br>                      return bpf(BPF_MAP_UPDATE_ELEM, &amp;attr, sizeof(attr));<br>                  }<br><br>              The <i>flags</i> argument should be specified as one of the<br>              following:<br><br>              <b>BPF_ANY</b><br>                     Create a new element or update an existing element.<br><br>              <b>BPF_NOEXIST</b><br>                     Create a new element only if it did not exist.<br><br>              <b>BPF_EXIST</b><br>                     Update an existing element.<br><br>              On success, the operation returns zero.  On error, -1 is<br>              returned and <i>errno</i> is set to <b>EINVAL</b>, <b>EPERM</b>, <b>ENOMEM</b>, or <b>E2BIG</b>.<br>              <b>E2BIG </b>indicates that the number of elements in the map reached<br>              the <i>max_entries</i> limit specified at map creation time.  <b>EEXIST</b><br>              will be returned if <i>flags</i> specifies <b>BPF_NOEXIST </b>and the<br>              element with <i>key</i> already exists in the map.  <b>ENOENT </b>will be<br>              returned if <i>flags</i> specifies <b>BPF_EXIST </b>and the element with <i>key</i><br>              doesn't exist in the map.<br><br>       <b>BPF_MAP_DELETE_ELEM</b><br>              The <b>BPF_MAP_DELETE_ELEM </b>command deleted the element whose key<br>              is <i>key</i> from the map referred to by the file descriptor <i>fd</i>.<br><br>                  int<br>                  bpf_delete_elem(int fd, const void *key)<br>                  {<br>                      union bpf_attr attr = {<br>                          .map_fd = fd,<br>                          .key    = ptr_to_u64(key),<br>                      };<br><br>                      return bpf(BPF_MAP_DELETE_ELEM, &amp;attr, sizeof(attr));<br>                  }<br><br>              On success, zero is returned.  If the element is not found, -1<br>              is returned and <i>errno</i> is set to <b>ENOENT</b>.<br><br>       <b>BPF_MAP_GET_NEXT_KEY</b><br>              The <b>BPF_MAP_GET_NEXT_KEY </b>command looks up an element by <i>key</i> in<br>              the map referred to by the file descriptor <i>fd</i> and sets the<br>              <i>next_key</i> pointer to the key of the next element.<br><br>                  int<br>                  bpf_get_next_key(int fd, const void *key, void *next_key)<br>                  {<br>                      union bpf_attr attr = {<br>                          .map_fd   = fd,<br>                          .key      = ptr_to_u64(key),<br>                          .next_key = ptr_to_u64(next_key),<br>                      };<br><br>                      return bpf(BPF_MAP_GET_NEXT_KEY, &amp;attr, sizeof(attr));<br>                  }<br><br>              If <i>key</i> is found, the operation returns zero and sets the<br>              <i>next_key</i> pointer to the key of the next element.  If <i>key</i> is<br>              not found, the operation returns zero and sets the <i>next_key</i><br>              pointer to the key of the first element.  If <i>key</i> is the last<br>              element, -1 is returned and <i>errno</i> is set to <b>ENOENT</b>.  Other<br>              possible <i>errno</i> values are <b>ENOMEM</b>, <b>EFAULT</b>, <b>EPERM</b>, and <b>EINVAL</b>.<br>              This method can be used to iterate over all elements in the<br>              map.<br><br>       <b>close(map_fd)</b><br>              Delete the map referred to by the file descriptor <i>map_fd</i>.<br>              When the user-space program that created a map exits, all maps<br>              will be deleted automatically (but see NOTES).<br><br>   <b>eBPF map types</b><br>       The following map types are supported:<br><br>       <b>BPF_MAP_TYPE_HASH</b><br>              Hash-table maps have the following characteristics:<br><br>              *  Maps are created and destroyed by user-space programs.<br>                 Both user-space and eBPF programs can perform lookup,<br>                 update, and delete operations.<br><br>              *  The kernel takes care of allocating and freeing key/value<br>                 pairs.<br><br>              *  The <b>map_update_elem</b>() helper with fail to insert new<br>                 element when the <i>max_entries</i> limit is reached.  (This<br>                 ensures that eBPF programs cannot exhaust memory.)<br><br>              *  <b>map_update_elem</b>() replaces existing elements atomically.<br><br>              Hash-table maps are optimized for speed of lookup.<br><br>       <b>BPF_MAP_TYPE_ARRAY</b><br>              Array maps have the following characteristics:<br><br>              *  Optimized for fastest possible lookup.  In the future the<br>                 verifier/JIT compiler may recognize lookup() operations<br>                 that employ a constant key and optimize it into constant<br>                 pointer.  It is possible to optimize a non-constant key<br>                 into direct pointer arithmetic as well, since pointers and<br>                 <i>value_size</i> are constant for the life of the eBPF program.<br>                 In other words, <b>array_map_lookup_elem</b>() may be 'inlined' by<br>                 the verifier/JIT compiler while preserving concurrent<br>                 access to this map from user space.<br><br>              *  All array elements pre-allocated and zero initialized at<br>                 init time<br><br>              *  The key is an array index, and must be exactly four bytes.<br><br>              *  <b>map_delete_elem</b>() fails with the error <b>EINVAL</b>, since<br>                 elements cannot be deleted.<br><br>              *  <b>map_update_elem</b>() replaces elements in a <b>nonatomic </b>fashion;<br>                 for atomic updates, a hash-table map should be used<br>                 instead.  There is however one special case that can also<br>                 be used with arrays: the atomic built-in<br>                 <b>__sync_fetch_and_add() </b>can be used on 32 and 64 bit atomic<br>                 counters.  For example, it can be applied on the whole<br>                 value itself if it represents a single counter, or in case<br>                 of a structure containing multiple counters, it could be<br>                 used on individual counters.  This is quite often useful<br>                 for aggregation and accounting of events.<br><br>              Among the uses for array maps are the following:<br><br>              *  As \"global\" eBPF variables: an array of 1 element whose key<br>                 is (index) 0 and where the value is a collection of<br>                 'global' variables which eBPF programs can use to keep<br>                 state between events.<br><br>              *  Aggregation of tracing events into a fixed set of buckets.<br><br>              *  Accounting of networking events, for example, number of<br>                 packets and packet sizes.<br><br>       <b>BPF_MAP_TYPE_PROG_ARRAY </b>(since Linux 4.2)<br>              A program array map is a special kind of array map whose map<br>              values contain only file descriptors referring to other eBPF<br>              programs.  Thus, both the <i>key_size</i> and <i>value_size</i> must be<br>              exactly four bytes.  This map is used in conjunction with the<br>              <b>bpf_tail_call</b>() helper.<br><br>              This means that an eBPF program with a program array map<br>              attached to it can call from kernel side into<br><br>                  void bpf_tail_call(void *context, void *prog_map, unsigned int index);<br><br>              and therefore replace its own program flow with the one from<br>              the program at the given program array slot, if present.  This<br>              can be regarded as kind of a jump table to a different eBPF<br>              program.  The invoked program will then reuse the same stack.<br>              When a jump into the new program has been performed, it won't<br>              return to the old program anymore.<br><br>              If no eBPF program is found at the given index of the program<br>              array (because the map slot doesn't contain a valid program<br>              file descriptor, the specified lookup index/key is out of<br>              bounds, or the limit of 32 nested calls has been exceed),<br>              execution continues with the current eBPF program.  This can<br>              be used as a fall-through for default cases.<br><br>              A program array map is useful, for example, in tracing or<br>              networking, to handle individual system calls or protocols in<br>              their own subprograms and use their identifiers as an<br>              individual map index.  This approach may result in performance<br>              benefits, and also makes it possible to overcome the maximum<br>              instruction limit of a single eBPF program.  In dynamic<br>              environments, a user-space daemon might atomically replace<br>              individual subprograms at run-time with newer versions to<br>              alter overall program behavior, for instance, if global<br>              policies change.<br><br>   <b>eBPF programs</b><br>       The <b>BPF_PROG_LOAD </b>command is used to load an eBPF program into the<br>       kernel.  The return value for this command is a new file descriptor<br>       associated with this eBPF program.<br><br>           char bpf_log_buf[LOG_BUF_SIZE];<br><br>           int<br>           bpf_prog_load(enum bpf_prog_type type,<br>                         const struct bpf_insn *insns, int insn_cnt,<br>                         const char *license)<br>           {<br>               union bpf_attr attr = {<br>                   .prog_type = type,<br>                   .insns     = ptr_to_u64(insns),<br>                   .insn_cnt  = insn_cnt,<br>                   .license   = ptr_to_u64(license),<br>                   .log_buf   = ptr_to_u64(bpf_log_buf),<br>                   .log_size  = LOG_BUF_SIZE,<br>                   .log_level = 1,<br>               };<br><br>               return bpf(BPF_PROG_LOAD, &amp;attr, sizeof(attr));<br>           }<br><br>       <i>prog_type</i> is one of the available program types:<br><br>           enum bpf_prog_type {<br>               BPF_PROG_TYPE_UNSPEC,        /* Reserve 0 as invalid<br>                                               program type */<br>               BPF_PROG_TYPE_SOCKET_FILTER,<br>               BPF_PROG_TYPE_KPROBE,<br>               BPF_PROG_TYPE_SCHED_CLS,<br>               BPF_PROG_TYPE_SCHED_ACT,<br>           };<br><br>       For further details of eBPF program types, see below.<br><br>       The remaining fields of <i>bpf_attr</i> are set as follows:<br><br>       *  <i>insns</i> is an array of <i>struct bpf_insn</i> instructions.<br><br>       *  <i>insn_cnt</i> is the number of instructions in the program referred to<br>          by <i>insns</i>.<br><br>       *  <i>license</i> is a license string, which must be GPL compatible to call<br>          helper functions marked <i>gpl_only</i>.  (The licensing rules are the<br>          same as for kernel modules, so that also dual licenses, such as<br>          \"Dual BSD/GPL\", may be used.)<br><br>       *  <i>log_buf</i> is a pointer to a caller-allocated buffer in which the in-<br>          kernel verifier can store the verification log.  This log is a<br>          multi-line string that can be checked by the program author in<br>          order to understand how the verifier came to the conclusion that<br>          the eBPF program is unsafe.  The format of the output can change<br>          at any time as the verifier evolves.<br><br>       *  <i>log_size</i> size of the buffer pointed to by <i>log_bug</i>.  If the size of<br>          the buffer is not large enough to store all verifier messages, -1<br>          is returned and <i>errno</i> is set to <b>ENOSPC</b>.<br><br>       *  <i>log_level</i> verbosity level of the verifier.  A value of zero means<br>          that the verifier will not provide a log; in this case, <i>log_buf</i><br>          must be a NULL pointer, and <i>log_size</i> must be zero.<br><br>       Applying close(2) to the file descriptor returned by <b>BPF_PROG_LOAD</b><br>       will unload the eBPF program (but see NOTES).<br><br>       Maps are accessible from eBPF programs and are used to exchange data<br>       between eBPF programs and between eBPF programs and user-space<br>       programs.  For example, eBPF programs can process various events<br>       (like kprobe, packets) and store their data into a map, and user-<br>       space programs can then fetch data from the map.  Conversely, user-<br>       space programs can use a map as a configuration mechanism, populating<br>       the map with values checked by the eBPF program, which then modifies<br>       its behavior on the fly according to those values.<br><br>   <b>eBPF program types</b><br>       The eBPF program type (<i>prog_type</i>) determines the subset of kernel<br>       helper functions that the program may call.  The program type also<br>       determines the program input (context)&#8212;the format of <i>struct</i><br>       <i>bpf_context</i> (which is the data blob passed into the eBPF program as<br>       the first argument).<br><br>       For example, a tracing program does not have the exact same subset of<br>       helper functions as a socket filter program (though they may have<br>       some helpers in common).  Similarly, the input (context) for a<br>       tracing program is a set of register values, while for a socket<br>       filter it is a network packet.<br><br>       The set of functions available to eBPF programs of a given type may<br>       increase in the future.<br><br>       The following program types are supported:<br><br>       <b>BPF_PROG_TYPE_SOCKET_FILTER </b>(since Linux 3.19)<br>              Currently, the set of functions for<br>              <b>BPF_PROG_TYPE_SOCKET_FILTER </b>is:<br><br>                  bpf_map_lookup_elem(map_fd, void *key)<br>                                      /* look up key in a map_fd */<br>                  bpf_map_update_elem(map_fd, void *key, void *value)<br>                                      /* update key/value */<br>                  bpf_map_delete_elem(map_fd, void *key)<br>                                      /* delete key in a map_fd */<br><br>              The <i>bpf_context</i> argument is a pointer to a <i>struct __sk_buff</i>.<br><br>       <b>BPF_PROG_TYPE_KPROBE </b>(since Linux 4.1)<br>              [To be documented]<br><br>       <b>BPF_PROG_TYPE_SCHED_CLS </b>(since Linux 4.1)<br>              [To be documented]<br><br>       <b>BPF_PROG_TYPE_SCHED_ACT </b>(since Linux 4.1)<br>              [To be documented]<br><br>   <b>Events</b><br>       Once a program is loaded, it can be attached to an event.  Various<br>       kernel subsystems have different ways to do so.<br><br>       Since Linux 3.19, the following call will attach the program <i>prog_fd</i><br>       to the socket <i>sockfd</i>, which was created by an earlier call to<br>       socket(2):<br><br>           setsockopt(sockfd, SOL_SOCKET, SO_ATTACH_BPF,<br>                      &amp;prog_fd, sizeof(prog_fd));<br><br>       Since Linux 4.1, the following call may be used to attach the eBPF<br>       program referred to by the file descriptor <i>prog_fd</i> to a perf event<br>       file descriptor, <i>event_fd</i>, that was created by a previous call to<br>       perf_event_open(2):<br><br>           ioctl(event_fd, PERF_EVENT_IOC_SET_BPF, prog_fd);<br></pre><br><h2>EXAMPLES  </h2><pre><br>       /* bpf+sockets example:<br>        * 1. create array map of 256 elements<br>        * 2. load program that counts number of packets received<br>        *    r0 = skb-&gt;data[ETH_HLEN + offsetof(struct iphdr, protocol)]<br>        *    map[r0]++<br>        * 3. attach prog_fd to raw socket via setsockopt()<br>        * 4. print number of received TCP/UDP packets every second<br>        */<br>       int<br>       main(int argc, char **argv)<br>       {<br>           int sock, map_fd, prog_fd, key;<br>           long long value = 0, tcp_cnt, udp_cnt;<br><br>           map_fd = bpf_create_map(BPF_MAP_TYPE_ARRAY, sizeof(key),<br>                                   sizeof(value), 256);<br>           if (map_fd &lt; 0) {<br>               printf(\"failed to create map '%s'\\n\", strerror(errno));<br>               /* likely not run as root */<br>               return 1;<br>           }<br><br>           struct bpf_insn prog[] = {<br>               BPF_MOV64_REG(BPF_REG_6, BPF_REG_1),        /* r6 = r1 */<br>               BPF_LD_ABS(BPF_B, ETH_HLEN + offsetof(struct iphdr, protocol)),<br>                                       /* r0 = ip-&gt;proto */<br>               BPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_0, -4),<br>                                       /* *(u32 *)(fp - 4) = r0 */<br>               BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),       /* r2 = fp */<br>               BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -4),      /* r2 = r2 - 4 */<br>               BPF_LD_MAP_FD(BPF_REG_1, map_fd),           /* r1 = map_fd */<br>               BPF_CALL_FUNC(BPF_FUNC_map_lookup_elem),<br>                                       /* r0 = map_lookup(r1, r2) */<br>               BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2),<br>                                       /* if (r0 == 0) goto pc+2 */<br>               BPF_MOV64_IMM(BPF_REG_1, 1),                /* r1 = 1 */<br>               BPF_XADD(BPF_DW, BPF_REG_0, BPF_REG_1, 0, 0),<br>                                       /* lock *(u64 *) r0 += r1 */<br>               BPF_MOV64_IMM(BPF_REG_0, 0),                /* r0 = 0 */<br>               BPF_EXIT_INSN(),                            /* return r0 */<br>           };<br><br>           prog_fd = bpf_prog_load(BPF_PROG_TYPE_SOCKET_FILTER, prog,<br>                                   sizeof(prog), \"GPL\");<br><br>           sock = open_raw_sock(\"lo\");<br><br>           assert(setsockopt(sock, SOL_SOCKET, SO_ATTACH_BPF, &amp;prog_fd,<br>                             sizeof(prog_fd)) == 0);<br><br>           for (;;) {<br>               key = IPPROTO_TCP;<br>               assert(bpf_lookup_elem(map_fd, &amp;key, &amp;tcp_cnt) == 0);<br>               key = IPPROTO_UDP<br>               assert(bpf_lookup_elem(map_fd, &amp;key, &amp;udp_cnt) == 0);<br>               printf(\"TCP %lld UDP %lld packets0, tcp_cnt, udp_cnt);<br>               sleep(1);<br>           }<br><br>           return 0;<br>       }<br><br>       Some complete working code can be found in the <i>samples/bpf</i> directory<br>       in the kernel source tree.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       For a successful call, the return value depends on the operation:<br><br>       <b>BPF_MAP_CREATE</b><br>              The new file descriptor associated with the eBPF map.<br><br>       <b>BPF_PROG_LOAD</b><br>              The new file descriptor associated with the eBPF program.<br><br>       All other commands<br>              Zero.<br><br>       On error, -1 is returned, and <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EPERM  </b>The call was made without sufficient privilege (without the<br>              <b>CAP_SYS_ADMIN </b>capability).<br><br>       <b>ENOMEM </b>Cannot allocate sufficient memory.<br><br>       <b>EBADF  </b><i>fd</i> is not an open file descriptor.<br><br>       <b>EFAULT </b>One of the pointers (<i>key</i> or <i>value</i> or <i>log_buf</i> or <i>insns</i>) is<br>              outside the accessible address space.<br><br>       <b>EINVAL </b>The value specified in <i>cmd</i> is not recognized by this kernel.<br><br>       <b>EINVAL </b>For <b>BPF_MAP_CREATE</b>, either <i>map_type</i> or attributes are invalid.<br><br>       <b>EINVAL </b>For <b>BPF_MAP_*_ELEM </b>commands, some of the fields of <i>union</i><br>              <i>bpf_attr</i> that are not used by this command are not set to<br>              zero.<br><br>       <b>EINVAL </b>For <b>BPF_PROG_LOAD, </b>indicates an attempt to load an invalid<br>              program.  eBPF programs can be deemed invalid due to<br>              unrecognized instructions, the use of reserved fields, jumps<br>              out of range, infinite loops or calls of unknown functions.<br><br>       <b>EACCES </b>For <b>BPF_PROG_LOAD, </b>even though all program instructions are<br>              valid, the program has been rejected because it was deemed<br>              unsafe.  This may be because it may have accessed a disallowed<br>              memory region or an uninitialized stack/register or because<br>              the function constraints don't match the actual types or<br>              because there was a misaligned memory access.  In this case,<br>              it is recommended to call <b>bpf</b>() again with <i>log_level = 1</i> and<br>              examine <i>log_buf</i> for the specific reason provided by the<br>              verifier.<br><br>       <b>ENOENT </b>For <b>BPF_MAP_LOOKUP_ELEM </b>or <b>BPF_MAP_DELETE_ELEM</b>, indicates that<br>              the element with the given <i>key</i> was not found.<br><br>       <b>E2BIG  </b>The eBPF program is too large or a map reached the <i>max_entries</i><br>              limit (maximum number of elements).<br></pre><br><h2>VERSIONS  </h2><pre><br>       The <b>bpf</b>() system call first appeared in Linux 3.18.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       The <b>bpf</b>() system call is Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       In the current implementation, all <b>bpf</b>() commands require the caller<br>       to have the <b>CAP_SYS_ADMIN </b>capability.<br><br>       eBPF objects (maps and programs) can be shared between processes.<br>       For example, after fork(2), the child inherits file descriptors<br>       referring to the same eBPF objects.  In addition, file descriptors<br>       referring to eBPF objects can be transferred over UNIX domain<br>       sockets.  File descriptors referring to eBPF objects can be<br>       duplicated in the usual way, using dup(2) and similar calls.  An eBPF<br>       object is deallocated only after all file descriptors referring to<br>       the object have been closed.<br><br>       eBPF programs can be written in a restricted C that is compiled<br>       (using the <b>clang </b>compiler) into eBPF bytecode.  Various features are<br>       omitted from this restricted C, such as loops, global variables,<br>       variadic functions, floating-point numbers, and passing structures as<br>       function arguments.  Some examples can be found in the<br>       <i>samples/bpf/*_kern.c</i> files in the kernel source tree.<br><br>       The kernel contains a just-in-time (JIT) compiler that translates<br>       eBPF bytecode into native machine code for better performance.  The<br>       JIT compiler is disabled by default, but its operation can be<br>       controlled by writing one of the following integer strings to the<br>       file <i>/proc/sys/net/core/bpf_jit_enable</i>:<br><br>       0  Disable JIT compilation (default).<br><br>       1  Normal compilation.<br><br>       2  Debugging mode.  The generated opcodes are dumped in hexadecimal<br>          into the kernel log.  These opcodes can then be disassembled using<br>          the program <i>tools/net/bpf_jit_disasm.c</i> provided in the kernel<br>          source tree.<br><br>       JIT compiler for eBPF is currently available for the x86-64, arm64,<br>       and s390 architectures.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       seccomp(2), socket(7), tc(8), tc-bpf(8)<br><br>       Both classic and extended BPF are explained in the kernel source file<br>       <i>Documentation/networking/filter.txt</i>.<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                           BPF(2)</span><br></pre><br>"}