{"Man page": "<pre><br><span class=\"headline\">CAPGET(2)                 Linux Programmer's Manual                CAPGET(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       capget, capset - set/get capabilities of thread(s)<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/capability.h&gt;</b><br><br>       <b>int capget(cap_user_header_t </b><i>hdrp</i><b>, cap_user_data_t </b><i>datap</i><b>);</b><br><br>       <b>int capset(cap_user_header_t </b><i>hdrp</i><b>, const cap_user_data_t </b><i>datap</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       As of Linux 2.2, the power of the superuser (root) has been<br>       partitioned into a set of discrete capabilities.  Each thread has a<br>       set of effective capabilities identifying which capabilities (if any)<br>       it may currently exercise.  Each thread also has a set of inheritable<br>       capabilities that may be passed through an execve(2) call, and a set<br>       of permitted capabilities that it can make effective or inheritable.<br><br>       These two system calls are the raw kernel interface for getting and<br>       setting thread capabilities.  Not only are these system calls<br>       specific to Linux, but the kernel API is likely to change and use of<br>       these system calls (in particular the format of the <i>cap_user_*_t</i><br>       types) is subject to extension with each kernel revision, but old<br>       programs will keep working.<br><br>       The portable interfaces are cap_set_proc(3) and cap_get_proc(3); if<br>       possible, you should use those interfaces in applications.  If you<br>       wish to use the Linux extensions in applications, you should use the<br>       easier-to-use interfaces capsetp(3) and capgetp(3).<br><br>   <b>Current details</b><br>       Now that you have been warned, some current kernel details.  The<br>       structures are defined as follows.<br><br>           #define _LINUX_CAPABILITY_VERSION_1  0x19980330<br>           #define _LINUX_CAPABILITY_U32S_1     1<br><br>                   /* V2 added in Linux 2.6.25; deprecated */<br>           #define _LINUX_CAPABILITY_VERSION_2  0x20071026<br>           #define _LINUX_CAPABILITY_U32S_2     2<br><br>                   /* V3 added in Linux 2.6.26 */<br>           #define _LINUX_CAPABILITY_VERSION_3  0x20080522<br>           #define _LINUX_CAPABILITY_U32S_3     2<br><br>           typedef struct __user_cap_header_struct {<br>              __u32 version;<br>              int pid;<br>           } *cap_user_header_t;<br><br>           typedef struct __user_cap_data_struct {<br>              __u32 effective;<br>              __u32 permitted;<br>              __u32 inheritable;<br>           } *cap_user_data_t;<br><br>       The <i>effective</i>, <i>permitted</i>, and <i>inheritable</i> fields are bit masks of the<br>       capabilities defined in capabilities(7).  Note that the <b>CAP_* </b>values<br>       are bit indexes and need to be bit-shifted before ORing into the bit<br>       fields.  To define the structures for passing to the system call, you<br>       have to use the <i>struct __user_cap_header_struct</i> and <i>struct</i><br>       <i>__user_cap_data_struct</i> names because the typedefs are only pointers.<br><br>       Kernels prior to 2.6.25 prefer 32-bit capabilities with version<br>       <b>_LINUX_CAPABILITY_VERSION_1</b>.  Linux 2.6.25 added 64-bit capability<br>       sets, with version <b>_LINUX_CAPABILITY_VERSION_2</b>.  There was, however,<br>       an API glitch, and Linux 2.6.26 added <b>_LINUX_CAPABILITY_VERSION_3 </b>to<br>       fix the problem.<br><br>       Note that 64-bit capabilities use <i>datap</i>[0] and <i>datap</i>[1], whereas<br>       32-bit capabilities use only <i>datap</i>[0].<br><br>       On kernels that support file capabilities (VFS capability support),<br>       these system calls behave slightly differently.  This support was<br>       added as an option in Linux 2.6.24, and became fixed (nonoptional) in<br>       Linux 2.6.33.<br><br>       For <b>capget</b>() calls, one can probe the capabilities of any process by<br>       specifying its process ID with the <i>hdrp-&gt;pid</i> field value.<br><br>   <b>With VFS capability support</b><br>       VFS Capability support creates a file-attribute method for adding<br>       capabilities to privileged executables.  This privilege model<br>       obsoletes kernel support for one process asynchronously setting the<br>       capabilities of another.  That is, with VFS support, for <b>capset</b>()<br>       calls the only permitted values for <i>hdrp-&gt;pid</i> are 0 or gettid(2),<br>       which are equivalent.<br><br>   <b>Without VFS capability support</b><br>       When the kernel does not support VFS capabilities, <b>capset</b>() calls can<br>       operate on the capabilities of the thread specified by the <i>pid</i> field<br>       of <i>hdrp</i> when that is nonzero, or on the capabilities of the calling<br>       thread if <i>pid</i> is 0.  If <i>pid</i> refers to a single-threaded process, then<br>       <i>pid</i> can be specified as a traditional process ID; operating on a<br>       thread of a multithreaded process requires a thread ID of the type<br>       returned by gettid(2).  For <b>capset</b>(), <i>pid</i> can also be: -1, meaning<br>       perform the change on all threads except the caller and init(1); or a<br>       value less than -1, in which case the change is applied to all<br>       members of the process group whose ID is -<i>pid</i>.<br><br>       For details on the data, see capabilities(7).<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, zero is returned.  On error, -1 is returned, and <i>errno</i> is<br>       set appropriately.<br><br>       The calls will fail with the error <b>EINVAL</b>, and set the <i>version</i> field<br>       of <i>hdrp</i> to the kernel preferred value of <b>_LINUX_CAPABILITY_VERSION_?</b><br>       when an unsupported <i>version</i> value is specified.  In this way, one can<br>       probe what the current preferred capability revision is.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EFAULT </b>Bad memory address.  <i>hdrp</i> must not be NULL.  <i>datap</i> may be NULL<br>              only when the user is trying to determine the preferred<br>              capability version format supported by the kernel.<br><br>       <b>EINVAL </b>One of the arguments was invalid.<br><br>       <b>EPERM  </b>An attempt was made to add a capability to the Permitted set,<br>              or to set a capability in the Effective or Inheritable sets<br>              that is not in the Permitted set.<br><br>       <b>EPERM  </b>The caller attempted to use <b>capset</b>() to modify the<br>              capabilities of a thread other than itself, but lacked<br>              sufficient privilege.  For kernels supporting VFS<br>              capabilities, this is never permitted.  For kernels lacking<br>              VFS support, the <b>CAP_SETPCAP </b>capability is required.  (A bug<br>              in kernels before 2.6.11 meant that this error could also<br>              occur if a thread without this capability tried to change its<br>              own capabilities by specifying the <i>pid</i> field as a nonzero<br>              value (i.e., the value returned by getpid(2)) instead of 0.)<br><br>       <b>ESRCH  </b>No such thread.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       These system calls are Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       The portable interface to the capability querying and setting<br>       functions is provided by the <i>libcap</i> library and is available here:<br>       &#10216;http://git.kernel.org/cgit/linux/kernel/git/morgan/libcap.git&#10217;<br></pre><br><h2>SEE ALSO  </h2><pre><br>       clone(2), gettid(2), capabilities(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                        CAPGET(2)</span><br></pre><br>"}