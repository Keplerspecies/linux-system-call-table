{"Man page": "<pre><br><span class=\"headline\">SIGNALFD(2)               Linux Programmer's Manual              SIGNALFD(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       signalfd - create a file descriptor for accepting signals<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/signalfd.h&gt;</b><br><br>       <b>int signalfd(int </b><i>fd</i><b>, const sigset_t *</b><i>mask</i><b>, int </b><i>flags</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>signalfd</b>() creates a file descriptor that can be used to accept<br>       signals targeted at the caller.  This provides an alternative to the<br>       use of a signal handler or sigwaitinfo(2), and has the advantage that<br>       the file descriptor may be monitored by select(2), poll(2), and<br>       epoll(7).<br><br>       The <i>mask</i> argument specifies the set of signals that the caller wishes<br>       to accept via the file descriptor.  This argument is a signal set<br>       whose contents can be initialized using the macros described in<br>       sigsetops(3).  Normally, the set of signals to be received via the<br>       file descriptor should be blocked using sigprocmask(2), to prevent<br>       the signals being handled according to their default dispositions.<br>       It is not possible to receive <b>SIGKILL </b>or <b>SIGSTOP </b>signals via a<br>       signalfd file descriptor; these signals are silently ignored if<br>       specified in <i>mask</i>.<br><br>       If the <i>fd</i> argument is -1, then the call creates a new file descriptor<br>       and associates the signal set specified in <i>mask</i> with that descriptor.<br>       If <i>fd</i> is not -1, then it must specify a valid existing signalfd file<br>       descriptor, and <i>mask</i> is used to replace the signal set associated<br>       with that descriptor.<br><br>       Starting with Linux 2.6.27, the following values may be bitwise ORed<br>       in <i>flags</i> to change the behavior of <b>signalfd</b>():<br><br>       <b>SFD_NONBLOCK  </b>Set the <b>O_NONBLOCK </b>file status flag on the new open<br>                     file description.  Using this flag saves extra calls to<br>                     fcntl(2) to achieve the same result.<br><br>       <b>SFD_CLOEXEC   </b>Set the close-on-exec (<b>FD_CLOEXEC</b>) flag on the new file<br>                     descriptor.  See the description of the <b>O_CLOEXEC </b>flag<br>                     in open(2) for reasons why this may be useful.<br><br>       In Linux up to version 2.6.26, the <i>flags</i> argument is unused, and must<br>       be specified as zero.<br><br>       <b>signalfd</b>() returns a file descriptor that supports the following<br>       operations:<br><br>       read(2)<br>              If one or more of the signals specified in <i>mask</i> is pending for<br>              the process, then the buffer supplied to read(2) is used to<br>              return one or more <i>signalfd_siginfo</i> structures (see below)<br>              that describe the signals.  The read(2) returns information<br>              for as many signals as are pending and will fit in the<br>              supplied buffer.  The buffer must be at least <i>sizeof(struct</i><br>              <i>signalfd_siginfo)</i> bytes.  The return value of the read(2) is<br>              the total number of bytes read.<br><br>              As a consequence of the read(2), the signals are consumed, so<br>              that they are no longer pending for the process (i.e., will<br>              not be caught by signal handlers, and cannot be accepted using<br>              sigwaitinfo(2)).<br><br>              If none of the signals in <i>mask</i> is pending for the process,<br>              then the read(2) either blocks until one of the signals in<br>              <i>mask</i> is generated for the process, or fails with the error<br>              <b>EAGAIN </b>if the file descriptor has been made nonblocking.<br><br>       poll(2), select(2) (and similar)<br>              The file descriptor is readable (the select(2) <i>readfds</i><br>              argument; the poll(2) <b>POLLIN </b>flag) if one or more of the<br>              signals in <i>mask</i> is pending for the process.<br><br>              The signalfd file descriptor also supports the other file-<br>              descriptor multiplexing APIs: pselect(2), ppoll(2), and<br>              epoll(7).<br><br>       close(2)<br>              When the file descriptor is no longer required it should be<br>              closed.  When all file descriptors associated with the same<br>              signalfd object have been closed, the resources for object are<br>              freed by the kernel.<br><br>   <b>The signalfd_siginfo structure</b><br>       The format of the <i>signalfd_siginfo</i> structure(s) returned by read(2)s<br>       from a signalfd file descriptor is as follows:<br><br>           struct signalfd_siginfo {<br>               uint32_t ssi_signo;   /* Signal number */<br>               int32_t  ssi_errno;   /* Error number (unused) */<br>               int32_t  ssi_code;    /* Signal code */<br>               uint32_t ssi_pid;     /* PID of sender */<br>               uint32_t ssi_uid;     /* Real UID of sender */<br>               int32_t  ssi_fd;      /* File descriptor (SIGIO) */<br>               uint32_t ssi_tid;     /* Kernel timer ID (POSIX timers)<br>               uint32_t ssi_band;    /* Band event (SIGIO) */<br>               uint32_t ssi_overrun; /* POSIX timer overrun count */<br>               uint32_t ssi_trapno;  /* Trap number that caused signal */<br>               int32_t  ssi_status;  /* Exit status or signal (SIGCHLD) */<br>               int32_t  ssi_int;     /* Integer sent by sigqueue(3) */<br>               uint64_t ssi_ptr;     /* Pointer sent by sigqueue(3) */<br>               uint64_t ssi_utime;   /* User CPU time consumed (SIGCHLD) */<br>               uint64_t ssi_stime;   /* System CPU time consumed (SIGCHLD) */<br>               uint64_t ssi_addr;    /* Address that generated signal<br>                                        (for hardware-generated signals) */<br>               uint8_t  pad[<i>X</i>];      /* Pad size to 128 bytes (allow for<br>                                         additional fields in the future) */<br>           };<br><br>       Each of the fields in this structure is analogous to the similarly<br>       named field in the <i>siginfo_t</i> structure.  The <i>siginfo_t</i> structure is<br>       described in sigaction(2).  Not all fields in the returned<br>       <i>signalfd_siginfo</i> structure will be valid for a specific signal; the<br>       set of valid fields can be determined from the value returned in the<br>       <i>ssi_code</i> field.  This field is the analog of the <i>siginfo_t si_code</i><br>       field; see sigaction(2) for details.<br><br>   <b>fork(2) semantics</b><br>       After a fork(2), the child inherits a copy of the signalfd file<br>       descriptor.  A read(2) from the file descriptor in the child will<br>       return information about signals queued to the child.<br><br>   <b>execve(2) semantics</b><br>       Just like any other file descriptor, a signalfd file descriptor<br>       remains open across an execve(2), unless it has been marked for<br>       close-on-exec (see fcntl(2)).  Any signals that were available for<br>       reading before the execve(2) remain available to the newly loaded<br>       program.  (This is analogous to traditional signal semantics, where a<br>       blocked signal that is pending remains pending across an execve(2).)<br><br>   <b>Thread semantics</b><br>       The semantics of signalfd file descriptors in a multithreaded program<br>       mirror the standard semantics for signals.  In other words, when a<br>       thread reads from a signalfd file descriptor, it will read the<br>       signals that are directed to the thread itself and the signals that<br>       are directed to the process (i.e., the entire thread group).  (A<br>       thread will not be able to read signals that are directed to other<br>       threads in the process.)<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>signalfd</b>() returns a signalfd file descriptor; this is<br>       either a new file descriptor (if <i>fd</i> was -1), or <i>fd</i> if <i>fd</i> was a valid<br>       signalfd file descriptor.  On error, -1 is returned and <i>errno</i> is set<br>       to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EBADF  </b>The <i>fd</i> file descriptor is not a valid file descriptor.<br><br>       <b>EINVAL </b><i>fd</i> is not a valid signalfd file descriptor.<br><br>       <b>EINVAL </b><i>flags</i> is invalid; or, in Linux 2.6.26 or earlier, <i>flags</i> is<br>              nonzero.<br><br>       <b>EMFILE </b>The per-process limit of open file descriptors has been<br>              reached.<br><br>       <b>ENFILE </b>The system-wide limit on the total number of open files has<br>              been reached.<br><br>       <b>ENODEV </b>Could not mount (internal) anonymous inode device.<br><br>       <b>ENOMEM </b>There was insufficient memory to create a new signalfd file<br>              descriptor.<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>signalfd</b>() is available on Linux since kernel 2.6.22.  Working<br>       support is provided in glibc since version 2.8.  The <b>signalfd4</b>()<br>       system call (see NOTES) is available on Linux since kernel 2.6.27.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>signalfd</b>() and <b>signalfd4</b>() are Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       A process can create multiple signalfd file descriptors.  This makes<br>       it possible to accept different signals on different file<br>       descriptors.  (This may be useful if monitoring the file descriptors<br>       using select(2), poll(2), or epoll(7): the arrival of different<br>       signals will make different descriptors ready.)  If a signal appears<br>       in the <i>mask</i> of more than one of the file descriptors, then<br>       occurrences of that signal can be read (once) from any one of the<br>       descriptors.<br><br>   <b>C library/kernel differences</b><br>       The underlying Linux system call requires an additional argument,<br>       <i>size_t sizemask</i>, which specifies the size of the <i>mask</i> argument.  The<br>       glibc <b>signalfd</b>() wrapper function does not include this argument,<br>       since it provides the required value for the underlying system call.<br><br>       There are two underlying Linux system calls: <b>signalfd</b>() and the more<br>       recent <b>signalfd4</b>().  The former system call does not implement a<br>       <i>flags</i> argument.  The latter system call implements the <i>flags</i> values<br>       described above.  Starting with glibc 2.9, the <b>signalfd</b>() wrapper<br>       function will use <b>signalfd4</b>() where it is available.<br></pre><br><h2>BUGS  </h2><pre><br>       In kernels before 2.6.25, the <i>ssi_ptr</i> and <i>ssi_int</i> fields are not<br>       filled in with the data accompanying a signal sent by sigqueue(3).<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The program below accepts the signals <b>SIGINT </b>and <b>SIGQUIT </b>via a<br>       signalfd file descriptor.  The program terminates after accepting a<br>       <b>SIGQUIT </b>signal.  The following shell session demonstrates the use of<br>       the program:<br><br>           $ <b>./signalfd_demo</b><br>           <b>^C                   </b># Control-C generates SIGINT<br>           Got SIGINT<br>           <b>^C</b><br>           Got SIGINT<br>           <b>^\\                    </b># Control-\\ generates SIGQUIT<br>           Got SIGQUIT<br>           $<br><br>   <b>Program source</b><br><br>       #include &lt;sys/signalfd.h&gt;<br>       #include &lt;signal.h&gt;<br>       #include &lt;unistd.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;stdio.h&gt;<br><br>       #define handle_error(msg) \\<br>           do { perror(msg); exit(EXIT_FAILURE); } while (0)<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           sigset_t mask;<br>           int sfd;<br>           struct signalfd_siginfo fdsi;<br>           ssize_t s;<br><br>           sigemptyset(&amp;mask);<br>           sigaddset(&amp;mask, SIGINT);<br>           sigaddset(&amp;mask, SIGQUIT);<br><br>           /* Block signals so that they aren't handled<br>              according to their default dispositions */<br><br>           if (sigprocmask(SIG_BLOCK, &amp;mask, NULL) == -1)<br>               handle_error(\"sigprocmask\");<br><br>           sfd = signalfd(-1, &amp;mask, 0);<br>           if (sfd == -1)<br>               handle_error(\"signalfd\");<br><br>           for (;;) {<br>               s = read(sfd, &amp;fdsi, sizeof(struct signalfd_siginfo));<br>               if (s != sizeof(struct signalfd_siginfo))<br>                   handle_error(\"read\");<br><br>               if (fdsi.ssi_signo == SIGINT) {<br>                   printf(\"Got SIGINT\\n\");<br>               } else if (fdsi.ssi_signo == SIGQUIT) {<br>                   printf(\"Got SIGQUIT\\n\");<br>                   exit(EXIT_SUCCESS);<br>               } else {<br>                   printf(\"Read unexpected signal\\n\");<br>               }<br>           }<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       eventfd(2), poll(2), read(2), select(2), sigaction(2),<br>       sigprocmask(2), sigwaitinfo(2), timerfd_create(2), sigsetops(3),<br>       sigwait(3), epoll(7), signal(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                      SIGNALFD(2)</span><br></pre><br>"}