{"Man page": "<pre><br><span class=\"headline\">POSIX_FADVISE(2)          Linux Programmer's Manual         POSIX_FADVISE(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       posix_fadvise - predeclare an access pattern for file data<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;fcntl.h&gt;</b><br><br>       <b>int posix_fadvise(int </b><i>fd</i><b>, off_t </b><i>offset</i><b>, off_t </b><i>len</i><b>, int </b><i>advice</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>posix_fadvise</b>():<br>           _XOPEN_SOURCE &gt;= 600 || _POSIX_C_SOURCE &gt;= 200112L<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       Programs can use <b>posix_fadvise</b>() to announce an intention to access<br>       file data in a specific pattern in the future, thus allowing the<br>       kernel to perform appropriate optimizations.<br><br>       The <i>advice</i> applies to a (not necessarily existent) region starting at<br>       <i>offset</i> and extending for <i>len</i> bytes (or until the end of the file if<br>       <i>len</i> is 0) within the file referred to by <i>fd</i>.  The <i>advice</i> is not<br>       binding; it merely constitutes an expectation on behalf of the<br>       application.<br><br>       Permissible values for <i>advice</i> include:<br><br>       <b>POSIX_FADV_NORMAL</b><br>              Indicates that the application has no advice to give about its<br>              access pattern for the specified data.  If no advice is given<br>              for an open file, this is the default assumption.<br><br>       <b>POSIX_FADV_SEQUENTIAL</b><br>              The application expects to access the specified data<br>              sequentially (with lower offsets read before higher ones).<br><br>       <b>POSIX_FADV_RANDOM</b><br>              The specified data will be accessed in random order.<br><br>       <b>POSIX_FADV_NOREUSE</b><br>              The specified data will be accessed only once.<br><br>       <b>POSIX_FADV_WILLNEED</b><br>              The specified data will be accessed in the near future.<br><br>       <b>POSIX_FADV_DONTNEED</b><br>              The specified data will not be accessed in the near future.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, zero is returned.  On error, an error number is returned.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EBADF  </b>The <i>fd</i> argument was not a valid file descriptor.<br><br>       <b>EINVAL </b>An invalid value was specified for <i>advice</i>.<br><br>       <b>ESPIPE </b>The specified file descriptor refers to a pipe or FIFO.<br>              (<b>ESPIPE </b>is the error specified by POSIX, but before kernel<br>              version 2.16, Linux returned <b>EINVAL </b>in this case.)<br></pre><br><h2>VERSIONS  </h2><pre><br>       Kernel support first appeared in Linux 2.5.60; the underlying system<br>       call is called <b>fadvise64</b>().  Library support has been provided since<br>       glibc version 2.2, via the wrapper function <b>posix_fadvise</b>().<br><br>       Since Linux 3.18, support for the underlying system call is optional,<br>       depending on the setting of the <b>CONFIG_ADVISE_SYSCALLS </b>configuration<br>       option.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008.  Note that the type of the <i>len</i> argument<br>       was changed from <i>size_t</i> to <i>off_t</i> in POSIX.1-2003 TC1.<br></pre><br><h2>NOTES  </h2><pre><br>       Under Linux, <b>POSIX_FADV_NORMAL </b>sets the readahead window to the<br>       default size for the backing device; <b>POSIX_FADV_SEQUENTIAL </b>doubles<br>       this size, and <b>POSIX_FADV_RANDOM </b>disables file readahead entirely.<br>       These changes affect the entire file, not just the specified region<br>       (but other open file handles to the same file are unaffected).<br><br>       <b>POSIX_FADV_WILLNEED </b>initiates a nonblocking read of the specified<br>       region into the page cache.  The amount of data read may be decreased<br>       by the kernel depending on virtual memory load.  (A few megabytes<br>       will usually be fully satisfied, and more is rarely useful.)<br><br>       In kernels before 2.6.18, <b>POSIX_FADV_NOREUSE </b>had the same semantics<br>       as <b>POSIX_FADV_WILLNEED</b>.  This was probably a bug; since kernel<br>       2.6.18, this flag is a no-op.<br><br>       <b>POSIX_FADV_DONTNEED </b>attempts to free cached pages associated with the<br>       specified region.  This is useful, for example, while streaming large<br>       files.  A program may periodically request the kernel to free cached<br>       data that has already been used, so that more useful cached pages are<br>       not discarded instead.<br><br>       Requests to discard partial pages are ignored.  It is preferable to<br>       preserve needed data than discard unneeded data.  If the application<br>       requires that data be considered for discarding then <i>offset</i> and <i>len</i><br>       must be page-aligned.<br><br>       Pages that have not yet been written out will be unaffected, so if<br>       the application wishes to guarantee that pages will be released, it<br>       should call fsync(2) or fdatasync(2) first.<br><br>   <b>C library/kernel differences</b><br>       The name of the wrapper function in the C library is <b>posix_fadvise</b>().<br>       The underlying system call is called <b>fadvise64</b>() (or, on some<br>       architectures, <b>fadvise64_64</b>()).<br><br>   <b>Architecture-specific variants</b><br>       Some architectures require 64-bit arguments to be aligned in a<br>       suitable pair of registers (see syscall(2) for further detail).  On<br>       such architectures, the call signature of <b>posix_fadvise</b>() shown in<br>       the SYNOPSIS would force a register to be wasted as padding between<br>       the <i>fd</i> and <i>offset</i> arguments.  Therefore, these architectures define a<br>       version of the system call that orders the arguments suitably, but is<br>       otherwise exactly the same as <b>posix_fadvise</b>().<br><br>       For example, since Linux 2.6.14, ARM has the following system call:<br><br>           <b>long arm_fadvise64_64(int </b><i>fd</i><b>, int </b><i>advice</i><b>,</b><br>                                 <b>loff_t </b><i>offset</i><b>, loff_t </b><i>len</i><b>);</b><br><br>       These architecture-specific details are generally hidden from<br>       applications by the glibc <b>posix_fadvise</b>() wrapper function, which<br>       invokes the appropriate architecture-specific system call.<br></pre><br><h2>BUGS  </h2><pre><br>       In kernels before 2.6.6, if <i>len</i> was specified as 0, then this was<br>       interpreted literally as \"zero bytes\", rather than as meaning \"all<br>       bytes through to the end of the file\".<br></pre><br><h2>SEE ALSO  </h2><pre><br>       readahead(2), sync_file_range(2), posix_fallocate(3),<br>       posix_madvise(3)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                 POSIX_FADVISE(2)</span><br></pre><br>"}