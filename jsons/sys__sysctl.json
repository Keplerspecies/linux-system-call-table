{"Man page": "<pre><br><span class=\"headline\">SYSCTL(2)                 Linux Programmer's Manual                SYSCTL(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       sysctl - read/write system parameters<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;unistd.h&gt;</b><br>       <b>#include &lt;linux/sysctl.h&gt;</b><br><br>       <b>int _sysctl(struct __sysctl_args *</b><i>args</i><b>);</b><br><br>       <i>Note</i>: There is no glibc wrapper for this system call; see NOTES.<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>Do not use this system call!  </b>See NOTES.<br><br>       The <b>_sysctl</b>() call reads and/or writes kernel parameters.  For<br>       example, the hostname, or the maximum number of open files.  The<br>       argument has the form<br><br>           struct __sysctl_args {<br>               int    *name;    /* integer vector describing variable */<br>               int     nlen;    /* length of this vector */<br>               void   *oldval;  /* 0 or address where to store old value */<br>               size_t *oldlenp; /* available room for old value,<br>                                   overwritten by actual size of old value */<br>               void   *newval;  /* 0 or address of new value */<br>               size_t  newlen;  /* size of new value */<br>           };<br><br>       This call does a search in a tree structure, possibly resembling a<br>       directory tree under <i>/proc/sys</i>, and if the requested item is found<br>       calls some appropriate routine to read or modify the value.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       Upon successful completion, <b>_sysctl</b>() returns 0.  Otherwise, a value<br>       of -1 is returned and <i>errno</i> is set to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EFAULT </b>The invocation asked for the previous value by setting <i>oldval</i><br>              non-NULL, but allowed zero room in <i>oldlenp</i>.<br><br>       <b>ENOTDIR</b><br>              <i>name</i> was not found.<br><br>       <b>EACCES</b>, <b>EPERM</b><br>              No search permission for one of the encountered \"directories\",<br>              or no read permission where <i>oldval</i> was nonzero, or no write<br>              permission where <i>newval</i> was nonzero.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       This call is Linux-specific, and should not be used in programs<br>       intended to be portable.  A <b>sysctl</b>() call has been present in Linux<br>       since version 1.3.57.  It originated in 4.4BSD.  Only Linux has the<br>       <i>/proc/sys</i> mirror, and the object naming schemes differ between Linux<br>       and 4.4BSD, but the declaration of the <b>sysctl</b>() function is the same<br>       in both.<br></pre><br><h2>NOTES  </h2><pre><br>       Glibc does not provide a wrapper for this system call; call it using<br>       syscall(2).  Or rather...  <i>don't</i> call it: use of this system call has<br>       long been discouraged, and it is so unloved that <b>it is likely to</b><br>       <b>disappear in a future kernel version</b>.  Since Linux 2.6.24, uses of<br>       this system call result in warnings in the kernel log.  Remove it<br>       from your programs now; use the <i>/proc/sys</i> interface instead.<br><br>       This system call is available only if the kernel was configured with<br>       the <b>CONFIG_SYSCTL_SYSCALL </b>option.<br></pre><br><h2>BUGS  </h2><pre><br>       The object names vary between kernel versions, making this system<br>       call worthless for applications.<br><br>       Not all available objects are properly documented.<br><br>       It is not yet possible to change operating system by writing to<br>       <i>/proc/sys/kernel/ostype</i>.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       #define _GNU_SOURCE<br>       #include &lt;unistd.h&gt;<br>       #include &lt;sys/syscall.h&gt;<br>       #include &lt;string.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;linux/sysctl.h&gt;<br><br>       int _sysctl(struct __sysctl_args *args );<br><br>       #define OSNAMESZ 100<br><br>       int<br>       main(void)<br>       {<br>           struct __sysctl_args args;<br>           char osname[OSNAMESZ];<br>           size_t osnamelth;<br>           int name[] = { CTL_KERN, KERN_OSTYPE };<br><br>           memset(&amp;args, 0, sizeof(struct __sysctl_args));<br>           args.name = name;<br>           args.nlen = sizeof(name)/sizeof(name[0]);<br>           args.oldval = osname;<br>           args.oldlenp = &amp;osnamelth;<br><br>           osnamelth = sizeof(osname);<br><br>           if (syscall(SYS__sysctl, &amp;args) == -1) {<br>               perror(\"_sysctl\");<br>               exit(EXIT_FAILURE);<br>           }<br>           printf(\"This machine is running %*s\\n\", osnamelth, osname);<br>           exit(EXIT_SUCCESS);<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       proc(5)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2012-12-22                        SYSCTL(2)</span><br></pre><br>"}