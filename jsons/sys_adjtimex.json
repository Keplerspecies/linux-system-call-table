{"Man page": "<pre><br><span class=\"headline\">ADJTIMEX(2)               Linux Programmer's Manual              ADJTIMEX(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       adjtimex - tune kernel clock<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#define _BSD_SOURCE      </b>/* See feature_test_macros(7) */<br>       <b>#include &lt;sys/timex.h&gt;</b><br><br>       <b>int adjtimex(struct timex *</b><i>buf</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       Linux uses David L. Mills' clock adjustment algorithm (see RFC 5905).<br>       The system call <b>adjtimex</b>() reads and optionally sets adjustment<br>       parameters for this algorithm.  It takes a pointer to a <i>timex</i><br>       structure, updates kernel parameters from field values, and returns<br>       the same structure with current kernel values.  This structure is<br>       declared as follows:<br><br>           struct timex {<br>               int  modes;      /* Mode selector */<br>               long offset;     /* Time offset; nanoseconds, if STA_NANO<br>                                   status flag is set, otherwise microseconds */<br>               long freq;       /* Frequency offset, in units of 2^-16 ppm<br>                                   (parts per million, see NOTES below) */<br>               long maxerror;   /* Maximum error (microseconds) */<br>               long esterror;   /* Estimated error (microseconds) */<br>               int  status;     /* Clock command/status */<br>               long constant;   /* PLL (phase-locked loop) time constant */<br>               long precision;  /* Clock precision (microseconds, read-only) */<br>               long tolerance;  /* Clock frequency tolerance (ppm, read-only) */<br>               struct timeval time;<br>                                /* Current time (read-only, except for<br>                                   ADJ_SETOFFSET); upon return, time.tv_usec<br>                                   contains nanoseconds, if STA_NANO status<br>                                   flag is set, otherwise microseconds */<br>               long tick;       /* Microseconds between clock ticks */<br>               long ppsfreq;    /* PPS (pulse per second) frequency (in units<br>                                   of 2^-16 ppm--see NOTES, read-only) */<br>               long jitter;     /* PPS jitter (read-only); nanoseconds, if<br>                                   STA_NANO status flag is set, otherwise<br>                                   microseconds */<br>               int  shift;      /* PPS interval duration (seconds, read-only) */<br>               long stabil;     /* PPS stability (2^-16 ppm--see NOTES,<br>                                   read-only) */<br>               long jitcnt;     /* PPS jitter limit exceeded (read-only) */<br>               long calcnt;     /* PPS calibration intervals (read-only) */<br>               long errcnt;     /* PPS calibration errors (read-only) */<br>               long stbcnt;     /* PPS stability limit exceeded (read-only) */<br>               int tai;         /* TAI offset, as set by previous ADJ_TAI<br>                                   operation (seconds, read-only,<br>                                   since Linux 2.6.26) */<br>               /* Further padding bytes to allow for future expansion */<br>           };<br><br>       The <i>modes</i> field determines which parameters, if any, to set.  It is a<br>       bit mask containing a bitwise-<i>or</i> combination of zero or more of the<br>       following bits:<br><br>       <b>ADJ_OFFSET</b><br>              Set time offset from <i>buf.offset</i>.<br><br>       <b>ADJ_FREQUENCY</b><br>              Set frequency offset from <i>buf.freq</i>.<br><br>       <b>ADJ_MAXERROR</b><br>              Set maximum time error from <i>buf.maxerror</i>.<br><br>       <b>ADJ_ESTERROR</b><br>              Set estimated time error from <i>buf.esterror</i>.<br><br>       <b>ADJ_STATUS</b><br>              Set clock status from <i>buf.status</i>.<br><br>       <b>ADJ_TIMECONST</b><br>              Set PLL time constant from <i>buf.constant</i>.  If the <b>STA_NANO</b><br>              status flag (see below) is clear, the kernel adds 4 to this<br>              value.<br><br>       <b>ADJ_SETOFFSET </b>(since Linux 2.6.29)<br>              Add <i>buf.time</i> to the current time.  If <i>buf.status</i> includes the<br>              <b>ADJ_NANO </b>flag, then <i>buf.time.tv_usec</i> is interpreted as a<br>              nanosecond value; otherwise it is interpreted as microseconds.<br><br>       <b>ADJ_MICRO </b>(since Linux 2.6.36)<br>              Select microsecond resolution.<br><br>       <b>ADJ_NANO </b>(since Linux 2.6.36)<br>              Select nanosecond resolution.  Only one of <b>ADJ_MICRO </b>and<br>              <b>ADJ_NANO </b>should be specified.<br><br>       <b>ADJ_TAI </b>(since Linux 2.6.26)<br>              Set TAI (Atomic International Time) offset from <i>buf-&gt;constant</i>.<br><br>              <b>ADJ_TAI </b>should not be used in conjunction with <b>ADJ_TIMECONST</b>,<br>              since the latter mode also employs the <i>buf-&gt;constant</i> field.<br><br>              For a complete explanation of TAI and the difference between<br>              TAI and UTC, see <i>BIPM</i> <br>              &#10216;http://www.bipm.org/en/bipm/tai/tai.html&#10217;<br><br>       <b>ADJ_TICK</b><br>              Set tick value from <i>buf.tick</i>.<br><br>       Alternatively, <i>modes</i> can be specified as either of the following<br>       (multibit mask) values, in which case other bits should not be speci&#8208;<br>       fied in <i>modes</i>:<br><br>       <b>ADJ_OFFSET_SINGLESHOT</b><br>              Old-fashioned <b>adjtime</b>(): (gradually) adjust time by value<br>              specified in <i>buf.offset</i>, which specifies an adjustment in<br>              microseconds.<br><br>       <b>ADJ_OFFSET_SS_READ </b>(functional since Linux 2.6.28)<br>              Return (in <i>buf.offset</i>) the remaining amount of time to be<br>              adjusted after an earlier <b>ADJ_OFFSET_SINGLESHOT </b>operation.<br>              This feature was added in Linux 2.6.24, but did not work cor&#8208;<br>              rectly until Linux 2.6.28.<br><br>       Ordinary users are restricted to a value of either 0 or <b>ADJ_OFF&#8208;</b><br>       <b>SET_SS_READ </b>for <i>modes</i>.  Only the superuser may set any parameters.<br><br>       The <i>buf.status</i> field is a bit mask that is used to set and/or<br>       retrieve status bits associated with the NTP implementation.  Some<br>       bits in the mask are both readable and settable, while others are<br>       read-only.<br><br>       <b>STA_PLL</b><br>              Enable phase-locked loop (PLL) updates (read-write) via<br>              <b>ADJ_OFFSET</b>.<br><br>       <b>STA_PPSFREQ</b><br>              Enable PPS freq discipline (read-write).<br><br>       <b>STA_PPSTIME</b><br>              Enable PPS time discipline (read-write).<br><br>       <b>STA_FLL</b><br>              Select frequency-locked loop (FLL) mode (read-write).<br><br>       <b>STA_INS</b><br>              Insert leap second (read-write).<br><br>       <b>STA_DEL</b><br>              Delete leap second (read-write).<br><br>       <b>STA_UNSYNC</b><br>              Clock unsynchronized (read-write).<br><br>       <b>STA_FREQHOLD</b><br>              Hold frequency (read-write).<br><br>       <b>STA_PPSSIGNAL</b><br>              PPS signal present (read-only).<br><br>       <b>STA_PPSJITTER</b><br>              PPS signal jitter exceeded (read-only).<br><br>       <b>STA_PPSWANDER</b><br>              PPS signal wander exceeded (read-only).<br><br>       <b>STA_PPSERROR</b><br>              PPS signal calibration error (read-only).<br><br>       <b>STA_CLOCKERR</b><br>              Clock hardware fault (read-only).<br><br>       <b>STA_NANO </b>(since Linux 2.6.26)<br>              Resolution (0 = microsecond, 1 = nanoseconds; read-only).  Set<br>              via <b>ADJ_NANO</b>, cleared via <b>ADJ_MICRO</b>.<br><br>       <b>STA_MODE </b>(since Linux 2.6.26)<br>              Mode (0 = Phase Locked Loop, 1 = Frequency Locked Loop; read-<br>              only).<br><br>       <b>STA_CLK </b>(since Linux 2.6.26)<br>              Clock source (0 = A, 1 = B; read-only).<br><br>       Attempts to set read-only <i>status</i> bits are silently ignored.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>adjtimex</b>() returns the clock state; that is, one of the<br>       following values:<br><br>       <b>TIME_OK     </b>Clock synchronized.<br><br>       <b>TIME_INS    </b>Insert leap second.<br><br>       <b>TIME_DEL    </b>Delete leap second.<br><br>       <b>TIME_OOP    </b>Leap second in progress.<br><br>       <b>TIME_WAIT   </b>Leap second has occurred.<br><br>       <b>TIME_ERROR  </b>Clock not synchronized.  The symbolic name <b>TIME_BAD </b>is a<br>                   synonym for <b>TIME_ERROR</b>, provided for backward<br>                   compatibility.<br><br>       On failure, <b>adjtimex</b>() returns -1 and sets <i>errno</i>.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EFAULT </b><i>buf</i> does not point to writable memory.<br><br>       <b>EINVAL </b>An attempt was made to set <i>buf.offset</i> to a value outside the<br>              range -131071 to +131071, or to set <i>buf.status</i> to a value<br>              other than those listed above, or to set <i>buf.tick</i> to a value<br>              outside the range 900000/<b>HZ </b>to 1100000/<b>HZ</b>, where <b>HZ </b>is the<br>              system timer interrupt frequency.<br><br>       <b>EPERM  </b><i>buf.modes</i> is neither 0 nor <b>ADJ_OFFSET_SS_READ</b>, and the caller<br>              does not have sufficient privilege.  Under Linux, the<br>              <b>CAP_SYS_TIME </b>capability is required.<br></pre><br><h2>NOTES  </h2><pre><br>       In struct <i>timex</i>, <i>freq</i>, <i>ppsfreq</i>, and <i>stabil</i> are ppm (parts per<br>       million) with a 16-bit fractional part, which means that a value of 1<br>       in one of those fields actually means 2^-16 ppm, and 2^16=65536 is 1<br>       ppm.  This is the case for both input values (in the case of <i>freq</i>)<br>       and output values.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>adjtimex</b>() is Linux-specific and should not be used in programs<br>       intended to be portable.  See adjtime(3) for a more portable, but<br>       less flexible, method of adjusting the system clock.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       settimeofday(2), adjtime(3), capabilities(7), time(7), <b>adjtimex</b>(8)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2014-12-31                      ADJTIMEX(2)</span><br></pre><br>"}