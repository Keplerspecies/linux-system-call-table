{"Man page": "<pre><br><span class=\"headline\">EPOLL_CTL(2)              Linux Programmer's Manual             EPOLL_CTL(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       epoll_ctl - control interface for an epoll descriptor<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/epoll.h&gt;</b><br><br>       <b>int epoll_ctl(int </b><i>epfd</i><b>, int </b><i>op</i><b>, int </b><i>fd</i><b>, struct epoll_event *</b><i>event</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       This system call performs control operations on the epoll(7) instance<br>       referred to by the file descriptor <i>epfd</i>.  It requests that the<br>       operation <i>op</i> be performed for the target file descriptor, <i>fd</i>.<br><br>       Valid values for the <i>op</i> argument are:<br><br>       <b>EPOLL_CTL_ADD</b><br>              Register the target file descriptor <i>fd</i> on the <b>epoll </b>instance<br>              referred to by the file descriptor <i>epfd</i> and associate the<br>              event <i>event</i> with the internal file linked to <i>fd</i>.<br><br>       <b>EPOLL_CTL_MOD</b><br>              Change the event <i>event</i> associated with the target file<br>              descriptor <i>fd</i>.<br><br>       <b>EPOLL_CTL_DEL</b><br>              Remove (deregister) the target file descriptor <i>fd</i> from the<br>              <b>epoll </b>instance referred to by <i>epfd</i>.  The <i>event</i> is ignored and<br>              can be NULL (but see BUGS below).<br><br>       The <i>event</i> argument describes the object linked to the file descriptor<br>       <i>fd</i>.  The <i>struct epoll_event</i> is defined as:<br><br>           typedef union epoll_data {<br>               void        *ptr;<br>               int          fd;<br>               uint32_t     u32;<br>               uint64_t     u64;<br>           } epoll_data_t;<br><br>           struct epoll_event {<br>               uint32_t     events;      /* Epoll events */<br>               epoll_data_t data;        /* User data variable */<br>           };<br><br>       The <i>events</i> member is a bit set composed using the following available<br>       event types:<br><br>       <b>EPOLLIN</b><br>              The associated file is available for read(2) operations.<br><br>       <b>EPOLLOUT</b><br>              The associated file is available for write(2) operations.<br><br>       <b>EPOLLRDHUP </b>(since Linux 2.6.17)<br>              Stream socket peer closed connection, or shut down writing<br>              half of connection.  (This flag is especially useful for<br>              writing simple code to detect peer shutdown when using Edge<br>              Triggered monitoring.)<br><br>       <b>EPOLLPRI</b><br>              There is urgent data available for read(2) operations.<br><br>       <b>EPOLLERR</b><br>              Error condition happened on the associated file descriptor.<br>              epoll_wait(2) will always wait for this event; it is not<br>              necessary to set it in <i>events</i>.<br><br>       <b>EPOLLHUP</b><br>              Hang up happened on the associated file descriptor.<br>              epoll_wait(2) will always wait for this event; it is not<br>              necessary to set it in <i>events</i>.  Note that when reading from a<br>              channel such as a pipe or a stream socket, this event merely<br>              indicates that the peer closed its end of the channel.<br>              Subsequent reads from the channel will return 0 (end of file)<br>              only after all outstanding data in the channel has been<br>              consumed.<br><br>       <b>EPOLLET</b><br>              Sets the Edge Triggered behavior for the associated file<br>              descriptor.  The default behavior for <b>epoll </b>is Level<br>              Triggered.  See epoll(7) for more detailed information about<br>              Edge and Level Triggered event distribution architectures.<br><br>       <b>EPOLLONESHOT </b>(since Linux 2.6.2)<br>              Sets the one-shot behavior for the associated file descriptor.<br>              This means that after an event is pulled out with<br>              epoll_wait(2) the associated file descriptor is internally<br>              disabled and no other events will be reported by the <b>epoll</b><br>              interface.  The user must call <b>epoll_ctl</b>() with <b>EPOLL_CTL_MOD</b><br>              to rearm the file descriptor with a new event mask.<br><br>       <b>EPOLLWAKEUP </b>(since Linux 3.5)<br>              If <b>EPOLLONESHOT </b>and <b>EPOLLET </b>are clear and the process has the<br>              <b>CAP_BLOCK_SUSPEND </b>capability, ensure that the system does not<br>              enter \"suspend\" or \"hibernate\" while this event is pending or<br>              being processed.  The event is considered as being \"processed\"<br>              from the time when it is returned by a call to epoll_wait(2)<br>              until the next call to epoll_wait(2) on the same epoll(7) file<br>              descriptor, the closure of that file descriptor, the removal<br>              of the event file descriptor with <b>EPOLL_CTL_DEL</b>, or the<br>              clearing of <b>EPOLLWAKEUP </b>for the event file descriptor with<br>              <b>EPOLL_CTL_MOD</b>.  See also BUGS.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       When successful, <b>epoll_ctl</b>() returns zero.  When an error occurs,<br>       <b>epoll_ctl</b>() returns -1 and <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EBADF  </b><i>epfd</i> or <i>fd</i> is not a valid file descriptor.<br><br>       <b>EEXIST </b><i>op</i> was <b>EPOLL_CTL_ADD</b>, and the supplied file descriptor <i>fd</i> is<br>              already registered with this epoll instance.<br><br>       <b>EINVAL </b><i>epfd</i> is not an <b>epoll </b>file descriptor, or <i>fd</i> is the same as<br>              <i>epfd</i>, or the requested operation <i>op</i> is not supported by this<br>              interface.<br><br>       <b>ENOENT </b><i>op</i> was <b>EPOLL_CTL_MOD </b>or <b>EPOLL_CTL_DEL</b>, and <i>fd</i> is not<br>              registered with this epoll instance.<br><br>       <b>ENOMEM </b>There was insufficient memory to handle the requested <i>op</i><br>              control operation.<br><br>       <b>ENOSPC </b>The limit imposed by <i>/proc/sys/fs/epoll/max_user_watches</i> was<br>              encountered while trying to register (<b>EPOLL_CTL_ADD</b>) a new<br>              file descriptor on an epoll instance.  See epoll(7) for<br>              further details.<br><br>       <b>EPERM  </b>The target file <i>fd</i> does not support <b>epoll</b>.  This error can<br>              occur if <i>fd</i> refers to, for example, a regular file or a<br>              directory.<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>epoll_ctl</b>() was added to the kernel in version 2.6.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>epoll_ctl</b>() is Linux-specific.  Library support is provided in glibc<br>       starting with version 2.3.2.<br></pre><br><h2>NOTES  </h2><pre><br>       The <b>epoll </b>interface supports all file descriptors that support<br>       poll(2).<br></pre><br><h2>BUGS  </h2><pre><br>       In kernel versions before 2.6.9, the <b>EPOLL_CTL_DEL </b>operation required<br>       a non-null pointer in <i>event</i>, even though this argument is ignored.<br>       Since Linux 2.6.9, <i>event</i> can be specified as NULL when using<br>       <b>EPOLL_CTL_DEL</b>.  Applications that need to be portable to kernels<br>       before 2.6.9 should specify a non-null pointer in <i>event</i>.<br><br>       If <b>EPOLLWAKEUP </b>is specified in <i>flags</i>, but the caller does not have<br>       the <b>CAP_BLOCK_SUSPEND </b>capability, then the <b>EPOLLWAKEUP </b>flag is<br>       <i>silently ignored</i>.  This unfortunate behavior is necessary because no<br>       validity checks were performed on the <i>flags</i> argument in the original<br>       implementation, and the addition of the <b>EPOLLWAKEUP </b>with a check that<br>       caused the call to fail if the caller did not have the<br>       <b>CAP_BLOCK_SUSPEND </b>capability caused a breakage in at least one<br>       existing user-space application that happened to randomly (and<br>       uselessly) specify this bit.  A robust application should therefore<br>       double check that it has the <b>CAP_BLOCK_SUSPEND </b>capability if<br>       attempting to use the <b>EPOLLWAKEUP </b>flag.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       epoll_create(2), epoll_wait(2), poll(2), epoll(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-05-07                     EPOLL_CTL(2)</span><br></pre><br>"}