{"Man page": "<pre><br><span class=\"headline\">SPLICE(2)                 Linux Programmer's Manual                SPLICE(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       splice - splice data to/from a pipe<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#define _GNU_SOURCE         </b>/* See feature_test_macros(7) */<br>       <b>#include &lt;fcntl.h&gt;</b><br><br>       <b>ssize_t splice(int </b><i>fd_in</i><b>, loff_t *</b><i>off_in</i><b>, int </b><i>fd_out</i><b>,</b><br>                      <b>loff_t *</b><i>off_out</i><b>, size_t </b><i>len</i><b>, unsigned int </b><i>flags</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>splice</b>() moves data between two file descriptors without copying<br>       between kernel address space and user address space.  It transfers up<br>       to <i>len</i> bytes of data from the file descriptor <i>fd_in</i> to the file<br>       descriptor <i>fd_out</i>, where one of the descriptors must refer to a pipe.<br><br>       The following semantics apply for <i>fd_in</i> and <i>off_in</i>:<br><br>       *  If <i>fd_in</i> refers to a pipe, then <i>off_in</i> must be NULL.<br><br>       *  If <i>fd_in</i> does not refer to a pipe and <i>off_in</i> is NULL, then bytes<br>          are read from <i>fd_in</i> starting from the current file offset, and the<br>          current file offset is adjusted appropriately.<br><br>       *  If <i>fd_in</i> does not refer to a pipe and <i>off_in</i> is not NULL, then<br>          <i>off_in</i> must point to a buffer which specifies the starting offset<br>          from which bytes will be read from <i>fd_in</i>; in this case, the<br>          current file offset of <i>fd_in</i> is not changed.<br><br>       Analogous statements apply for <i>fd_out</i> and <i>off_out</i>.<br><br>       The <i>flags</i> argument is a bit mask that is composed by ORing together<br>       zero or more of the following values:<br><br>       <b>SPLICE_F_MOVE      </b>Attempt to move pages instead of copying.  This is<br>                          only a hint to the kernel: pages may still be<br>                          copied if the kernel cannot move the pages from<br>                          the pipe, or if the pipe buffers don't refer to<br>                          full pages.  The initial implementation of this<br>                          flag was buggy: therefore starting in Linux 2.6.21<br>                          it is a no-op (but is still permitted in a<br>                          <b>splice</b>() call); in the future, a correct<br>                          implementation may be restored.<br><br>       <b>SPLICE_F_NONBLOCK  </b>Do not block on I/O.  This makes the splice pipe<br>                          operations nonblocking, but <b>splice</b>() may<br>                          nevertheless block because the file descriptors<br>                          that are spliced to/from may block (unless they<br>                          have the <b>O_NONBLOCK </b>flag set).<br><br>       <b>SPLICE_F_MORE      </b>More data will be coming in a subsequent splice.<br>                          This is a helpful hint when the <i>fd_out</i> refers to a<br>                          socket (see also the description of <b>MSG_MORE </b>in<br>                          send(2), and the description of <b>TCP_CORK </b>in<br>                          tcp(7)).<br><br>       <b>SPLICE_F_GIFT      </b>Unused for <b>splice</b>(); see vmsplice(2).<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       Upon successful completion, <b>splice</b>() returns the number of bytes<br>       spliced to or from the pipe.  A return value of 0 means that there<br>       was no data to transfer, and it would not make sense to block,<br>       because there are no writers connected to the write end of the pipe<br>       referred to by <i>fd_in</i>.<br><br>       On error, <b>splice</b>() returns -1 and <i>errno</i> is set to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EAGAIN SPLICE_F_NONBLOCK </b>was specified in <i>flags</i>, and the operation<br>              would block.<br><br>       <b>EBADF  </b>One or both file descriptors are not valid, or do not have<br>              proper read-write mode.<br><br>       <b>EINVAL </b>Target filesystem doesn't support splicing; target file is<br>              opened in append mode; neither of the descriptors refers to a<br>              pipe; or offset given for nonseekable device.<br><br>       <b>ENOMEM </b>Out of memory.<br><br>       <b>ESPIPE </b>Either <i>off_in</i> or <i>off_out</i> was not NULL, but the corresponding<br>              file descriptor refers to a pipe.<br></pre><br><h2>VERSIONS  </h2><pre><br>       The <b>splice</b>() system call first appeared in Linux 2.6.17; library<br>       support was added to glibc in version 2.5.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       This system call is Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       The three system calls <b>splice</b>(), vmsplice(2), and tee(2), provide<br>       user-space programs with full control over an arbitrary kernel<br>       buffer, implemented within the kernel using the same type of buffer<br>       that is used for a pipe.  In overview, these system calls perform the<br>       following tasks:<br><br>       <b>splice</b>()    moves data from the buffer to an arbitrary file<br>                   descriptor, or vice versa, or from one buffer to another.<br><br>       tee(2)      \"copies\" the data from one buffer to another.<br><br>       vmsplice(2) \"copies\" data from user space into the buffer.<br><br>       Though we talk of copying, actual copies are generally avoided.  The<br>       kernel does this by implementing a pipe buffer as a set of reference-<br>       counted pointers to pages of kernel memory.  The kernel creates<br>       \"copies\" of pages in a buffer by creating new pointers (for the<br>       output buffer) referring to the pages, and increasing the reference<br>       counts for the pages: only pointers are copied, not the pages of the<br>       buffer.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       See tee(2).<br></pre><br><h2>SEE ALSO  </h2><pre><br>       sendfile(2), tee(2), vmsplice(2)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2014-12-31                        SPLICE(2)</span><br></pre><br>"}