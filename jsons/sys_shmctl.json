{"Man page": "<pre><br><span class=\"headline\">SHMCTL(2)                 Linux Programmer's Manual                SHMCTL(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       shmctl - System V shared memory control<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/ipc.h&gt;</b><br>       <b>#include &lt;sys/shm.h&gt;</b><br><br>       <b>int shmctl(int </b><i>shmid</i><b>, int </b><i>cmd</i><b>, struct shmid_ds *</b><i>buf</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>shmctl</b>() performs the control operation specified by <i>cmd</i> on the<br>       System V shared memory segment whose identifier is given in <i>shmid</i>.<br><br>       The <i>buf</i> argument is a pointer to a <i>shmid_ds</i> structure, defined in<br>       <i>&lt;sys/shm.h&gt;</i> as follows:<br><br>           struct shmid_ds {<br>               struct ipc_perm shm_perm;    /* Ownership and permissions */<br>               size_t          shm_segsz;   /* Size of segment (bytes) */<br>               time_t          shm_atime;   /* Last attach time */<br>               time_t          shm_dtime;   /* Last detach time */<br>               time_t          shm_ctime;   /* Last change time */<br>               pid_t           shm_cpid;    /* PID of creator */<br>               pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */<br>               shmatt_t        shm_nattch;  /* No. of current attaches */<br>               ...<br>           };<br><br>       The <i>ipc_perm</i> structure is defined as follows (the highlighted fields<br>       are settable using <b>IPC_SET</b>):<br><br>           struct ipc_perm {<br>               key_t          __key;    /* Key supplied to shmget(2) */<br>               uid_t          <b>uid</b>;      /* Effective UID of owner */<br>               gid_t          <b>gid</b>;      /* Effective GID of owner */<br>               uid_t          cuid;     /* Effective UID of creator */<br>               gid_t          cgid;     /* Effective GID of creator */<br>               unsigned short <b>mode</b>;     /* <b>Permissions </b>+ SHM_DEST and<br>                                           SHM_LOCKED flags */<br>               unsigned short __seq;    /* Sequence number */<br>           };<br><br>       Valid values for <i>cmd</i> are:<br><br>       <b>IPC_STAT  </b>Copy information from the kernel data structure associated<br>                 with <i>shmid</i> into the <i>shmid_ds</i> structure pointed to by <i>buf</i>.<br>                 The caller must have read permission on the shared memory<br>                 segment.<br><br>       <b>IPC_SET   </b>Write the values of some members of the <i>shmid_ds</i> structure<br>                 pointed to by <i>buf</i> to the kernel data structure associated<br>                 with this shared memory segment, updating also its<br>                 <i>shm_ctime</i> member.  The following fields can be changed:<br>                 <i>shm_perm.uid</i>, <i>shm_perm.gid</i>, and (the least significant 9<br>                 bits of) <i>shm_perm.mode</i>.  The effective UID of the calling<br>                 process must match the owner (<i>shm_perm.uid</i>) or creator<br>                 (<i>shm_perm.cuid</i>) of the shared memory segment, or the caller<br>                 must be privileged.<br><br>       <b>IPC_RMID  </b>Mark the segment to be destroyed.  The segment will<br>                 actually be destroyed only after the last process detaches<br>                 it (i.e., when the <i>shm_nattch</i> member of the associated<br>                 structure <i>shmid_ds</i> is zero).  The caller must be the owner<br>                 or creator of the segment, or be privileged.  The <i>buf</i><br>                 argument is ignored.<br><br>                 If a segment has been marked for destruction, then the<br>                 (nonstandard) <b>SHM_DEST </b>flag of the <i>shm_perm.mode</i> field in<br>                 the associated data structure retrieved by <b>IPC_STAT </b>will be<br>                 set.<br><br>                 The caller <i>must</i> ensure that a segment is eventually<br>                 destroyed; otherwise its pages that were faulted in will<br>                 remain in memory or swap.<br><br>                 See also the description of<br>                 <i>/proc/sys/kernel/shm_rmid_forced</i> in proc(5).<br><br>       <b>IPC_INFO </b>(Linux-specific)<br>                 Return information about system-wide shared memory limits<br>                 and parameters in the structure pointed to by <i>buf</i>.  This<br>                 structure is of type <i>shminfo</i> (thus, a cast is required),<br>                 defined in <i>&lt;sys/shm.h&gt;</i> if the <b>_GNU_SOURCE </b>feature test<br>                 macro is defined:<br><br>                     struct shminfo {<br>                         unsigned long shmmax; /* Maximum segment size */<br>                         unsigned long shmmin; /* Minimum segment size;<br>                                                  always 1 */<br>                         unsigned long shmmni; /* Maximum number of segments */<br>                         unsigned long shmseg; /* Maximum number of segments<br>                                                  that a process can attach;<br>                                                  unused within kernel */<br>                         unsigned long shmall; /* Maximum number of pages of<br>                                                  shared memory, system-wide */<br>                     };<br><br>                 The <i>shmmni</i>, <i>shmmax</i>, and <i>shmall</i> settings can be changed via<br>                 <i>/proc</i> files of the same name; see proc(5) for details.<br><br>       <b>SHM_INFO </b>(Linux-specific)<br>                 Return a <i>shm_info</i> structure whose fields contain<br>                 information about system resources consumed by shared<br>                 memory.  This structure is defined in <i>&lt;sys/shm.h&gt;</i> if the<br>                 <b>_GNU_SOURCE </b>feature test macro is defined:<br><br>                     struct shm_info {<br>                         int           used_ids; /* # of currently existing<br>                                                    segments */<br>                         unsigned long shm_tot;  /* Total number of shared<br>                                                    memory pages */<br>                         unsigned long shm_rss;  /* # of resident shared<br>                                                    memory pages */<br>                         unsigned long shm_swp;  /* # of swapped shared<br>                                                    memory pages */<br>                         unsigned long swap_attempts;<br>                                                 /* Unused since Linux 2.4 */<br>                         unsigned long swap_successes;<br>                                                 /* Unused since Linux 2.4 */<br>                     };<br><br>       <b>SHM_STAT </b>(Linux-specific)<br>                 Return a <i>shmid_ds</i> structure as for <b>IPC_STAT</b>.  However, the<br>                 <i>shmid</i> argument is not a segment identifier, but instead an<br>                 index into the kernel's internal array that maintains<br>                 information about all shared memory segments on the system.<br><br>       The caller can prevent or allow swapping of a shared memory segment<br>       with the following <i>cmd</i> values:<br><br>       <b>SHM_LOCK </b>(Linux-specific)<br>                 Prevent swapping of the shared memory segment.  The caller<br>                 must fault in any pages that are required to be present<br>                 after locking is enabled.  If a segment has been locked,<br>                 then the (nonstandard) <b>SHM_LOCKED </b>flag of the <i>shm_perm.mode</i><br>                 field in the associated data structure retrieved by<br>                 <b>IPC_STAT </b>will be set.<br><br>       <b>SHM_UNLOCK </b>(Linux-specific)<br>                 Unlock the segment, allowing it to be swapped out.<br><br>       In kernels before 2.6.10, only a privileged process could employ<br>       <b>SHM_LOCK </b>and <b>SHM_UNLOCK</b>.  Since kernel 2.6.10, an unprivileged<br>       process can employ these operations if its effective UID matches the<br>       owner or creator UID of the segment, and (for <b>SHM_LOCK</b>) the amount of<br>       memory to be locked falls within the <b>RLIMIT_MEMLOCK </b>resource limit<br>       (see setrlimit(2)).<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       A successful <b>IPC_INFO </b>or <b>SHM_INFO </b>operation returns the index of the<br>       highest used entry in the kernel's internal array recording<br>       information about all shared memory segments.  (This information can<br>       be used with repeated <b>SHM_STAT </b>operations to obtain information about<br>       all shared memory segments on the system.)  A successful <b>SHM_STAT</b><br>       operation returns the identifier of the shared memory segment whose<br>       index was given in <i>shmid</i>.  Other operations return 0 on success.<br><br>       On error, -1 is returned, and <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EACCES IPC_STAT </b>or <b>SHM_STAT </b>is requested and <i>shm_perm.mode</i> does not<br>              allow read access for <i>shmid</i>, and the calling process does not<br>              have the <b>CAP_IPC_OWNER </b>capability.<br><br>       <b>EFAULT </b>The argument <i>cmd</i> has value <b>IPC_SET </b>or <b>IPC_STAT </b>but the address<br>              pointed to by <i>buf</i> isn't accessible.<br><br>       <b>EIDRM  </b><i>shmid</i> points to a removed identifier.<br><br>       <b>EINVAL </b><i>shmid</i> is not a valid identifier, or <i>cmd</i> is not a valid<br>              command.  Or: for a <b>SHM_STAT </b>operation, the index value<br>              specified in <i>shmid</i> referred to an array slot that is currently<br>              unused.<br><br>       <b>ENOMEM </b>(In kernels since 2.6.9), <b>SHM_LOCK </b>was specified and the size<br>              of the to-be-locked segment would mean that the total bytes in<br>              locked shared memory segments would exceed the limit for the<br>              real user ID of the calling process.  This limit is defined by<br>              the <b>RLIMIT_MEMLOCK </b>soft resource limit (see setrlimit(2)).<br><br>       <b>EOVERFLOW</b><br>              <b>IPC_STAT </b>is attempted, and the GID or UID value is too large<br>              to be stored in the structure pointed to by <i>buf</i>.<br><br>       <b>EPERM  IPC_SET </b>or <b>IPC_RMID </b>is attempted, and the effective user ID of<br>              the calling process is not that of the creator (found in<br>              <i>shm_perm.cuid</i>), or the owner (found in <i>shm_perm.uid</i>), and the<br>              process was not privileged (Linux: did not have the<br>              <b>CAP_SYS_ADMIN </b>capability).<br><br>              Or (in kernels before 2.6.9), <b>SHM_LOCK </b>or <b>SHM_UNLOCK </b>was<br>              specified, but the process was not privileged (Linux: did not<br>              have the <b>CAP_IPC_LOCK </b>capability).  (Since Linux 2.6.9, this<br>              error can also occur if the <b>RLIMIT_MEMLOCK </b>is 0 and the caller<br>              is not privileged.)<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008, SVr4.<br></pre><br><h2>NOTES  </h2><pre><br>       The inclusion of <i>&lt;sys/types.h&gt;</i> and <i>&lt;sys/ipc.h&gt;</i> isn't required on<br>       Linux or by any version of POSIX.  However, some old implementations<br>       required the inclusion of these header files, and the SVID also<br>       documented their inclusion.  Applications intended to be portable to<br>       such old systems may need to include these header files.<br><br>       The <b>IPC_INFO</b>, <b>SHM_STAT </b>and <b>SHM_INFO </b>operations are used by the<br>       ipcs(1) program to provide information on allocated resources.  In<br>       the future, these may modified or moved to a <i>/proc</i> filesystem<br>       interface.<br><br>       Linux permits a process to attach (shmat(2)) a shared memory segment<br>       that has already been marked for deletion using <i>shmctl(IPC_RMID)</i>.<br>       This feature is not available on other UNIX implementations; portable<br>       applications should avoid relying on it.<br><br>       Various fields in a <i>struct shmid_ds</i> were typed as <i>short</i> under Linux<br>       2.2 and have become <i>long</i> under Linux 2.4.  To take advantage of this,<br>       a recompilation under glibc-2.1.91 or later should suffice.  (The<br>       kernel distinguishes old and new calls by an <b>IPC_64 </b>flag in <i>cmd</i>.)<br></pre><br><h2>SEE ALSO  </h2><pre><br>       mlock(2), setrlimit(2), shmget(2), shmop(2), capabilities(7),<br>       svipc(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-08-08                        SHMCTL(2)</span><br></pre><br>"}