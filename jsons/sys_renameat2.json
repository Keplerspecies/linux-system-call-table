{"Man page": "<pre><br><span class=\"headline\">RENAME(2)                 Linux Programmer's Manual                RENAME(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       rename, renameat, renameat2 - change the name or location of a file<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;stdio.h&gt;</b><br><br>       <b>int rename(const char *</b><i>oldpath</i><b>, const char *</b><i>newpath</i><b>);</b><br><br>       <b>#include &lt;fcntl.h&gt;           </b>/* Definition of AT_* constants */<br>       <b>#include &lt;stdio.h&gt;</b><br><br>       <b>int renameat(int </b><i>olddirfd</i><b>, const char *</b><i>oldpath</i><b>,</b><br>                    <b>int </b><i>newdirfd</i><b>, const char *</b><i>newpath</i><b>);</b><br><br>       <b>int renameat2(int </b><i>olddirfd</i><b>, const char *</b><i>oldpath</i><b>,</b><br>                     <b>int </b><i>newdirfd</i><b>, const char *</b><i>newpath</i><b>, unsigned int </b><i>flags</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>renameat</b>():<br>           Since glibc 2.10:<br>               _XOPEN_SOURCE &gt;= 700 || _POSIX_C_SOURCE &gt;= 200809L<br>           Before glibc 2.10:<br>               _ATFILE_SOURCE<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>rename</b>() renames a file, moving it between directories if required.<br>       Any other hard links to the file (as created using link(2)) are<br>       unaffected.  Open file descriptors for <i>oldpath</i> are also unaffected.<br><br>       If <i>newpath</i> already exists, it will be atomically replaced (subject to<br>       a few conditions; see ERRORS below), so that there is no point at<br>       which another process attempting to access <i>newpath</i> will find it<br>       missing.<br><br>       If <i>oldpath</i> and <i>newpath</i> are existing hard links referring to the same<br>       file, then <b>rename</b>() does nothing, and returns a success status.<br><br>       If <i>newpath</i> exists but the operation fails for some reason, <b>rename</b>()<br>       guarantees to leave an instance of <i>newpath</i> in place.<br><br>       <i>oldpath</i> can specify a directory.  In this case, <i>newpath</i> must either<br>       not exist, or it must specify an empty directory.<br><br>       However, when overwriting there will probably be a window in which<br>       both <i>oldpath</i> and <i>newpath</i> refer to the file being renamed.<br><br>       If <i>oldpath</i> refers to a symbolic link, the link is renamed; if <i>newpath</i><br>       refers to a symbolic link, the link will be overwritten.<br><br>   <b>renameat()</b><br>       The <b>renameat</b>() system call operates in exactly the same way as<br>       <b>rename</b>(), except for the differences described here.<br><br>       If the pathname given in <i>oldpath</i> is relative, then it is interpreted<br>       relative to the directory referred to by the file descriptor <i>olddirfd</i><br>       (rather than relative to the current working directory of the calling<br>       process, as is done by <b>rename</b>() for a relative pathname).<br><br>       If <i>oldpath</i> is relative and <i>olddirfd</i> is the special value <b>AT_FDCWD</b>,<br>       then <i>oldpath</i> is interpreted relative to the current working directory<br>       of the calling process (like <b>rename</b>()).<br><br>       If <i>oldpath</i> is absolute, then <i>olddirfd</i> is ignored.<br><br>       The interpretation of <i>newpath</i> is as for <i>oldpath</i>, except that a<br>       relative pathname is interpreted relative to the directory referred<br>       to by the file descriptor <i>newdirfd</i>.<br><br>       See openat(2) for an explanation of the need for <b>renameat</b>().<br><br>   <b>renameat2()</b><br>       <b>renameat2</b>() has an additional <i>flags</i> argument.  A <b>renameat2</b>() call<br>       with a zero <i>flags</i> argument is equivalent to <b>renameat</b>().<br><br>       The <i>flags</i> argument is a bit mask consisting of zero or more of the<br>       following flags:<br><br>       <b>RENAME_EXCHANGE</b><br>              Atomically exchange <i>oldpath</i> and <i>newpath</i>.  Both pathnames must<br>              exist but may be of different types (e.g., one could be a non-<br>              empty directory and the other a symbolic link).<br><br>       <b>RENAME_NOREPLACE</b><br>              Don't overwrite <i>newpath</i> of the rename.  Return an error if<br>              <i>newpath</i> already exists.<br><br>              <b>RENAME_NOREPLACE </b>can't be employed together with<br>              <b>RENAME_EXCHANGE</b>.<br><br>       <b>RENAME_WHITEOUT </b>(since Linux 3.18)<br>              This operation makes sense only for overlay/union filesystem<br>              implementations.<br><br>              Specifying <b>RENAME_WHITEOUT </b>creates a \"whiteout\" object at the<br>              source of the rename at the same time as performing the<br>              rename.  The whole operation is atomic, so that if the rename<br>              succeeds then the whiteout will also have been created.<br><br>              A \"whiteout\" is an object that has special meaning in<br>              union/overlay filesystem constructs.  In these constructs,<br>              multiple layers exist and only the top one is ever modified.<br>              A whiteout on an upper layer will effectively hide a matching<br>              file in the lower layer, making it appear as if the file<br>              didn't exist.<br><br>              When a file that exists on the lower layer is renamed, the<br>              file is first copied up (if not already on the upper layer)<br>              and then renamed on the upper, read-write layer.  At the same<br>              time, the source file needs to be \"whiteouted\" (so that the<br>              version of the source file in the lower layer is rendered<br>              invisible).  The whole operation needs to be done atomically.<br><br>              When not part of a union/overlay, the whiteout appears as a<br>              character device with a {0,0} device number.<br><br>              <b>RENAME_WHITEOUT </b>requires the same privileges as creating a<br>              device node (i.e., the <b>CAP_MKNOD </b>capability).<br><br>              <b>RENAME_WHITEOUT </b>can't be employed together with<br>              <b>RENAME_EXCHANGE</b>.<br><br>              <b>RENAME_WHITEOUT </b>requires support from the underlying<br>              filesystem.  Among the filesystems that provide that support<br>              are shmem (since Linux 3.18), ext4 (since Linux 3.18), and XFS<br>              (since Linux 4.1).<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, zero is returned.  On error, -1 is returned, and <i>errno</i> is<br>       set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EACCES </b>Write permission is denied for the directory containing<br>              <i>oldpath</i> or <i>newpath</i>, or, search permission is denied for one of<br>              the directories in the path prefix of <i>oldpath</i> or <i>newpath</i>, or<br>              <i>oldpath</i> is a directory and does not allow write permission<br>              (needed to update the <i>..</i>  entry).  (See also<br>              path_resolution(7).)<br><br>       <b>EBUSY  </b>The rename fails because <i>oldpath</i> or <i>newpath</i> is a directory<br>              that is in use by some process (perhaps as current working<br>              directory, or as root directory, or because it was open for<br>              reading) or is in use by the system (for example as mount<br>              point), while the system considers this an error.  (Note that<br>              there is no requirement to return <b>EBUSY </b>in such cases&#8212;there is<br>              nothing wrong with doing the rename anyway&#8212;but it is allowed<br>              to return <b>EBUSY </b>if the system cannot otherwise handle such<br>              situations.)<br><br>       <b>EDQUOT </b>The user's quota of disk blocks on the filesystem has been<br>              exhausted.<br><br>       <b>EFAULT </b><i>oldpath</i> or <i>newpath</i> points outside your accessible address<br>              space.<br><br>       <b>EINVAL </b>The new pathname contained a path prefix of the old, or, more<br>              generally, an attempt was made to make a directory a<br>              subdirectory of itself.<br><br>       <b>EISDIR </b><i>newpath</i> is an existing directory, but <i>oldpath</i> is not a<br>              directory.<br><br>       <b>ELOOP  </b>Too many symbolic links were encountered in resolving <i>oldpath</i><br>              or <i>newpath</i>.<br><br>       <b>EMLINK </b><i>oldpath</i> already has the maximum number of links to it, or it<br>              was a directory and the directory containing <i>newpath</i> has the<br>              maximum number of links.<br><br>       <b>ENAMETOOLONG</b><br>              <i>oldpath</i> or <i>newpath</i> was too long.<br><br>       <b>ENOENT </b>The link named by <i>oldpath</i> does not exist; or, a directory<br>              component in <i>newpath</i> does not exist; or, <i>oldpath</i> or <i>newpath</i> is<br>              an empty string.<br><br>       <b>ENOMEM </b>Insufficient kernel memory was available.<br><br>       <b>ENOSPC </b>The device containing the file has no room for the new<br>              directory entry.<br><br>       <b>ENOTDIR</b><br>              A component used as a directory in <i>oldpath</i> or <i>newpath</i> is not,<br>              in fact, a directory.  Or, <i>oldpath</i> is a directory, and <i>newpath</i><br>              exists but is not a directory.<br><br>       <b>ENOTEMPTY </b>or <b>EEXIST</b><br>              <i>newpath</i> is a nonempty directory, that is, contains entries<br>              other than \".\" and \"..\".<br><br>       <b>EPERM </b>or <b>EACCES</b><br>              The directory containing <i>oldpath</i> has the sticky bit (<b>S_ISVTX</b>)<br>              set and the process's effective user ID is neither the user ID<br>              of the file to be deleted nor that of the directory containing<br>              it, and the process is not privileged (Linux: does not have<br>              the <b>CAP_FOWNER </b>capability); or <i>newpath</i> is an existing file and<br>              the directory containing it has the sticky bit set and the<br>              process's effective user ID is neither the user ID of the file<br>              to be replaced nor that of the directory containing it, and<br>              the process is not privileged (Linux: does not have the<br>              <b>CAP_FOWNER </b>capability); or the filesystem containing <i>pathname</i><br>              does not support renaming of the type requested.<br><br>       <b>EROFS  </b>The file is on a read-only filesystem.<br><br>       <b>EXDEV  </b><i>oldpath</i> and <i>newpath</i> are not on the same mounted filesystem.<br>              (Linux permits a filesystem to be mounted at multiple points,<br>              but <b>rename</b>() does not work across different mount points, even<br>              if the same filesystem is mounted on both.)<br><br>       The following additional errors can occur for <b>renameat</b>() and<br>       <b>renameat2</b>():<br><br>       <b>EBADF  </b><i>olddirfd</i> or <i>newdirfd</i> is not a valid file descriptor.<br><br>       <b>ENOTDIR</b><br>              <i>oldpath</i> is relative and <i>olddirfd</i> is a file descriptor<br>              referring to a file other than a directory; or similar for<br>              <i>newpath</i> and <i>newdirfd</i><br><br>       The following additional errors can occur for <b>renameat2</b>():<br><br>       <b>EEXIST </b><i>flags</i> contains <b>RENAME_NOREPLACE </b>and <i>newpath</i> already exists.<br><br>       <b>EINVAL </b>An invalid flag was specified in <i>flags</i>.<br><br>       <b>EINVAL </b>Both <b>RENAME_NOREPLACE </b>and <b>RENAME_EXCHANGE </b>were specified in<br>              <i>flags</i>.<br><br>       <b>EINVAL </b>Both <b>RENAME_WHITEOUT </b>and <b>RENAME_EXCHANGE </b>were specified in<br>              <i>flags</i>.<br><br>       <b>EINVAL </b>The filesystem does not support one of the flags in <i>flags</i>.<br><br>       <b>ENOENT </b><i>flags</i> contains <b>RENAME_EXCHANGE </b>and <i>newpath</i> does not exist.<br><br>       <b>EPERM  RENAME_WHITEOUT </b>was specified in <i>flags</i>, but the caller does<br>              not have the <b>CAP_MKNOD </b>capability.<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>renameat</b>() was added to Linux in kernel 2.6.16; library support was<br>       added to glibc in version 2.4.<br><br>       <b>renameat2</b>() was added to Linux in kernel 3.15.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>rename</b>(): 4.3BSD, C89, C99, POSIX.1-2001, POSIX.1-2008.<br><br>       <b>renameat</b>(): POSIX.1-2008.<br><br>       <b>renameat2</b>() is Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>   <b>Glibc notes</b><br>       On older kernels where <b>renameat</b>() is unavailable, the glibc wrapper<br>       function falls back to the use of <b>rename</b>().  When <i>oldpath</i> and <i>newpath</i><br>       are relative pathnames, glibc constructs pathnames based on the<br>       symbolic links in <i>/proc/self/fd</i> that correspond to the <i>olddirfd</i> and<br>       <i>newdirfd</i> arguments.<br></pre><br><h2>BUGS  </h2><pre><br>       On NFS filesystems, you can not assume that if the operation failed,<br>       the file was not renamed.  If the server does the rename operation<br>       and then crashes, the retransmitted RPC which will be processed when<br>       the server is up again causes a failure.  The application is expected<br>       to deal with this.  See link(2) for a similar problem.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       mv(1), chmod(2), link(2), symlink(2), unlink(2), path_resolution(7),<br>       symlink(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                        RENAME(2)</span><br></pre><br>"}