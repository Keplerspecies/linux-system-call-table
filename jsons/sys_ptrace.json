{"Man page": "<pre><br><span class=\"headline\">PTRACE(2)                 Linux Programmer's Manual                PTRACE(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       ptrace - process trace<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/ptrace.h&gt;</b><br><br>       <b>long ptrace(enum __ptrace_request </b><i>request</i><b>, pid_t </b><i>pid</i><b>,</b><br>                   <b>void *</b><i>addr</i><b>, void *</b><i>data</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>ptrace</b>() system call provides a means by which one process (the<br>       \"tracer\") may observe and control the execution of another process<br>       (the \"tracee\"), and examine and change the tracee's memory and<br>       registers.  It is primarily used to implement breakpoint debugging<br>       and system call tracing.<br><br>       A tracee first needs to be attached to the tracer.  Attachment and<br>       subsequent commands are per thread: in a multithreaded process, every<br>       thread can be individually attached to a (potentially different)<br>       tracer, or left not attached and thus not debugged.  Therefore,<br>       \"tracee\" always means \"(one) thread\", never \"a (possibly<br>       multithreaded) process\".  Ptrace commands are always sent to a<br>       specific tracee using a call of the form<br><br>           ptrace(PTRACE_foo, pid, ...)<br><br>       where <i>pid</i> is the thread ID of the corresponding Linux thread.<br><br>       (Note that in this page, a \"multithreaded process\" means a thread<br>       group consisting of threads created using the clone(2) <b>CLONE_THREAD</b><br>       flag.)<br><br>       A process can initiate a trace by calling fork(2) and having the<br>       resulting child do a <b>PTRACE_TRACEME</b>, followed (typically) by an<br>       execve(2).  Alternatively, one process may commence tracing another<br>       process using <b>PTRACE_ATTACH </b>or <b>PTRACE_SEIZE</b>.<br><br>       While being traced, the tracee will stop each time a signal is<br>       delivered, even if the signal is being ignored.  (An exception is<br>       <b>SIGKILL</b>, which has its usual effect.)  The tracer will be notified at<br>       its next call to waitpid(2) (or one of the related \"wait\" system<br>       calls); that call will return a <i>status</i> value containing information<br>       that indicates the cause of the stop in the tracee.  While the tracee<br>       is stopped, the tracer can use various ptrace requests to inspect and<br>       modify the tracee.  The tracer then causes the tracee to continue,<br>       optionally ignoring the delivered signal (or even delivering a<br>       different signal instead).<br><br>       If the <b>PTRACE_O_TRACEEXEC </b>option is not in effect, all successful<br>       calls to execve(2) by the traced process will cause it to be sent a<br>       <b>SIGTRAP </b>signal, giving the parent a chance to gain control before the<br>       new program begins execution.<br><br>       When the tracer is finished tracing, it can cause the tracee to<br>       continue executing in a normal, untraced mode via <b>PTRACE_DETACH</b>.<br><br>       The value of <i>request</i> determines the action to be performed:<br><br>       <b>PTRACE_TRACEME</b><br>              Indicate that this process is to be traced by its parent.  A<br>              process probably shouldn't make this request if its parent<br>              isn't expecting to trace it.  (<i>pid</i>, <i>addr</i>, and <i>data</i> are<br>              ignored.)<br><br>              The <b>PTRACE_TRACEME </b>request is used only by the tracee; the<br>              remaining requests are used only by the tracer.  In the<br>              following requests, <i>pid</i> specifies the thread ID of the tracee<br>              to be acted on.  For requests other than <b>PTRACE_ATTACH</b>,<br>              <b>PTRACE_SEIZE</b>, <b>PTRACE_INTERRUPT</b>, and <b>PTRACE_KILL</b>, the tracee<br>              must be stopped.<br><br>       <b>PTRACE_PEEKTEXT</b>, <b>PTRACE_PEEKDATA</b><br>              Read a word at the address <i>addr</i> in the tracee's memory,<br>              returning the word as the result of the <b>ptrace</b>() call.  Linux<br>              does not have separate text and data address spaces, so these<br>              two requests are currently equivalent.  (<i>data</i> is ignored; but<br>              see NOTES.)<br><br>       <b>PTRACE_PEEKUSER</b><br>              Read a word at offset <i>addr</i> in the tracee's USER area, which<br>              holds the registers and other information about the process<br>              (see <i>&lt;sys/user.h&gt;</i>).  The word is returned as the result of the<br>              <b>ptrace</b>() call.  Typically, the offset must be word-aligned,<br>              though this might vary by architecture.  See NOTES.  (<i>data</i> is<br>              ignored; but see NOTES.)<br><br>       <b>PTRACE_POKETEXT</b>, <b>PTRACE_POKEDATA</b><br>              Copy the word <i>data</i> to the address <i>addr</i> in the tracee's memory.<br>              As for <b>PTRACE_PEEKTEXT </b>and <b>PTRACE_PEEKDATA</b>, these two requests<br>              are currently equivalent.<br><br>       <b>PTRACE_POKEUSER</b><br>              Copy the word <i>data</i> to offset <i>addr</i> in the tracee's USER area.<br>              As for <b>PTRACE_PEEKUSER</b>, the offset must typically be word-<br>              aligned.  In order to maintain the integrity of the kernel,<br>              some modifications to the USER area are disallowed.<br><br>       <b>PTRACE_GETREGS</b>, <b>PTRACE_GETFPREGS</b><br>              Copy the tracee's general-purpose or floating-point registers,<br>              respectively, to the address <i>data</i> in the tracer.  See<br>              <i>&lt;sys/user.h&gt;</i> for information on the format of this data.<br>              (<i>addr</i> is ignored.)  Note that SPARC systems have the meaning<br>              of <i>data</i> and <i>addr</i> reversed; that is, <i>data</i> is ignored and the<br>              registers are copied to the address <i>addr</i>.  <b>PTRACE_GETREGS </b>and<br>              <b>PTRACE_GETFPREGS </b>are not present on all architectures.<br><br>       <b>PTRACE_GETREGSET </b>(since Linux 2.6.34)<br>              Read the tracee's registers.  <i>addr</i> specifies, in an<br>              architecture-dependent way, the type of registers to be read.<br>              <b>NT_PRSTATUS </b>(with numerical value 1) usually results in<br>              reading of general-purpose registers.  If the CPU has, for<br>              example, floating-point and/or vector registers, they can be<br>              retrieved by setting <i>addr</i> to the corresponding <b>NT_foo</b><br>              constant.  <i>data</i> points to a <b>struct iovec</b>, which describes the<br>              destination buffer's location and length.  On return, the<br>              kernel modifies <b>iov.len </b>to indicate the actual number of bytes<br>              returned.<br><br>       <b>PTRACE_SETREGS</b>, <b>PTRACE_SETFPREGS</b><br>              Modify the tracee's general-purpose or floating-point<br>              registers, respectively, from the address <i>data</i> in the tracer.<br>              As for <b>PTRACE_POKEUSER</b>, some general-purpose register<br>              modifications may be disallowed.  (<i>addr</i> is ignored.)  Note<br>              that SPARC systems have the meaning of <i>data</i> and <i>addr</i> reversed;<br>              that is, <i>data</i> is ignored and the registers are copied from the<br>              address <i>addr</i>.  <b>PTRACE_SETREGS </b>and <b>PTRACE_SETFPREGS </b>are not<br>              present on all architectures.<br><br>       <b>PTRACE_SETREGSET </b>(since Linux 2.6.34)<br>              Modify the tracee's registers.  The meaning of <i>addr</i> and <i>data</i><br>              is analogous to <b>PTRACE_GETREGSET</b>.<br><br>       <b>PTRACE_GETSIGINFO </b>(since Linux 2.3.99-pre6)<br>              Retrieve information about the signal that caused the stop.<br>              Copy a <i>siginfo_t</i> structure (see sigaction(2)) from the tracee<br>              to the address <i>data</i> in the tracer.  (<i>addr</i> is ignored.)<br><br>       <b>PTRACE_SETSIGINFO </b>(since Linux 2.3.99-pre6)<br>              Set signal information: copy a <i>siginfo_t</i> structure from the<br>              address <i>data</i> in the tracer to the tracee.  This will affect<br>              only signals that would normally be delivered to the tracee<br>              and were caught by the tracer.  It may be difficult to tell<br>              these normal signals from synthetic signals generated by<br>              <b>ptrace</b>() itself.  (<i>addr</i> is ignored.)<br><br>       <b>PTRACE_PEEKSIGINFO </b>(since Linux 3.10)<br>              Retrieve <i>siginfo_t</i> structures without removing signals from a<br>              queue.  <i>addr</i> points to a <i>ptrace_peeksiginfo_args</i> structure<br>              that specifies the ordinal position from which copying of<br>              signals should start, and the number of signals to copy.<br>              <i>siginfo_t</i> structures are copied into the buffer pointed to by<br>              <i>data</i>.  The return value contains the number of copied signals<br>              (zero indicates that there is no signal corresponding to the<br>              specified ordinal position).  Within the returned <i>siginfo</i><br>              structures, the <i>si_code</i> field includes information (<b>__SI_CHLD</b>,<br>              <b>__SI_FAULT</b>, etc.) that are not otherwise exposed to user<br>              space.<br><br>                 struct ptrace_peeksiginfo_args {<br>                     u64 off;    /* Ordinal position in queue at which<br>                                    to start copying signals */<br>                     u32 flags;  /* PTRACE_PEEKSIGINFO_SHARED or 0 */<br>                     s32 nr;     /* Number of signals to copy */<br>                 };<br><br>                 Currently, there is only one flag,<br>                 <b>PTRACE_PEEKSIGINFO_SHARED</b>, for dumping signals from the<br>                 process-wide signal queue.  If this flag is not set,<br>                 signals are read from the per-thread queue of the specified<br>                 thread.<br><br>       <b>PTRACE_GETSIGMASK </b>(since Linux 3.11)<br>              Place a copy of the mask of blocked signals (see<br>              sigprocmask(2)) in the buffer pointed to by <i>data</i>, which should<br>              be a pointer to a buffer of type <i>sigset_t</i>.  The <i>addr</i> argument<br>              contains the size of the buffer pointed to by <i>data</i> (i.e.,<br>              <i>sizeof(sigset_t)</i>).<br><br>       <b>PTRACE_SETSIGMASK </b>(since Linux 3.11)<br>              Change the mask of blocked signals (see sigprocmask(2)) to the<br>              value specified in the buffer pointed to by <i>data</i>, which should<br>              be a pointer to a buffer of type <i>sigset_t</i>.  The <i>addr</i> argument<br>              contains the size of the buffer pointed to by <i>data</i> (i.e.,<br>              <i>sizeof(sigset_t)</i>).<br><br>       <b>PTRACE_SETOPTIONS </b>(since Linux 2.4.6; see BUGS for caveats)<br>              Set ptrace options from <i>data</i>.  (<i>addr</i> is ignored.)  <i>data</i> is<br>              interpreted as a bit mask of options, which are specified by<br>              the following flags:<br><br>              <b>PTRACE_O_EXITKILL </b>(since Linux 3.8)<br>                     If a tracer sets this flag, a <b>SIGKILL </b>signal will be<br>                     sent to every tracee if the tracer exits.  This option<br>                     is useful for ptrace jailers that want to ensure that<br>                     tracees can never escape the tracer's control.<br><br>              <b>PTRACE_O_TRACECLONE </b>(since Linux 2.5.46)<br>                     Stop the tracee at the next clone(2) and automatically<br>                     start tracing the newly cloned process, which will<br>                     start with a <b>SIGSTOP</b>, or <b>PTRACE_EVENT_STOP </b>if<br>                     <b>PTRACE_SEIZE </b>was used.  A waitpid(2) by the tracer will<br>                     return a <i>status</i> value such that<br><br>                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_CLONE&lt;&lt;8))<br><br>                     The PID of the new process can be retrieved with<br>                     <b>PTRACE_GETEVENTMSG</b>.<br><br>                     This option may not catch clone(2) calls in all cases.<br>                     If the tracee calls clone(2) with the <b>CLONE_VFORK </b>flag,<br>                     <b>PTRACE_EVENT_VFORK </b>will be delivered instead if<br>                     <b>PTRACE_O_TRACEVFORK </b>is set; otherwise if the tracee<br>                     calls clone(2) with the exit signal set to <b>SIGCHLD</b>,<br>                     <b>PTRACE_EVENT_FORK </b>will be delivered if<br>                     <b>PTRACE_O_TRACEFORK </b>is set.<br><br>              <b>PTRACE_O_TRACEEXEC </b>(since Linux 2.5.46)<br>                     Stop the tracee at the next execve(2).  A waitpid(2) by<br>                     the tracer will return a <i>status</i> value such that<br><br>                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_EXEC&lt;&lt;8))<br><br>                     If the execing thread is not a thread group leader, the<br>                     thread ID is reset to thread group leader's ID before<br>                     this stop.  Since Linux 3.0, the former thread ID can<br>                     be retrieved with <b>PTRACE_GETEVENTMSG</b>.<br><br>              <b>PTRACE_O_TRACEEXIT </b>(since Linux 2.5.60)<br>                     Stop the tracee at exit.  A waitpid(2) by the tracer<br>                     will return a <i>status</i> value such that<br><br>                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_EXIT&lt;&lt;8))<br><br>                     The tracee's exit status can be retrieved with<br>                     <b>PTRACE_GETEVENTMSG</b>.<br><br>                     The tracee is stopped early during process exit, when<br>                     registers are still available, allowing the tracer to<br>                     see where the exit occurred, whereas the normal exit<br>                     notification is done after the process is finished<br>                     exiting.  Even though context is available, the tracer<br>                     cannot prevent the exit from happening at this point.<br><br>              <b>PTRACE_O_TRACEFORK </b>(since Linux 2.5.46)<br>                     Stop the tracee at the next fork(2) and automatically<br>                     start tracing the newly forked process, which will<br>                     start with a <b>SIGSTOP</b>, or <b>PTRACE_EVENT_STOP </b>if<br>                     <b>PTRACE_SEIZE </b>was used.  A waitpid(2) by the tracer will<br>                     return a <i>status</i> value such that<br><br>                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_FORK&lt;&lt;8))<br><br>                     The PID of the new process can be retrieved with<br>                     <b>PTRACE_GETEVENTMSG</b>.<br><br>              <b>PTRACE_O_TRACESYSGOOD </b>(since Linux 2.4.6)<br>                     When delivering system call traps, set bit 7 in the<br>                     signal number (i.e., deliver <i>SIGTRAP|0x80</i>).  This makes<br>                     it easy for the tracer to distinguish normal traps from<br>                     those caused by a system call.  (<b>PTRACE_O_TRACESYSGOOD</b><br>                     may not work on all architectures.)<br><br>              <b>PTRACE_O_TRACEVFORK </b>(since Linux 2.5.46)<br>                     Stop the tracee at the next vfork(2) and automatically<br>                     start tracing the newly vforked process, which will<br>                     start with a <b>SIGSTOP</b>, or <b>PTRACE_EVENT_STOP </b>if<br>                     <b>PTRACE_SEIZE </b>was used.  A waitpid(2) by the tracer will<br>                     return a <i>status</i> value such that<br><br>                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_VFORK&lt;&lt;8))<br><br>                     The PID of the new process can be retrieved with<br>                     <b>PTRACE_GETEVENTMSG</b>.<br><br>              <b>PTRACE_O_TRACEVFORKDONE </b>(since Linux 2.5.60)<br>                     Stop the tracee at the completion of the next vfork(2).<br>                     A waitpid(2) by the tracer will return a <i>status</i> value<br>                     such that<br><br>                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_VFORK_DONE&lt;&lt;8))<br><br>                     The PID of the new process can (since Linux 2.6.18) be<br>                     retrieved with <b>PTRACE_GETEVENTMSG</b>.<br><br>              <b>PTRACE_O_TRACESECCOMP </b>(since Linux 3.5)<br>                     Stop the tracee when a seccomp(2) <b>SECCOMP_RET_TRACE</b><br>                     rule is triggered.  A waitpid(2) by the tracer will<br>                     return a <i>status</i> value such that<br><br>                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_SECCOMP&lt;&lt;8))<br><br>                     While this triggers a <b>PTRACE_EVENT </b>stop, it is similar<br>                     to a syscall-enter-stop, in that the tracee has not yet<br>                     entered the syscall that seccomp triggered on.  The<br>                     seccomp event message data (from the <b>SECCOMP_RET_DATA</b><br>                     portion of the seccomp filter rule) can be retrieved<br>                     with <b>PTRACE_GETEVENTMSG</b>.<br><br>       <b>PTRACE_GETEVENTMSG </b>(since Linux 2.5.46)<br>              Retrieve a message (as an <i>unsigned long</i>) about the ptrace<br>              event that just happened, placing it at the address <i>data</i> in<br>              the tracer.  For <b>PTRACE_EVENT_EXIT</b>, this is the tracee's exit<br>              status.  For <b>PTRACE_EVENT_FORK</b>, <b>PTRACE_EVENT_VFORK</b>,<br>              <b>PTRACE_EVENT_VFORK_DONE</b>, and <b>PTRACE_EVENT_CLONE</b>, this is the<br>              PID of the new process.  For <b>PTRACE_EVENT_SECCOMP</b>, this is the<br>              seccomp(2) filter's <b>SECCOMP_RET_DATA </b>associated with the<br>              triggered rule.  (<i>addr</i> is ignored.)<br><br>       <b>PTRACE_CONT</b><br>              Restart the stopped tracee process.  If <i>data</i> is nonzero, it is<br>              interpreted as the number of a signal to be delivered to the<br>              tracee; otherwise, no signal is delivered.  Thus, for example,<br>              the tracer can control whether a signal sent to the tracee is<br>              delivered or not.  (<i>addr</i> is ignored.)<br><br>       <b>PTRACE_SYSCALL</b>, <b>PTRACE_SINGLESTEP</b><br>              Restart the stopped tracee as for <b>PTRACE_CONT</b>, but arrange for<br>              the tracee to be stopped at the next entry to or exit from a<br>              system call, or after execution of a single instruction,<br>              respectively.  (The tracee will also, as usual, be stopped<br>              upon receipt of a signal.)  From the tracer's perspective, the<br>              tracee will appear to have been stopped by receipt of a<br>              <b>SIGTRAP</b>.  So, for <b>PTRACE_SYSCALL</b>, for example, the idea is to<br>              inspect the arguments to the system call at the first stop,<br>              then do another <b>PTRACE_SYSCALL </b>and inspect the return value of<br>              the system call at the second stop.  The <i>data</i> argument is<br>              treated as for <b>PTRACE_CONT</b>.  (<i>addr</i> is ignored.)<br><br>       <b>PTRACE_SYSEMU</b>, <b>PTRACE_SYSEMU_SINGLESTEP </b>(since Linux 2.6.14)<br>              For <b>PTRACE_SYSEMU</b>, continue and stop on entry to the next<br>              system call, which will not be executed.  For<br>              <b>PTRACE_SYSEMU_SINGLESTEP</b>, do the same but also singlestep if<br>              not a system call.  This call is used by programs like User<br>              Mode Linux that want to emulate all the tracee's system calls.<br>              The <i>data</i> argument is treated as for <b>PTRACE_CONT</b>.  The <i>addr</i><br>              argument is ignored.  These requests are currently supported<br>              only on x86.<br><br>       <b>PTRACE_LISTEN </b>(since Linux 3.4)<br>              Restart the stopped tracee, but prevent it from executing.<br>              The resulting state of the tracee is similar to a process<br>              which has been stopped by a <b>SIGSTOP </b>(or other stopping<br>              signal).  See the \"group-stop\" subsection for additional<br>              information.  <b>PTRACE_LISTEN </b>works only on tracees attached by<br>              <b>PTRACE_SEIZE</b>.<br><br>       <b>PTRACE_KILL</b><br>              Send the tracee a <b>SIGKILL </b>to terminate it.  (<i>addr</i> and <i>data</i> are<br>              ignored.)<br><br>              <i>This operation is deprecated; do not use it!</i>  Instead, send a<br>              <b>SIGKILL </b>directly using kill(2) or tgkill(2).  The problem with<br>              <b>PTRACE_KILL </b>is that it requires the tracee to be in signal-<br>              delivery-stop, otherwise it may not work (i.e., may complete<br>              successfully but won't kill the tracee).  By contrast, sending<br>              a <b>SIGKILL </b>directly has no such limitation.<br><br>       <b>PTRACE_INTERRUPT </b>(since Linux 3.4)<br>              Stop a tracee.  If the tracee is running or sleeping in kernel<br>              space and <b>PTRACE_SYSCALL </b>is in effect, the system call is<br>              interrupted and syscall-exit-stop is reported.  (The<br>              interrupted system call is restarted when the tracee is<br>              restarted.)  If the tracee was already stopped by a signal and<br>              <b>PTRACE_LISTEN </b>was sent to it, the tracee stops with<br>              <b>PTRACE_EVENT_STOP </b>and <i>WSTOPSIG(status)</i> returns the stop<br>              signal.  If any other ptrace-stop is generated at the same<br>              time (for example, if a signal is sent to the tracee), this<br>              ptrace-stop happens.  If none of the above applies (for<br>              example, if the tracee is running in user space), it stops<br>              with <b>PTRACE_EVENT_STOP </b>with <i>WSTOPSIG(status)</i> == <b>SIGTRAP</b>.<br>              <b>PTRACE_INTERRUPT </b>only works on tracees attached by<br>              <b>PTRACE_SEIZE</b>.<br><br>       <b>PTRACE_ATTACH</b><br>              Attach to the process specified in <i>pid</i>, making it a tracee of<br>              the calling process.  The tracee is sent a <b>SIGSTOP</b>, but will<br>              not necessarily have stopped by the completion of this call;<br>              use waitpid(2) to wait for the tracee to stop.  See the<br>              \"Attaching and detaching\" subsection for additional<br>              information.  (<i>addr</i> and <i>data</i> are ignored.)<br><br>       <b>PTRACE_SEIZE </b>(since Linux 3.4)<br>              Attach to the process specified in <i>pid</i>, making it a tracee of<br>              the calling process.  Unlike <b>PTRACE_ATTACH</b>, <b>PTRACE_SEIZE </b>does<br>              not stop the process.  Group-stops are reported as<br>              <b>PTRACE_EVENT_STOP </b>and <i>WSTOPSIG(status)</i> returns the stop<br>              signal.  Automatically attached children stop with<br>              <b>PTRACE_EVENT_STOP </b>and <i>WSTOPSIG(status)</i> returns <b>SIGTRAP </b>instead<br>              of having <b>SIGSTOP </b>signal delivered to them.  <b>evecve</b>(2) does<br>              not deliver an extra <b>SIGTRAP</b>.  Only a <b>PTRACE_SEIZE</b>d process<br>              can accept <b>PTRACE_INTERRUPT </b>and <b>PTRACE_LISTEN </b>commands.  The<br>              \"seized\" behavior just described is inherited by children that<br>              are automatically attached using <b>PTRACE_O_TRACEFORK</b>,<br>              <b>PTRACE_O_TRACEVFORK</b>, and <b>PTRACE_O_TRACECLONE</b>.  <i>addr</i> must be<br>              zero.  <i>data</i> contains a bit mask of ptrace options to activate<br>              immediately.<br><br>       <b>PTRACE_DETACH</b><br>              Restart the stopped tracee as for <b>PTRACE_CONT</b>, but first<br>              detach from it.  Under Linux, a tracee can be detached in this<br>              way regardless of which method was used to initiate tracing.<br>              (<i>addr</i> is ignored.)<br><br>   <b>Death under ptrace</b><br>       When a (possibly multithreaded) process receives a killing signal<br>       (one whose disposition is set to <b>SIG_DFL </b>and whose default action is<br>       to kill the process), all threads exit.  Tracees report their death<br>       to their tracer(s).  Notification of this event is delivered via<br>       waitpid(2).<br><br>       Note that the killing signal will first cause signal-delivery-stop<br>       (on one tracee only), and only after it is injected by the tracer (or<br>       after it was dispatched to a thread which isn't traced), will death<br>       from the signal happen on <i>all</i> tracees within a multithreaded process.<br>       (The term \"signal-delivery-stop\" is explained below.)<br><br>       <b>SIGKILL </b>does not generate signal-delivery-stop and therefore the<br>       tracer can't suppress it.  <b>SIGKILL </b>kills even within system calls<br>       (syscall-exit-stop is not generated prior to death by <b>SIGKILL</b>).  The<br>       net effect is that <b>SIGKILL </b>always kills the process (all its<br>       threads), even if some threads of the process are ptraced.<br><br>       When the tracee calls _exit(2), it reports its death to its tracer.<br>       Other threads are not affected.<br><br>       When any thread executes exit_group(2), every tracee in its thread<br>       group reports its death to its tracer.<br><br>       If the <b>PTRACE_O_TRACEEXIT </b>option is on, <b>PTRACE_EVENT_EXIT </b>will happen<br>       before actual death.  This applies to exits via exit(2),<br>       exit_group(2), and signal deaths (except <b>SIGKILL</b>, depending on the<br>       kernel version; see BUGS below), and when threads are torn down on<br>       execve(2) in a multithreaded process.<br><br>       The tracer cannot assume that the ptrace-stopped tracee exists.<br>       There are many scenarios when the tracee may die while stopped (such<br>       as <b>SIGKILL</b>).  Therefore, the tracer must be prepared to handle an<br>       <b>ESRCH </b>error on any ptrace operation.  Unfortunately, the same error<br>       is returned if the tracee exists but is not ptrace-stopped (for<br>       commands which require a stopped tracee), or if it is not traced by<br>       the process which issued the ptrace call.  The tracer needs to keep<br>       track of the stopped/running state of the tracee, and interpret <b>ESRCH</b><br>       as \"tracee died unexpectedly\" only if it knows that the tracee has<br>       been observed to enter ptrace-stop.  Note that there is no guarantee<br>       that <i>waitpid(WNOHANG)</i> will reliably report the tracee's death status<br>       if a ptrace operation returned <b>ESRCH</b>.  <i>waitpid(WNOHANG)</i> may return 0<br>       instead.  In other words, the tracee may be \"not yet fully dead\", but<br>       already refusing ptrace requests.<br><br>       The tracer can't assume that the tracee <i>always</i> ends its life by<br>       reporting <i>WIFEXITED(status)</i> or <i>WIFSIGNALED(status)</i>; there are cases<br>       where this does not occur.  For example, if a thread other than<br>       thread group leader does an execve(2), it disappears; its PID will<br>       never be seen again, and any subsequent ptrace stops will be reported<br>       under the thread group leader's PID.<br><br>   <b>Stopped states</b><br>       A tracee can be in two states: running or stopped.  For the purposes<br>       of ptrace, a tracee which is blocked in a system call (such as<br>       read(2), pause(2), etc.)  is nevertheless considered to be running,<br>       even if the tracee is blocked for a long time.  The state of the<br>       tracee after <b>PTRACE_LISTEN </b>is somewhat of a gray area: it is not in<br>       any ptrace-stop (ptrace commands won't work on it, and it will<br>       deliver waitpid(2) notifications), but it also may be considered<br>       \"stopped\" because it is not executing instructions (is not<br>       scheduled), and if it was in group-stop before <b>PTRACE_LISTEN</b>, it will<br>       not respond to signals until <b>SIGCONT </b>is received.<br><br>       There are many kinds of states when the tracee is stopped, and in<br>       ptrace discussions they are often conflated.  Therefore, it is<br>       important to use precise terms.<br><br>       In this manual page, any stopped state in which the tracee is ready<br>       to accept ptrace commands from the tracer is called <i>ptrace-stop</i>.<br>       Ptrace-stops can be further subdivided into <i>signal-delivery-stop</i>,<br>       <i>group-stop</i>, <i>syscall-stop</i>, and so on.  These stopped states are<br>       described in detail below.<br><br>       When the running tracee enters ptrace-stop, it notifies its tracer<br>       using waitpid(2) (or one of the other \"wait\" system calls).  Most of<br>       this manual page assumes that the tracer waits with:<br><br>           pid = waitpid(pid_or_minus_1, &amp;status, __WALL);<br><br>       Ptrace-stopped tracees are reported as returns with <i>pid</i> greater than<br>       0 and <i>WIFSTOPPED(status)</i> true.<br><br>       The <b>__WALL </b>flag does not include the <b>WSTOPPED </b>and <b>WEXITED </b>flags, but<br>       implies their functionality.<br><br>       Setting the <b>WCONTINUED </b>flag when calling waitpid(2) is not<br>       recommended: the \"continued\" state is per-process and consuming it<br>       can confuse the real parent of the tracee.<br><br>       Use of the <b>WNOHANG </b>flag may cause waitpid(2) to return 0 (\"no wait<br>       results available yet\") even if the tracer knows there should be a<br>       notification.  Example:<br><br>           errno = 0;<br>           ptrace(PTRACE_CONT, pid, 0L, 0L);<br>           if (errno == ESRCH) {<br>               /* tracee is dead */<br>               r = waitpid(tracee, &amp;status, __WALL | WNOHANG);<br>               /* r can still be 0 here! */<br>           }<br><br>       The following kinds of ptrace-stops exist: signal-delivery-stops,<br>       group-stops, <b>PTRACE_EVENT </b>stops, syscall-stops.  They all are<br>       reported by waitpid(2) with <i>WIFSTOPPED(status)</i> true.  They may be<br>       differentiated by examining the value <i>status&gt;&gt;8</i>, and if there is<br>       ambiguity in that value, by querying <b>PTRACE_GETSIGINFO</b>.  (Note: the<br>       <i>WSTOPSIG(status)</i> macro can't be used to perform this examination,<br>       because it returns the value <i>(status&gt;&gt;8) &amp; 0xff</i>.)<br><br>   <b>Signal-delivery-stop</b><br>       When a (possibly multithreaded) process receives any signal except<br>       <b>SIGKILL</b>, the kernel selects an arbitrary thread which handles the<br>       signal.  (If the signal is generated with tgkill(2), the target<br>       thread can be explicitly selected by the caller.)  If the selected<br>       thread is traced, it enters signal-delivery-stop.  At this point, the<br>       signal is not yet delivered to the process, and can be suppressed by<br>       the tracer.  If the tracer doesn't suppress the signal, it passes the<br>       signal to the tracee in the next ptrace restart request.  This second<br>       step of signal delivery is called <i>signal injection</i> in this manual<br>       page.  Note that if the signal is blocked, signal-delivery-stop<br>       doesn't happen until the signal is unblocked, with the usual<br>       exception that <b>SIGSTOP </b>can't be blocked.<br><br>       Signal-delivery-stop is observed by the tracer as waitpid(2)<br>       returning with <i>WIFSTOPPED(status)</i> true, with the signal returned by<br>       <i>WSTOPSIG(status)</i>.  If the signal is <b>SIGTRAP</b>, this may be a different<br>       kind of ptrace-stop; see the \"Syscall-stops\" and \"execve\" sections<br>       below for details.  If <i>WSTOPSIG(status)</i> returns a stopping signal,<br>       this may be a group-stop; see below.<br><br>   <b>Signal injection and suppression</b><br>       After signal-delivery-stop is observed by the tracer, the tracer<br>       should restart the tracee with the call<br><br>           ptrace(PTRACE_restart, pid, 0, sig)<br><br>       where <b>PTRACE_restart </b>is one of the restarting ptrace requests.  If<br>       <i>sig</i> is 0, then a signal is not delivered.  Otherwise, the signal <i>sig</i><br>       is delivered.  This operation is called <i>signal injection</i> in this<br>       manual page, to distinguish it from signal-delivery-stop.<br><br>       The <i>sig</i> value may be different from the <i>WSTOPSIG(status)</i> value: the<br>       tracer can cause a different signal to be injected.<br><br>       Note that a suppressed signal still causes system calls to return<br>       prematurely.  In this case, system calls will be restarted: the<br>       tracer will observe the tracee to reexecute the interrupted system<br>       call (or restart_syscall(2) system call for a few system calls which<br>       use a different mechanism for restarting) if the tracer uses<br>       <b>PTRACE_SYSCALL</b>.  Even system calls (such as poll(2)) which are not<br>       restartable after signal are restarted after signal is suppressed;<br>       however, kernel bugs exist which cause some system calls to fail with<br>       <b>EINTR </b>even though no observable signal is injected to the tracee.<br><br>       Restarting ptrace commands issued in ptrace-stops other than signal-<br>       delivery-stop are not guaranteed to inject a signal, even if <i>sig</i> is<br>       nonzero.  No error is reported; a nonzero <i>sig</i> may simply be ignored.<br>       Ptrace users should not try to \"create a new signal\" this way: use<br>       tgkill(2) instead.<br><br>       The fact that signal injection requests may be ignored when<br>       restarting the tracee after ptrace stops that are not signal-<br>       delivery-stops is a cause of confusion among ptrace users.  One<br>       typical scenario is that the tracer observes group-stop, mistakes it<br>       for signal-delivery-stop, restarts the tracee with<br><br>           ptrace(PTRACE_restart, pid, 0, stopsig)<br><br>       with the intention of injecting <i>stopsig</i>, but <i>stopsig</i> gets ignored and<br>       the tracee continues to run.<br><br>       The <b>SIGCONT </b>signal has a side effect of waking up (all threads of) a<br>       group-stopped process.  This side effect happens before signal-<br>       delivery-stop.  The tracer can't suppress this side effect (it can<br>       only suppress signal injection, which only causes the <b>SIGCONT </b>handler<br>       to not be executed in the tracee, if such a handler is installed).<br>       In fact, waking up from group-stop may be followed by signal-<br>       delivery-stop for signal(s) <i>other than</i> <b>SIGCONT</b>, if they were pending<br>       when <b>SIGCONT </b>was delivered.  In other words, <b>SIGCONT </b>may be not the<br>       first signal observed by the tracee after it was sent.<br><br>       Stopping signals cause (all threads of) a process to enter group-<br>       stop.  This side effect happens after signal injection, and therefore<br>       can be suppressed by the tracer.<br><br>       In Linux 2.4 and earlier, the <b>SIGSTOP </b>signal can't be injected.<br><br>       <b>PTRACE_GETSIGINFO </b>can be used to retrieve a <i>siginfo_t</i> structure which<br>       corresponds to the delivered signal.  <b>PTRACE_SETSIGINFO </b>may be used<br>       to modify it.  If <b>PTRACE_SETSIGINFO </b>has been used to alter <i>siginfo_t</i>,<br>       the <i>si_signo</i> field and the <i>sig</i> parameter in the restarting command<br>       must match, otherwise the result is undefined.<br><br>   <b>Group-stop</b><br>       When a (possibly multithreaded) process receives a stopping signal,<br>       all threads stop.  If some threads are traced, they enter a group-<br>       stop.  Note that the stopping signal will first cause signal-<br>       delivery-stop (on one tracee only), and only after it is injected by<br>       the tracer (or after it was dispatched to a thread which isn't<br>       traced), will group-stop be initiated on <i>all</i> tracees within the<br>       multithreaded process.  As usual, every tracee reports its group-stop<br>       separately to the corresponding tracer.<br><br>       Group-stop is observed by the tracer as waitpid(2) returning with<br>       <i>WIFSTOPPED(status)</i> true, with the stopping signal available via<br>       <i>WSTOPSIG(status)</i>.  The same result is returned by some other classes<br>       of ptrace-stops, therefore the recommended practice is to perform the<br>       call<br><br>           ptrace(PTRACE_GETSIGINFO, pid, 0, &amp;siginfo)<br><br>       The call can be avoided if the signal is not <b>SIGSTOP</b>, <b>SIGTSTP</b>,<br>       <b>SIGTTIN</b>, or <b>SIGTTOU</b>; only these four signals are stopping signals.<br>       If the tracer sees something else, it can't be a group-stop.<br>       Otherwise, the tracer needs to call <b>PTRACE_GETSIGINFO</b>.  If<br>       <b>PTRACE_GETSIGINFO </b>fails with <b>EINVAL</b>, then it is definitely a group-<br>       stop.  (Other failure codes are possible, such as <b>ESRCH </b>(\"no such<br>       process\") if a <b>SIGKILL </b>killed the tracee.)<br><br>       If tracee was attached using <b>PTRACE_SEIZE</b>, group-stop is indicated by<br>       <b>PTRACE_EVENT_STOP</b>: <i>status&gt;&gt;16 == PTRACE_EVENT_STOP</i>.  This allows<br>       detection of group-stops without requiring an extra <b>PTRACE_GETSIGINFO</b><br>       call.<br><br>       As of Linux 2.6.38, after the tracer sees the tracee ptrace-stop and<br>       until it restarts or kills it, the tracee will not run, and will not<br>       send notifications (except <b>SIGKILL </b>death) to the tracer, even if the<br>       tracer enters into another waitpid(2) call.<br><br>       The kernel behavior described in the previous paragraph causes a<br>       problem with transparent handling of stopping signals.  If the tracer<br>       restarts the tracee after group-stop, the stopping signal is<br>       effectively ignored&#8212;the tracee doesn't remain stopped, it runs.  If<br>       the tracer doesn't restart the tracee before entering into the next<br>       waitpid(2), future <b>SIGCONT </b>signals will not be reported to the<br>       tracer; this would cause the <b>SIGCONT </b>signals to have no effect on the<br>       tracee.<br><br>       Since Linux 3.4, there is a method to overcome this problem: instead<br>       of <b>PTRACE_CONT</b>, a <b>PTRACE_LISTEN </b>command can be used to restart a<br>       tracee in a way where it does not execute, but waits for a new event<br>       which it can report via waitpid(2) (such as when it is restarted by a<br>       <b>SIGCONT</b>).<br><br>   <b>PTRACE_EVENT stops</b><br>       If the tracer sets <b>PTRACE_O_TRACE_* </b>options, the tracee will enter<br>       ptrace-stops called <b>PTRACE_EVENT </b>stops.<br><br>       <b>PTRACE_EVENT </b>stops are observed by the tracer as waitpid(2) returning<br>       with <i>WIFSTOPPED(status)</i>, and <i>WSTOPSIG(status)</i> returns <b>SIGTRAP</b>.  An<br>       additional bit is set in the higher byte of the status word: the<br>       value <i>status&gt;&gt;8</i> will be<br><br>           (SIGTRAP | PTRACE_EVENT_foo &lt;&lt; 8).<br><br>       The following events exist:<br><br>       <b>PTRACE_EVENT_VFORK</b><br>              Stop before return from vfork(2) or clone(2) with the<br>              <b>CLONE_VFORK </b>flag.  When the tracee is continued after this<br>              stop, it will wait for child to exit/exec before continuing<br>              its execution (in other words, the usual behavior on<br>              vfork(2)).<br><br>       <b>PTRACE_EVENT_FORK</b><br>              Stop before return from fork(2) or clone(2) with the exit<br>              signal set to <b>SIGCHLD</b>.<br><br>       <b>PTRACE_EVENT_CLONE</b><br>              Stop before return from clone(2).<br><br>       <b>PTRACE_EVENT_VFORK_DONE</b><br>              Stop before return from vfork(2) or clone(2) with the<br>              <b>CLONE_VFORK </b>flag, but after the child unblocked this tracee by<br>              exiting or execing.<br><br>       For all four stops described above, the stop occurs in the parent<br>       (i.e., the tracee), not in the newly created thread.<br>       <b>PTRACE_GETEVENTMSG </b>can be used to retrieve the new thread's ID.<br><br>       <b>PTRACE_EVENT_EXEC</b><br>              Stop before return from execve(2).  Since Linux 3.0,<br>              <b>PTRACE_GETEVENTMSG </b>returns the former thread ID.<br><br>       <b>PTRACE_EVENT_EXIT</b><br>              Stop before exit (including death from exit_group(2)), signal<br>              death, or exit caused by execve(2) in a multithreaded process.<br>              <b>PTRACE_GETEVENTMSG </b>returns the exit status.  Registers can be<br>              examined (unlike when \"real\" exit happens).  The tracee is<br>              still alive; it needs to be <b>PTRACE_CONT</b>ed or <b>PTRACE_DETACH</b>ed<br>              to finish exiting.<br><br>       <b>PTRACE_EVENT_STOP</b><br>              Stop induced by <b>PTRACE_INTERRUPT </b>command, or group-stop, or<br>              initial ptrace-stop when a new child is attached (only if<br>              attached using <b>PTRACE_SEIZE</b>).<br><br>       <b>PTRACE_EVENT_SECCOMP</b><br>              Stop triggered by a seccomp(2) rule on tracee syscall entry<br>              when <b>PTRACE_O_TRACESECCOMP </b>has been set by the tracer.  The<br>              seccomp event message data (from the <b>SECCOMP_RET_DATA </b>portion<br>              of the seccomp filter rule) can be retrieved with<br>              <b>PTRACE_GETEVENTMSG</b>.<br><br>       <b>PTRACE_GETSIGINFO </b>on <b>PTRACE_EVENT </b>stops returns <b>SIGTRAP </b>in <i>si_signo</i>,<br>       with <i>si_code</i> set to <i>(event&lt;&lt;8) | SIGTRAP</i>.<br><br>   <b>Syscall-stops</b><br>       If the tracee was restarted by <b>PTRACE_SYSCALL</b>, the tracee enters<br>       syscall-enter-stop just prior to entering any system call.  If the<br>       tracer restarts the tracee with <b>PTRACE_SYSCALL</b>, the tracee enters<br>       syscall-exit-stop when the system call is finished, or if it is<br>       interrupted by a signal.  (That is, signal-delivery-stop never<br>       happens between syscall-enter-stop and syscall-exit-stop; it happens<br>       <i>after</i> syscall-exit-stop.)<br><br>       Other possibilities are that the tracee may stop in a <b>PTRACE_EVENT</b><br>       stop, exit (if it entered _exit(2) or exit_group(2)), be killed by<br>       <b>SIGKILL</b>, or die silently (if it is a thread group leader, the<br>       execve(2) happened in another thread, and that thread is not traced<br>       by the same tracer; this situation is discussed later).<br><br>       Syscall-enter-stop and syscall-exit-stop are observed by the tracer<br>       as waitpid(2) returning with <i>WIFSTOPPED(status)</i> true, and<br>       <i>WSTOPSIG(status)</i> giving <b>SIGTRAP</b>.  If the <b>PTRACE_O_TRACESYSGOOD </b>option<br>       was set by the tracer, then <i>WSTOPSIG(status)</i> will give the value<br>       <i>(SIGTRAP | 0x80)</i>.<br><br>       Syscall-stops can be distinguished from signal-delivery-stop with<br>       <b>SIGTRAP </b>by querying <b>PTRACE_GETSIGINFO </b>for the following cases:<br><br>       <i>si_code</i> &lt;= 0<br>              <b>SIGTRAP </b>was delivered as a result of a user-space action, for<br>              example, a system call (tgkill(2), kill(2), sigqueue(3),<br>              etc.), expiration of a POSIX timer, change of state on a POSIX<br>              message queue, or completion of an asynchronous I/O request.<br><br>       <i>si_code</i> == SI_KERNEL (0x80)<br>              <b>SIGTRAP </b>was sent by the kernel.<br><br>       <i>si_code</i> == SIGTRAP or <i>si_code</i> == (SIGTRAP|0x80)<br>              This is a syscall-stop.<br><br>       However, syscall-stops happen very often (twice per system call), and<br>       performing <b>PTRACE_GETSIGINFO </b>for every syscall-stop may be somewhat<br>       expensive.<br><br>       Some architectures allow the cases to be distinguished by examining<br>       registers.  For example, on x86, <i>rax</i> == -<b>ENOSYS </b>in syscall-enter-<br>       stop.  Since <b>SIGTRAP </b>(like any other signal) always happens <i>after</i><br>       syscall-exit-stop, and at this point <i>rax</i> almost never contains<br>       -<b>ENOSYS</b>, the <b>SIGTRAP </b>looks like \"syscall-stop which is not syscall-<br>       enter-stop\"; in other words, it looks like a \"stray syscall-exit-<br>       stop\" and can be detected this way.  But such detection is fragile<br>       and is best avoided.<br><br>       Using the <b>PTRACE_O_TRACESYSGOOD </b>option is the recommended method to<br>       distinguish syscall-stops from other kinds of ptrace-stops, since it<br>       is reliable and does not incur a performance penalty.<br><br>       Syscall-enter-stop and syscall-exit-stop are indistinguishable from<br>       each other by the tracer.  The tracer needs to keep track of the<br>       sequence of ptrace-stops in order to not misinterpret syscall-enter-<br>       stop as syscall-exit-stop or vice versa.  The rule is that syscall-<br>       enter-stop is always followed by syscall-exit-stop, <b>PTRACE_EVENT </b>stop<br>       or the tracee's death; no other kinds of ptrace-stop can occur in<br>       between.<br><br>       If after syscall-enter-stop, the tracer uses a restarting command<br>       other than <b>PTRACE_SYSCALL</b>, syscall-exit-stop is not generated.<br><br>       <b>PTRACE_GETSIGINFO </b>on syscall-stops returns <b>SIGTRAP </b>in <i>si_signo</i>, with<br>       <i>si_code</i> set to <b>SIGTRAP </b>or <i>(SIGTRAP|0x80)</i>.<br><br>   <b>PTRACE_SINGLESTEP, PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP stops</b><br>       [Details of these kinds of stops are yet to be documented.]<br><br>   <b>Informational and restarting ptrace commands</b><br>       Most ptrace commands (all except <b>PTRACE_ATTACH</b>, <b>PTRACE_SEIZE</b>,<br>       <b>PTRACE_TRACEME</b>, <b>PTRACE_INTERRUPT</b>, and <b>PTRACE_KILL</b>) require the tracee<br>       to be in a ptrace-stop, otherwise they fail with <b>ESRCH</b>.<br><br>       When the tracee is in ptrace-stop, the tracer can read and write data<br>       to the tracee using informational commands.  These commands leave the<br>       tracee in ptrace-stopped state:<br><br>           ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER, pid, addr, 0);<br>           ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr, long_val);<br>           ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &amp;struct);<br>           ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &amp;struct);<br>           ptrace(PTRACE_GETREGSET, pid, NT_foo, &amp;iov);<br>           ptrace(PTRACE_SETREGSET, pid, NT_foo, &amp;iov);<br>           ptrace(PTRACE_GETSIGINFO, pid, 0, &amp;siginfo);<br>           ptrace(PTRACE_SETSIGINFO, pid, 0, &amp;siginfo);<br>           ptrace(PTRACE_GETEVENTMSG, pid, 0, &amp;long_var);<br>           ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);<br><br>       Note that some errors are not reported.  For example, setting signal<br>       information (<i>siginfo</i>) may have no effect in some ptrace-stops, yet<br>       the call may succeed (return 0 and not set <i>errno</i>); querying<br>       <b>PTRACE_GETEVENTMSG </b>may succeed and return some random value if<br>       current ptrace-stop is not documented as returning a meaningful event<br>       message.<br><br>       The call<br><br>           ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);<br><br>       affects one tracee.  The tracee's current flags are replaced.  Flags<br>       are inherited by new tracees created and \"auto-attached\" via active<br>       <b>PTRACE_O_TRACEFORK</b>, <b>PTRACE_O_TRACEVFORK</b>, or <b>PTRACE_O_TRACECLONE</b><br>       options.<br><br>       Another group of commands makes the ptrace-stopped tracee run.  They<br>       have the form:<br><br>           ptrace(cmd, pid, 0, sig);<br><br>       where <i>cmd</i> is <b>PTRACE_CONT</b>, <b>PTRACE_LISTEN</b>, <b>PTRACE_DETACH</b>,<br>       <b>PTRACE_SYSCALL</b>, <b>PTRACE_SINGLESTEP</b>, <b>PTRACE_SYSEMU</b>, or<br>       <b>PTRACE_SYSEMU_SINGLESTEP</b>.  If the tracee is in signal-delivery-stop,<br>       <i>sig</i> is the signal to be injected (if it is nonzero).  Otherwise, <i>sig</i><br>       may be ignored.  (When restarting a tracee from a ptrace-stop other<br>       than signal-delivery-stop, recommended practice is to always pass 0<br>       in <i>sig</i>.)<br><br>   <b>Attaching and detaching</b><br>       A thread can be attached to the tracer using the call<br><br>           ptrace(PTRACE_ATTACH, pid, 0, 0);<br><br>       or<br><br>           ptrace(PTRACE_SEIZE, pid, 0, PTRACE_O_flags);<br><br>       <b>PTRACE_ATTACH </b>sends <b>SIGSTOP </b>to this thread.  If the tracer wants this<br>       <b>SIGSTOP </b>to have no effect, it needs to suppress it.  Note that if<br>       other signals are concurrently sent to this thread during attach, the<br>       tracer may see the tracee enter signal-delivery-stop with other<br>       signal(s) first!  The usual practice is to reinject these signals<br>       until <b>SIGSTOP </b>is seen, then suppress <b>SIGSTOP </b>injection.  The design<br>       bug here is that a ptrace attach and a concurrently delivered <b>SIGSTOP</b><br>       may race and the concurrent <b>SIGSTOP </b>may be lost.<br><br>       Since attaching sends <b>SIGSTOP </b>and the tracer usually suppresses it,<br>       this may cause a stray <b>EINTR </b>return from the currently executing<br>       system call in the tracee, as described in the \"Signal injection and<br>       suppression\" section.<br><br>       Since Linux 3.4, <b>PTRACE_SEIZE </b>can be used instead of <b>PTRACE_ATTACH</b>.<br>       <b>PTRACE_SEIZE </b>does not stop the attached process.  If you need to stop<br>       it after attach (or at any other time) without sending it any<br>       signals, use <b>PTRACE_INTERRUPT </b>command.<br><br>       The request<br><br>           ptrace(PTRACE_TRACEME, 0, 0, 0);<br><br>       turns the calling thread into a tracee.  The thread continues to run<br>       (doesn't enter ptrace-stop).  A common practice is to follow the<br>       <b>PTRACE_TRACEME </b>with<br><br>           raise(SIGSTOP);<br><br>       and allow the parent (which is our tracer now) to observe our signal-<br>       delivery-stop.<br><br>       If the <b>PTRACE_O_TRACEFORK</b>, <b>PTRACE_O_TRACEVFORK</b>, or<br>       <b>PTRACE_O_TRACECLONE </b>options are in effect, then children created by,<br>       respectively, vfork(2) or clone(2) with the <b>CLONE_VFORK </b>flag, fork(2)<br>       or clone(2) with the exit signal set to <b>SIGCHLD</b>, and other kinds of<br>       clone(2), are automatically attached to the same tracer which traced<br>       their parent.  <b>SIGSTOP </b>is delivered to the children, causing them to<br>       enter signal-delivery-stop after they exit the system call which<br>       created them.<br><br>       Detaching of the tracee is performed by:<br><br>           ptrace(PTRACE_DETACH, pid, 0, sig);<br><br>       <b>PTRACE_DETACH </b>is a restarting operation; therefore it requires the<br>       tracee to be in ptrace-stop.  If the tracee is in signal-delivery-<br>       stop, a signal can be injected.  Otherwise, the <i>sig</i> parameter may be<br>       silently ignored.<br><br>       If the tracee is running when the tracer wants to detach it, the<br>       usual solution is to send <b>SIGSTOP </b>(using tgkill(2), to make sure it<br>       goes to the correct thread), wait for the tracee to stop in signal-<br>       delivery-stop for <b>SIGSTOP </b>and then detach it (suppressing <b>SIGSTOP</b><br>       injection).  A design bug is that this can race with concurrent<br>       <b>SIGSTOP</b>s.  Another complication is that the tracee may enter other<br>       ptrace-stops and needs to be restarted and waited for again, until<br>       <b>SIGSTOP </b>is seen.  Yet another complication is to be sure that the<br>       tracee is not already ptrace-stopped, because no signal delivery<br>       happens while it is&#8212;not even <b>SIGSTOP</b>.<br><br>       If the tracer dies, all tracees are automatically detached and<br>       restarted, unless they were in group-stop.  Handling of restart from<br>       group-stop is currently buggy, but the \"as planned\" behavior is to<br>       leave tracee stopped and waiting for <b>SIGCONT</b>.  If the tracee is<br>       restarted from signal-delivery-stop, the pending signal is injected.<br><br>   <b>execve(2) under ptrace</b><br>       When one thread in a multithreaded process calls execve(2), the<br>       kernel destroys all other threads in the process, and resets the<br>       thread ID of the execing thread to the thread group ID (process ID).<br>       (Or, to put things another way, when a multithreaded process does an<br>       execve(2), at completion of the call, it appears as though the<br>       execve(2) occurred in the thread group leader, regardless of which<br>       thread did the execve(2).)  This resetting of the thread ID looks<br>       very confusing to tracers:<br><br>       *  All other threads stop in <b>PTRACE_EVENT_EXIT </b>stop, if the<br>          <b>PTRACE_O_TRACEEXIT </b>option was turned on.  Then all other threads<br>          except the thread group leader report death as if they exited via<br>          _exit(2) with exit code 0.<br><br>       *  The execing tracee changes its thread ID while it is in the<br>          execve(2).  (Remember, under ptrace, the \"pid\" returned from<br>          waitpid(2), or fed into ptrace calls, is the tracee's thread ID.)<br>          That is, the tracee's thread ID is reset to be the same as its<br>          process ID, which is the same as the thread group leader's thread<br>          ID.<br><br>       *  Then a <b>PTRACE_EVENT_EXEC </b>stop happens, if the <b>PTRACE_O_TRACEEXEC</b><br>          option was turned on.<br><br>       *  If the thread group leader has reported its <b>PTRACE_EVENT_EXIT </b>stop<br>          by this time, it appears to the tracer that the dead thread leader<br>          \"reappears from nowhere\".  (Note: the thread group leader does not<br>          report death via <i>WIFEXITED(status)</i> until there is at least one<br>          other live thread.  This eliminates the possibility that the<br>          tracer will see it dying and then reappearing.)  If the thread<br>          group leader was still alive, for the tracer this may look as if<br>          thread group leader returns from a different system call than it<br>          entered, or even \"returned from a system call even though it was<br>          not in any system call\".  If the thread group leader was not<br>          traced (or was traced by a different tracer), then during<br>          execve(2) it will appear as if it has become a tracee of the<br>          tracer of the execing tracee.<br><br>       All of the above effects are the artifacts of the thread ID change in<br>       the tracee.<br><br>       The <b>PTRACE_O_TRACEEXEC </b>option is the recommended tool for dealing<br>       with this situation.  First, it enables <b>PTRACE_EVENT_EXEC </b>stop, which<br>       occurs before execve(2) returns.  In this stop, the tracer can use<br>       <b>PTRACE_GETEVENTMSG </b>to retrieve the tracee's former thread ID.  (This<br>       feature was introduced in Linux 3.0.)  Second, the <b>PTRACE_O_TRACEEXEC</b><br>       option disables legacy <b>SIGTRAP </b>generation on execve(2).<br><br>       When the tracer receives <b>PTRACE_EVENT_EXEC </b>stop notification, it is<br>       guaranteed that except this tracee and the thread group leader, no<br>       other threads from the process are alive.<br><br>       On receiving the <b>PTRACE_EVENT_EXEC </b>stop notification, the tracer<br>       should clean up all its internal data structures describing the<br>       threads of this process, and retain only one data structure&#8212;one which<br>       describes the single still running tracee, with<br><br>           thread ID == thread group ID == process ID.<br><br>       Example: two threads call execve(2) at the same time:<br><br>       *** we get syscall-enter-stop in thread 1: **<br>       PID1 execve(\"/bin/foo\", \"foo\" &lt;unfinished ...&gt;<br>       *** we issue PTRACE_SYSCALL for thread 1 **<br>       *** we get syscall-enter-stop in thread 2: **<br>       PID2 execve(\"/bin/bar\", \"bar\" &lt;unfinished ...&gt;<br>       *** we issue PTRACE_SYSCALL for thread 2 **<br>       *** we get PTRACE_EVENT_EXEC for PID0, we issue PTRACE_SYSCALL **<br>       *** we get syscall-exit-stop for PID0: **<br>       PID0 &lt;... execve resumed&gt; )             = 0<br><br>       If the <b>PTRACE_O_TRACEEXEC </b>option is <i>not</i> in effect for the execing<br>       tracee, and if the tracee was <b>PTRACE_ATTACH</b>ed rather that<br>       <b>PTRACE_SEIZE</b>d, the kernel delivers an extra <b>SIGTRAP </b>to the tracee<br>       after execve(2) returns.  This is an ordinary signal (similar to one<br>       which can be generated by <i>kill -TRAP</i>), not a special kind of ptrace-<br>       stop.  Employing <b>PTRACE_GETSIGINFO </b>for this signal returns <i>si_code</i><br>       set to 0 (<i>SI_USER</i>).  This signal may be blocked by signal mask, and<br>       thus may be delivered (much) later.<br><br>       Usually, the tracer (for example, strace(1)) would not want to show<br>       this extra post-execve <b>SIGTRAP </b>signal to the user, and would suppress<br>       its delivery to the tracee (if <b>SIGTRAP </b>is set to <b>SIG_DFL</b>, it is a<br>       killing signal).  However, determining <i>which</i> <b>SIGTRAP </b>to suppress is<br>       not easy.  Setting the <b>PTRACE_O_TRACEEXEC </b>option or using<br>       <b>PTRACE_SEIZE </b>and thus suppressing this extra <b>SIGTRAP </b>is the<br>       recommended approach.<br><br>   <b>Real parent</b><br>       The ptrace API (ab)uses the standard UNIX parent/child signaling over<br>       waitpid(2).  This used to cause the real parent of the process to<br>       stop receiving several kinds of waitpid(2) notifications when the<br>       child process is traced by some other process.<br><br>       Many of these bugs have been fixed, but as of Linux 2.6.38 several<br>       still exist; see BUGS below.<br><br>       As of Linux 2.6.38, the following is believed to work correctly:<br><br>       *  exit/death by signal is reported first to the tracer, then, when<br>          the tracer consumes the waitpid(2) result, to the real parent (to<br>          the real parent only when the whole multithreaded process exits).<br>          If the tracer and the real parent are the same process, the report<br>          is sent only once.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, the <b>PTRACE_PEEK* </b>requests return the requested data (but<br>       see NOTES), while other requests return zero.<br><br>       On error, all requests return -1, and <i>errno</i> is set appropriately.<br>       Since the value returned by a successful <b>PTRACE_PEEK* </b>request may be<br>       -1, the caller must clear <i>errno</i> before the call, and then check it<br>       afterward to determine whether or not an error occurred.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EBUSY  </b>(i386 only) There was an error with allocating or freeing a<br>              debug register.<br><br>       <b>EFAULT </b>There was an attempt to read from or write to an invalid area<br>              in the tracer's or the tracee's memory, probably because the<br>              area wasn't mapped or accessible.  Unfortunately, under Linux,<br>              different variations of this fault will return <b>EIO </b>or <b>EFAULT</b><br>              more or less arbitrarily.<br><br>       <b>EINVAL </b>An attempt was made to set an invalid option.<br><br>       <b>EIO    </b><i>request</i> is invalid, or an attempt was made to read from or<br>              write to an invalid area in the tracer's or the tracee's<br>              memory, or there was a word-alignment violation, or an invalid<br>              signal was specified during a restart request.<br><br>       <b>EPERM  </b>The specified process cannot be traced.  This could be because<br>              the tracer has insufficient privileges (the required<br>              capability is <b>CAP_SYS_PTRACE</b>); unprivileged processes cannot<br>              trace processes that they cannot send signals to or those<br>              running set-user-ID/set-group-ID programs, for obvious<br>              reasons.  Alternatively, the process may already be being<br>              traced, or (on kernels before 2.6.26) be init(1) (PID 1).<br><br>       <b>ESRCH  </b>The specified process does not exist, or is not currently<br>              being traced by the caller, or is not stopped (for requests<br>              that require a stopped tracee).<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       SVr4, 4.3BSD.<br></pre><br><h2>NOTES  </h2><pre><br>       Although arguments to <b>ptrace</b>() are interpreted according to the<br>       prototype given, glibc currently declares <b>ptrace</b>() as a variadic<br>       function with only the <i>request</i> argument fixed.  It is recommended to<br>       always supply four arguments, even if the requested operation does<br>       not use them, setting unused/ignored arguments to <i>0L</i> or <i>(void *) 0</i>.<br><br>       In Linux kernels before 2.6.26, init(1), the process with PID 1, may<br>       not be traced.<br><br>       A tracees parent continues to be the tracer even if that tracer calls<br>       execve(2).<br><br>       The layout of the contents of memory and the USER area are quite<br>       operating-system- and architecture-specific.  The offset supplied,<br>       and the data returned, might not entirely match with the definition<br>       of <i>struct user</i>.<br><br>       The size of a \"word\" is determined by the operating-system variant<br>       (e.g., for 32-bit Linux it is 32 bits).<br><br>       This page documents the way the <b>ptrace</b>() call works currently in<br>       Linux.  Its behavior differs significantly on other flavors of UNIX.<br>       In any case, use of <b>ptrace</b>() is highly specific to the operating<br>       system and architecture.<br><br>   <b>C library/kernel differences</b><br>       At the system call level, the <b>PTRACE_PEEKTEXT</b>, <b>PTRACE_PEEKDATA</b>, and<br>       <b>PTRACE_PEEKUSER </b>requests have a different API: they store the result<br>       at the address specified by the <i>data</i> parameter, and the return value<br>       is the error flag.  The glibc wrapper function provides the API given<br>       in DESCRIPTION above, with the result being returned via the function<br>       return value.<br></pre><br><h2>BUGS  </h2><pre><br>       On hosts with 2.6 kernel headers, <b>PTRACE_SETOPTIONS </b>is declared with<br>       a different value than the one for 2.4.  This leads to applications<br>       compiled with 2.6 kernel headers failing when run on 2.4 kernels.<br>       This can be worked around by redefining <b>PTRACE_SETOPTIONS </b>to<br>       <b>PTRACE_OLDSETOPTIONS</b>, if that is defined.<br><br>       Group-stop notifications are sent to the tracer, but not to real<br>       parent.  Last confirmed on 2.6.38.6.<br><br>       If a thread group leader is traced and exits by calling _exit(2), a<br>       <b>PTRACE_EVENT_EXIT </b>stop will happen for it (if requested), but the<br>       subsequent <b>WIFEXITED </b>notification will not be delivered until all<br>       other threads exit.  As explained above, if one of other threads<br>       calls execve(2), the death of the thread group leader will <i>never</i> be<br>       reported.  If the execed thread is not traced by this tracer, the<br>       tracer will never know that execve(2) happened.  One possible<br>       workaround is to <b>PTRACE_DETACH </b>the thread group leader instead of<br>       restarting it in this case.  Last confirmed on 2.6.38.6.<br><br>       A <b>SIGKILL </b>signal may still cause a <b>PTRACE_EVENT_EXIT </b>stop before<br>       actual signal death.  This may be changed in the future; <b>SIGKILL </b>is<br>       meant to always immediately kill tasks even under ptrace.  Last<br>       confirmed on Linux 3.13.<br><br>       Some system calls return with <b>EINTR </b>if a signal was sent to a tracee,<br>       but delivery was suppressed by the tracer.  (This is very typical<br>       operation: it is usually done by debuggers on every attach, in order<br>       to not introduce a bogus <b>SIGSTOP</b>).  As of Linux 3.2.9, the following<br>       system calls are affected (this list is likely incomplete):<br>       epoll_wait(2), and read(2) from an inotify(7) file descriptor.  The<br>       usual symptom of this bug is that when you attach to a quiescent<br>       process with the command<br><br>           strace -p &lt;process-ID&gt;<br><br>       then, instead of the usual and expected one-line output such as<br><br>           restart_syscall(&lt;... resuming interrupted call ...&gt;_<br><br>       or<br><br>           select(6, [5], NULL, [5], NULL_<br><br>       ('_' denotes the cursor position), you observe more than one line.<br>       For example:<br><br>           clock_gettime(CLOCK_MONOTONIC, {15370, 690928118}) = 0<br>           epoll_wait(4,_<br><br>       What is not visible here is that the process was blocked in<br>       epoll_wait(2) before strace(1) has attached to it.  Attaching caused<br>       epoll_wait(2) to return to user space with the error <b>EINTR</b>.  In this<br>       particular case, the program reacted to <b>EINTR </b>by checking the current<br>       time, and then executing epoll_wait(2) again.  (Programs which do not<br>       expect such \"stray\" <b>EINTR </b>errors may behave in an unintended way upon<br>       an strace(1) attach.)<br></pre><br><h2>SEE ALSO  </h2><pre><br>       gdb(1), strace(1), clone(2), execve(2), fork(2), gettid(2),<br>       seccomp(2), sigaction(2), tgkill(2), vfork(2), waitpid(2), exec(3),<br>       capabilities(7), signal(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                        PTRACE(2)</span><br></pre><br>"}