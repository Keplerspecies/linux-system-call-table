{"Man page": "<pre><br><span class=\"headline\">SIGNAL(2)                 Linux Programmer's Manual                SIGNAL(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       signal - ANSI C signal handling<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;signal.h&gt;</b><br><br>       <b>typedef void (*sighandler_t)(int);</b><br><br>       <b>sighandler_t signal(int </b><i>signum</i><b>, sighandler_t </b><i>handler</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The behavior of <b>signal</b>() varies across UNIX versions, and has also<br>       varied historically across different versions of Linux.  <b>Avoid its</b><br>       <b>use</b>: use sigaction(2) instead.  See <i>Portability</i> below.<br><br>       <b>signal</b>() sets the disposition of the signal <i>signum</i> to <i>handler</i>, which<br>       is either <b>SIG_IGN</b>, <b>SIG_DFL</b>, or the address of a programmer-defined<br>       function (a \"signal handler\").<br><br>       If the signal <i>signum</i> is delivered to the process, then one of the<br>       following happens:<br><br>       *  If the disposition is set to <b>SIG_IGN</b>, then the signal is ignored.<br><br>       *  If the disposition is set to <b>SIG_DFL</b>, then the default action<br>          associated with the signal (see signal(7)) occurs.<br><br>       *  If the disposition is set to a function, then first either the<br>          disposition is reset to <b>SIG_DFL</b>, or the signal is blocked (see<br>          <i>Portability</i> below), and then <i>handler</i> is called with argument<br>          <i>signum</i>.  If invocation of the handler caused the signal to be<br>          blocked, then the signal is unblocked upon return from the<br>          handler.<br><br>       The signals <b>SIGKILL </b>and <b>SIGSTOP </b>cannot be caught or ignored.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       <b>signal</b>() returns the previous value of the signal handler, or <b>SIG_ERR</b><br>       on error.  In the event of an error, <i>errno</i> is set to indicate the<br>       cause.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EINVAL </b><i>signum</i> is invalid.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008, C89, C99.<br></pre><br><h2>NOTES  </h2><pre><br>       The effects of <b>signal</b>() in a multithreaded process are unspecified.<br><br>       According to POSIX, the behavior of a process is undefined after it<br>       ignores a <b>SIGFPE</b>, <b>SIGILL</b>, or <b>SIGSEGV </b>signal that was not generated by<br>       kill(2) or raise(3).  Integer division by zero has undefined result.<br>       On some architectures it will generate a <b>SIGFPE </b>signal.  (Also<br>       dividing the most negative integer by -1 may generate <b>SIGFPE</b>.)<br>       Ignoring this signal might lead to an endless loop.<br><br>       See sigaction(2) for details on what happens when <b>SIGCHLD </b>is set to<br>       <b>SIG_IGN</b>.<br><br>       See signal(7) for a list of the async-signal-safe functions that can<br>       be safely called from inside a signal handler.<br><br>       The use of <i>sighandler_t</i> is a GNU extension, exposed if <b>_GNU_SOURCE </b>is<br>       defined; glibc also defines (the BSD-derived) <i>sig_t</i> if <b>_BSD_SOURCE </b>is<br>       defined.  Without use of such a type, the declaration of <b>signal</b>() is<br>       the somewhat harder to read:<br><br>           <b>void ( *</b><i>signal</i><b>(int </b><i>signum</i><b>, void (*</b><i>handler</i><b>)(int)) ) (int);</b><br><br>   <b>Portability</b><br>       The only portable use of <b>signal</b>() is to set a signal's disposition to<br>       <b>SIG_DFL </b>or <b>SIG_IGN</b>.  The semantics when using <b>signal</b>() to establish a<br>       signal handler vary across systems (and POSIX.1 explicitly permits<br>       this variation); <b>do not use it for this purpose.</b><br><br>       POSIX.1 solved the portability mess by specifying sigaction(2), which<br>       provides explicit control of the semantics when a signal handler is<br>       invoked; use that interface instead of <b>signal</b>().<br><br>       In the original UNIX systems, when a handler that was established<br>       using <b>signal</b>() was invoked by the delivery of a signal, the<br>       disposition of the signal would be reset to <b>SIG_DFL</b>, and the system<br>       did not block delivery of further instances of the signal.  This is<br>       equivalent to calling sigaction(2) with the following flags:<br><br>           sa.sa_flags = SA_RESETHAND | SA_NODEFER;<br><br>       System V also provides these semantics for <b>signal</b>().  This was bad<br>       because the signal might be delivered again before the handler had a<br>       chance to reestablish itself.  Furthermore, rapid deliveries of the<br>       same signal could result in recursive invocations of the handler.<br><br>       BSD improved on this situation, but unfortunately also changed the<br>       semantics of the existing <b>signal</b>() interface while doing so.  On BSD,<br>       when a signal handler is invoked, the signal disposition is not<br>       reset, and further instances of the signal are blocked from being<br>       delivered while the handler is executing.  Furthermore, certain<br>       blocking system calls are automatically restarted if interrupted by a<br>       signal handler (see signal(7)).  The BSD semantics are equivalent to<br>       calling sigaction(2) with the following flags:<br><br>           sa.sa_flags = SA_RESTART;<br><br>       The situation on Linux is as follows:<br><br>       * The kernel's <b>signal</b>() system call provides System V semantics.<br><br>       * By default, in glibc 2 and later, the <b>signal</b>() wrapper function<br>         does not invoke the kernel system call.  Instead, it calls<br>         sigaction(2) using flags that supply BSD semantics.  This default<br>         behavior is provided as long as the <b>_BSD_SOURCE </b>feature test macro<br>         is defined.  By default, <b>_BSD_SOURCE </b>is defined; it is also<br>         implicitly defined if one defines <b>_GNU_SOURCE</b>, and can of course be<br>         explicitly defined.<br><br>       * On glibc 2 and later, if the <b>_BSD_SOURCE </b>feature test macro is not<br>         defined, then <b>signal</b>() provides System V semantics.  (The default<br>         implicit definition of <b>_BSD_SOURCE </b>is not provided if one invokes<br>         gcc(1) in one of its standard modes (<i>-std=xxx</i> or <i>-ansi</i>) or defines<br>         various other feature test macros such as <b>_POSIX_SOURCE</b>,<br>         <b>_XOPEN_SOURCE</b>, or <b>_SVID_SOURCE</b>; see feature_test_macros(7).)<br></pre><br><h2>SEE ALSO  </h2><pre><br>       kill(1), alarm(2), kill(2), killpg(2), pause(2), sigaction(2),<br>       signalfd(2), sigpending(2), sigprocmask(2), sigsuspend(2),<br>       bsd_signal(3), raise(3), siginterrupt(3), sigqueue(3), sigsetops(3),<br>       sigvec(3), sysv_signal(3), signal(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-08-08                        SIGNAL(2)</span><br></pre><br>"}