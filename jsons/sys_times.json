{"Man page": "<pre><br><span class=\"headline\">TIMES(2)                  Linux Programmer's Manual                 TIMES(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       times - get process times<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/times.h&gt;</b><br><br>       <b>clock_t times(struct tms *</b><i>buf</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>times</b>() stores the current process times in the <i>struct tms</i> that <i>buf</i><br>       points to.  The <i>struct tms</i> is as defined in <i>&lt;sys/times.h&gt;</i>:<br><br>           struct tms {<br>               clock_t tms_utime;  /* user time */<br>               clock_t tms_stime;  /* system time */<br>               clock_t tms_cutime; /* user time of children */<br>               clock_t tms_cstime; /* system time of children */<br>           };<br><br>       The <i>tms_utime</i> field contains the CPU time spent executing<br>       instructions of the calling process.  The <i>tms_stime</i> field contains<br>       the CPU time spent in the system while executing tasks on behalf of<br>       the calling process.  The <i>tms_cutime</i> field contains the sum of the<br>       <i>tms_utime</i> and <i>tms_cutime</i> values for all waited-for terminated<br>       children.  The <i>tms_cstime</i> field contains the sum of the <i>tms_stime</i> and<br>       <i>tms_cstime</i> values for all waited-for terminated children.<br><br>       Times for terminated children (and their descendants) are added in at<br>       the moment wait(2) or waitpid(2) returns their process ID.  In<br>       particular, times of grandchildren that the children did not wait for<br>       are never seen.<br><br>       All times reported are in clock ticks.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       <b>times</b>() returns the number of clock ticks that have elapsed since an<br>       arbitrary point in the past.  The return value may overflow the<br>       possible range of type <i>clock_t</i>.  On error, <i>(clock_t) -1</i> is returned,<br>       and <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EFAULT </b><i>tms</i> points outside the process's address space.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.<br></pre><br><h2>NOTES  </h2><pre><br>       The number of clock ticks per second can be obtained using:<br><br>           sysconf(_SC_CLK_TCK);<br><br>       In POSIX.1-1996 the symbol <b>CLK_TCK </b>(defined in <i>&lt;time.h&gt;</i>) is mentioned<br>       as obsolescent.  It is obsolete now.<br><br>       In Linux kernel versions before 2.6.9, if the disposition of <b>SIGCHLD</b><br>       is set to <b>SIG_IGN</b>, then the times of terminated children are<br>       automatically included in the <i>tms_cstime</i> and <i>tms_cutime</i> fields,<br>       although POSIX.1-2001 says that this should happen only if the<br>       calling process wait(2)s on its children.  This nonconformance is<br>       rectified in Linux 2.6.9 and later.<br><br>       On Linux, the <i>buf</i> argument can be specified as NULL, with the result<br>       that <b>times</b>() just returns a function result.  However, POSIX does not<br>       specify this behavior, and most other UNIX implementations require a<br>       non-NULL value for <i>buf</i>.<br><br>       Note that clock(3) also returns a value of type <i>clock_t</i>, but this<br>       value is measured in units of <b>CLOCKS_PER_SEC</b>, not the clock ticks<br>       used by <b>times</b>().<br><br>       On Linux, the \"arbitrary point in the past\" from which the return<br>       value of <b>times</b>() is measured has varied across kernel versions.  On<br>       Linux 2.4 and earlier this point is the moment the system was booted.<br>       Since Linux 2.6, this point is <i>(2^32/HZ) - 300</i> (i.e., about 429<br>       million) seconds before system boot time.  This variability across<br>       kernel versions (and across UNIX implementations), combined with the<br>       fact that the returned value may overflow the range of <i>clock_t</i>, means<br>       that a portable application would be wise to avoid using this value.<br>       To measure changes in elapsed time, use clock_gettime(2) instead.<br><br>   <b>Historical</b><br>       SVr1-3 returns <i>long</i> and the struct members are of type <i>time_t</i><br>       although they store clock ticks, not seconds since the Epoch.  V7<br>       used <i>long</i> for the struct members, because it had no type <i>time_t</i> yet.<br></pre><br><h2>BUGS  </h2><pre><br>       A limitation of the Linux system call conventions on some<br>       architectures (notably i386) means that on Linux 2.6 there is a small<br>       time window (41 seconds) soon after boot when <b>times</b>() can return -1,<br>       falsely indicating that an error occurred.  The same problem can<br>       occur when the return value wraps past the maximum value that can be<br>       stored in <b>clock_t</b>.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       time(1), getrusage(2), wait(2), clock(3), sysconf(3), time(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-08-08                         TIMES(2)</span><br></pre><br>"}