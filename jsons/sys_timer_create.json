{"Man page": "<pre><br><span class=\"headline\">TIMER_CREATE(2)           Linux Programmer's Manual          TIMER_CREATE(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       timer_create - create a POSIX per-process timer<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;signal.h&gt;</b><br>       <b>#include &lt;time.h&gt;</b><br><br>       <b>int timer_create(clockid_t </b><i>clockid</i><b>, struct sigevent *</b><i>sevp</i><b>,</b><br>                        <b>timer_t *</b><i>timerid</i><b>);</b><br><br>       Link with <i>-lrt</i>.<br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>timer_create</b>(): _POSIX_C_SOURCE &gt;= 199309L<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>timer_create</b>() creates a new per-process interval timer.  The ID of<br>       the new timer is returned in the buffer pointed to by <i>timerid</i>, which<br>       must be a non-null pointer.  This ID is unique within the process,<br>       until the timer is deleted.  The new timer is initially disarmed.<br><br>       The <i>clockid</i> argument specifies the clock that the new timer uses to<br>       measure time.  It can be specified as one of the following values:<br><br>       <b>CLOCK_REALTIME</b><br>              A settable system-wide real-time clock.<br><br>       <b>CLOCK_MONOTONIC</b><br>              A nonsettable monotonically increasing clock that measures<br>              time from some unspecified point in the past that does not<br>              change after system startup.<br><br>       <b>CLOCK_PROCESS_CPUTIME_ID </b>(since Linux 2.6.12)<br>              A clock that measures (user and system) CPU time consumed by<br>              (all of the threads in) the calling process.<br><br>       <b>CLOCK_THREAD_CPUTIME_ID </b>(since Linux 2.6.12)<br>              A clock that measures (user and system) CPU time consumed by<br>              the calling thread.<br><br>       As well as the above values, <i>clockid</i> can be specified as the <i>clockid</i><br>       returned by a call to clock_getcpuclockid(3) or<br>       pthread_getcpuclockid(3).<br><br>       The <i>sevp</i> argument points to a <i>sigevent</i> structure that specifies how<br>       the caller should be notified when the timer expires.  For the<br>       definition and general details of this structure, see sigevent(7).<br><br>       The <i>sevp.sigev_notify</i> field can have the following values:<br><br>       <b>SIGEV_NONE</b><br>              Don't asynchronously notify when the timer expires.  Progress<br>              of the timer can be monitored using timer_gettime(2).<br><br>       <b>SIGEV_SIGNAL</b><br>              Upon timer expiration, generate the signal <i>sigev_signo</i> for the<br>              process.  See sigevent(7) for general details.  The <i>si_code</i><br>              field of the <i>siginfo_t</i> structure will be set to <b>SI_TIMER</b>.  At<br>              any point in time, at most one signal is queued to the process<br>              for a given timer; see timer_getoverrun(2) for more details.<br><br>       <b>SIGEV_THREAD</b><br>              Upon timer expiration, invoke <i>sigev_notify_function</i> as if it<br>              were the start function of a new thread.  See sigevent(7) for<br>              details.<br><br>       <b>SIGEV_THREAD_ID </b>(Linux-specific)<br>              As for <b>SIGEV_SIGNAL</b>, but the signal is targeted at the thread<br>              whose ID is given in <i>sigev_notify_thread_id</i>, which must be a<br>              thread in the same process as the caller.  The<br>              <i>sigev_notify_thread_id</i> field specifies a kernel thread ID,<br>              that is, the value returned by clone(2) or gettid(2).  This<br>              flag is intended only for use by threading libraries.<br><br>       Specifying <i>sevp</i> as NULL is equivalent to specifying a pointer to a<br>       <i>sigevent</i> structure in which <i>sigev_notify</i> is <b>SIGEV_SIGNAL</b>, <i>sigev_signo</i><br>       is <b>SIGALRM</b>, and <i>sigev_value.sival_int</i> is the timer ID.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>timer_create</b>() returns 0, and the ID of the new timer is<br>       placed in <i>*timerid</i>.  On failure, -1 is returned, and <i>errno</i> is set to<br>       indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EAGAIN </b>Temporary error during kernel allocation of timer structures.<br><br>       <b>EINVAL </b>Clock ID, <i>sigev_notify</i>, <i>sigev_signo</i>, or <i>sigev_notify_thread_id</i><br>              is invalid.<br><br>       <b>ENOMEM </b>Could not allocate memory.<br></pre><br><h2>VERSIONS  </h2><pre><br>       This system call is available since Linux 2.6.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008.<br></pre><br><h2>NOTES  </h2><pre><br>       A program may create multiple interval timers using <b>timer_create</b>().<br><br>       Timers are not inherited by the child of a fork(2), and are disarmed<br>       and deleted during an execve(2).<br><br>       The kernel preallocates a \"queued real-time signal\" for each timer<br>       created using <b>timer_create</b>().  Consequently, the number of timers is<br>       limited by the <b>RLIMIT_SIGPENDING </b>resource limit (see setrlimit(2)).<br><br>       The timers created by <b>timer_create</b>() are commonly known as \"POSIX<br>       (interval) timers\".  The POSIX timers API consists of the following<br>       interfaces:<br><br>       *  <b>timer_create</b>(): Create a timer.<br><br>       *  timer_settime(2): Arm (start) or disarm (stop) a timer.<br><br>       *  timer_gettime(2): Fetch the time remaining until the next<br>          expiration of a timer, along with the interval setting of the<br>          timer.<br><br>       *  timer_getoverrun(2): Return the overrun count for the last timer<br>          expiration.<br><br>       *  timer_delete(2): Disarm and delete a timer.<br><br>       Since Linux 3.10, the <i>/proc/[pid]/timers</i> file can be used to list the<br>       POSIX timers for the process with PID <i>pid</i>.  See proc(5) for further<br>       information.<br><br>   <b>C library/kernel differences</b><br>       Part of the implementation of the POSIX timers API is provided by<br>       glibc.  In particular:<br><br>       *  Much of the functionality for <b>SIGEV_THREAD </b>is implemented within<br>          glibc, rather than the kernel.  (This is necessarily so, since the<br>          thread involved in handling the notification is one that must be<br>          managed by the C library POSIX threads implementation.)  Although<br>          the notification delivered to the process is via a thread,<br>          internally the NPTL implementation uses a <i>sigev_notify</i> value of<br>          <b>SIGEV_THREAD_ID </b>along with a real-time signal that is reserved by<br>          the implementation (see nptl(7)).<br><br>       *  The implementation of the default case where <i>evp</i> is NULL is<br>          handled inside glibc, which invokes the underlying system call<br>          with a suitably populated <i>sigevent</i> structure.<br><br>       *  The timer IDs presented at user level are maintained by glibc,<br>          which maps these IDs to the timer IDs employed by the kernel.<br><br>       The POSIX timers system calls first appeared in Linux 2.6.  Prior to<br>       this, glibc provided an incomplete user-space implementation<br>       (<b>CLOCK_REALTIME </b>timers only) using POSIX threads, and in glibc<br>       versions before 2.17, the implementation falls back to this technique<br>       on systems running pre-2.6 Linux kernels.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The program below takes two arguments: a sleep period in seconds, and<br>       a timer frequency in nanoseconds.  The program establishes a handler<br>       for the signal it uses for the timer, blocks that signal, creates and<br>       arms a timer that expires with the given frequency, sleeps for the<br>       specified number of seconds, and then unblocks the timer signal.<br>       Assuming that the timer expired at least once while the program<br>       slept, the signal handler will be invoked, and the handler displays<br>       some information about the timer notification.  The program<br>       terminates after one invocation of the signal handler.<br><br>       In the following example run, the program sleeps for 1 second, after<br>       creating a timer that has a frequency of 100 nanoseconds.  By the<br>       time the signal is unblocked and delivered, there have been around<br>       ten million overruns.<br><br>           $ <b>./a.out 1 100</b><br>           Establishing handler for signal 34<br>           Blocking signal 34<br>           timer ID is 0x804c008<br>           Sleeping for 1 seconds<br>           Unblocking signal 34<br>           Caught signal 34<br>               sival_ptr = 0xbfb174f4;     *sival_ptr = 0x804c008<br>               overrun count = 10004886<br><br>   <b>Program source</b><br><br>       #include &lt;stdlib.h&gt;<br>       #include &lt;unistd.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;signal.h&gt;<br>       #include &lt;time.h&gt;<br><br>       #define CLOCKID CLOCK_REALTIME<br>       #define SIG SIGRTMIN<br><br>       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\<br>                               } while (0)<br><br>       static void<br>       print_siginfo(siginfo_t *si)<br>       {<br>           timer_t *tidp;<br>           int or;<br><br>           tidp = si-&gt;si_value.sival_ptr;<br><br>           printf(\"    sival_ptr = %p; \", si-&gt;si_value.sival_ptr);<br>           printf(\"    *sival_ptr = 0x%lx\\n\", (long) *tidp);<br><br>           or = timer_getoverrun(*tidp);<br>           if (or == -1)<br>               errExit(\"timer_getoverrun\");<br>           else<br>               printf(\"    overrun count = %d\\n\", or);<br>       }<br><br>       static void<br>       handler(int sig, siginfo_t *si, void *uc)<br>       {<br>           /* Note: calling printf() from a signal handler is not<br>              strictly correct, since printf() is not async-signal-safe;<br>              see signal(7) */<br><br>           printf(\"Caught signal %d\\n\", sig);<br>           print_siginfo(si);<br>           signal(sig, SIG_IGN);<br>       }<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           timer_t timerid;<br>           struct sigevent sev;<br>           struct itimerspec its;<br>           long long freq_nanosecs;<br>           sigset_t mask;<br>           struct sigaction sa;<br><br>           if (argc != 3) {<br>               fprintf(stderr, \"Usage: %s &lt;sleep-secs&gt; &lt;freq-nanosecs&gt;\\n\",<br>                       argv[0]);<br>               exit(EXIT_FAILURE);<br>           }<br><br>           /* Establish handler for timer signal */<br><br>           printf(\"Establishing handler for signal %d\\n\", SIG);<br>           sa.sa_flags = SA_SIGINFO;<br>           sa.sa_sigaction = handler;<br>           sigemptyset(&amp;sa.sa_mask);<br>           if (sigaction(SIG, &amp;sa, NULL) == -1)<br>               errExit(\"sigaction\");<br><br>           /* Block timer signal temporarily */<br><br>           printf(\"Blocking signal %d\\n\", SIG);<br>           sigemptyset(&amp;mask);<br>           sigaddset(&amp;mask, SIG);<br>           if (sigprocmask(SIG_SETMASK, &amp;mask, NULL) == -1)<br>               errExit(\"sigprocmask\");<br><br>           /* Create the timer */<br><br>           sev.sigev_notify = SIGEV_SIGNAL;<br>           sev.sigev_signo = SIG;<br>           sev.sigev_value.sival_ptr = &amp;timerid;<br>           if (timer_create(CLOCKID, &amp;sev, &amp;timerid) == -1)<br>               errExit(\"timer_create\");<br><br>           printf(\"timer ID is 0x%lx\\n\", (long) timerid);<br><br>           /* Start the timer */<br><br>           freq_nanosecs = atoll(argv[2]);<br>           its.it_value.tv_sec = freq_nanosecs / 1000000000;<br>           its.it_value.tv_nsec = freq_nanosecs % 1000000000;<br>           its.it_interval.tv_sec = its.it_value.tv_sec;<br>           its.it_interval.tv_nsec = its.it_value.tv_nsec;<br><br>           if (timer_settime(timerid, 0, &amp;its, NULL) == -1)<br>                errExit(\"timer_settime\");<br><br>           /* Sleep for a while; meanwhile, the timer may expire<br>              multiple times */<br><br>           printf(\"Sleeping for %d seconds\\n\", atoi(argv[1]));<br>           sleep(atoi(argv[1]));<br><br>           /* Unlock the timer signal, so that timer notification<br>              can be delivered */<br><br>           printf(\"Unblocking signal %d\\n\", SIG);<br>           if (sigprocmask(SIG_UNBLOCK, &amp;mask, NULL) == -1)<br>               errExit(\"sigprocmask\");<br><br>           exit(EXIT_SUCCESS);<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       clock_gettime(2), setitimer(2), timer_delete(2), timer_getoverrun(2),<br>       timer_settime(2), timerfd_create(2), clock_getcpuclockid(3),<br>       pthread_getcpuclockid(3), pthreads(7), sigevent(7), signal(7),<br>       time(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                  TIMER_CREATE(2)</span><br></pre><br>"}