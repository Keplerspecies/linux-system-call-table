{"Man page": "<pre><br><span class=\"headline\">LINK(2)                   Linux Programmer's Manual                  LINK(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       link, linkat - make a new name for a file<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>int link(const char *</b><i>oldpath</i><b>, const char *</b><i>newpath</i><b>);</b><br><br>       <b>#include &lt;fcntl.h&gt;           </b>/* Definition of AT_* constants */<br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>int linkat(int </b><i>olddirfd</i><b>, const char *</b><i>oldpath</i><b>,</b><br>                  <b>int </b><i>newdirfd</i><b>, const char *</b><i>newpath</i><b>, int </b><i>flags</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>linkat</b>():<br>           Since glibc 2.10:<br>               _XOPEN_SOURCE &gt;= 700 || _POSIX_C_SOURCE &gt;= 200809L<br>           Before glibc 2.10:<br>               _ATFILE_SOURCE<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>link</b>() creates a new link (also known as a hard link) to an existing<br>       file.<br><br>       If <i>newpath</i> exists, it will <i>not</i> be overwritten.<br><br>       This new name may be used exactly as the old one for any operation;<br>       both names refer to the same file (and so have the same permissions<br>       and ownership) and it is impossible to tell which name was the<br>       \"original\".<br><br>   <b>linkat()</b><br>       The <b>linkat</b>() system call operates in exactly the same way as <b>link</b>(),<br>       except for the differences described here.<br><br>       If the pathname given in <i>oldpath</i> is relative, then it is interpreted<br>       relative to the directory referred to by the file descriptor <i>olddirfd</i><br>       (rather than relative to the current working directory of the calling<br>       process, as is done by <b>link</b>() for a relative pathname).<br><br>       If <i>oldpath</i> is relative and <i>olddirfd</i> is the special value <b>AT_FDCWD</b>,<br>       then <i>oldpath</i> is interpreted relative to the current working directory<br>       of the calling process (like <b>link</b>()).<br><br>       If <i>oldpath</i> is absolute, then <i>olddirfd</i> is ignored.<br><br>       The interpretation of <i>newpath</i> is as for <i>oldpath</i>, except that a<br>       relative pathname is interpreted relative to the directory referred<br>       to by the file descriptor <i>newdirfd</i>.<br><br>       The following values can be bitwise ORed in <i>flags</i>:<br><br>       <b>AT_EMPTY_PATH </b>(since Linux 2.6.39)<br>              If <i>oldpath</i> is an empty string, create a link to the file<br>              referenced by <i>olddirfd</i> (which may have been obtained using the<br>              open(2) <b>O_PATH </b>flag).  In this case, <i>olddirfd</i> can refer to any<br>              type of file, not just a directory.  This will generally not<br>              work if the file has a link count of zero (files created with<br>              <b>O_TMPFILE </b>and without <b>O_EXCL </b>are an exception).  The caller<br>              must have the <b>CAP_DAC_READ_SEARCH </b>capability in order to use<br>              this flag.  This flag is Linux-specific; define <b>_GNU_SOURCE </b>to<br>              obtain its definition.<br><br>       <b>AT_SYMLINK_FOLLOW </b>(since Linux 2.6.18)<br>              By default, <b>linkat</b>(), does not dereference <i>oldpath</i> if it is a<br>              symbolic link (like <b>link</b>()).  The flag <b>AT_SYMLINK_FOLLOW </b>can<br>              be specified in <i>flags</i> to cause <i>oldpath</i> to be dereferenced if<br>              it is a symbolic link.  If procfs is mounted, this can be used<br>              as an alternative to <b>AT_EMPTY_PATH</b>, like this:<br><br>                  linkat(AT_FDCWD, \"/proc/self/fd/&lt;fd&gt;\", newdirfd,<br>                         newname, AT_SYMLINK_FOLLOW);<br><br>       Before kernel 2.6.18, the <i>flags</i> argument was unused, and had to be<br>       specified as 0.<br><br>       See openat(2) for an explanation of the need for <b>linkat</b>().<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, zero is returned.  On error, -1 is returned, and <i>errno</i> is<br>       set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EACCES </b>Write access to the directory containing <i>newpath</i> is denied, or<br>              search permission is denied for one of the directories in the<br>              path prefix of <i>oldpath</i> or <i>newpath</i>.  (See also<br>              path_resolution(7).)<br><br>       <b>EDQUOT </b>The user's quota of disk blocks on the filesystem has been<br>              exhausted.<br><br>       <b>EEXIST </b><i>newpath</i> already exists.<br><br>       <b>EFAULT </b><i>oldpath</i> or <i>newpath</i> points outside your accessible address<br>              space.<br><br>       <b>EIO    </b>An I/O error occurred.<br><br>       <b>ELOOP  </b>Too many symbolic links were encountered in resolving <i>oldpath</i><br>              or <i>newpath</i>.<br><br>       <b>EMLINK </b>The file referred to by <i>oldpath</i> already has the maximum number<br>              of links to it.<br><br>       <b>ENAMETOOLONG</b><br>              <i>oldpath</i> or <i>newpath</i> was too long.<br><br>       <b>ENOENT </b>A directory component in <i>oldpath</i> or <i>newpath</i> does not exist or<br>              is a dangling symbolic link.<br><br>       <b>ENOMEM </b>Insufficient kernel memory was available.<br><br>       <b>ENOSPC </b>The device containing the file has no room for the new<br>              directory entry.<br><br>       <b>ENOTDIR</b><br>              A component used as a directory in <i>oldpath</i> or <i>newpath</i> is not,<br>              in fact, a directory.<br><br>       <b>EPERM  </b><i>oldpath</i> is a directory.<br><br>       <b>EPERM  </b>The filesystem containing <i>oldpath</i> and <i>newpath</i> does not support<br>              the creation of hard links.<br><br>       <b>EPERM </b>(since Linux 3.6)<br>              The caller does not have permission to create a hard link to<br>              this file (see the description of<br>              <i>/proc/sys/fs/protected_hardlinks</i> in proc(5)).<br><br>       <b>EROFS  </b>The file is on a read-only filesystem.<br><br>       <b>EXDEV  </b><i>oldpath</i> and <i>newpath</i> are not on the same mounted filesystem.<br>              (Linux permits a filesystem to be mounted at multiple points,<br>              but <b>link</b>() does not work across different mount points, even<br>              if the same filesystem is mounted on both.)<br><br>       The following additional errors can occur for <b>linkat</b>():<br><br>       <b>EBADF  </b><i>olddirfd</i> or <i>newdirfd</i> is not a valid file descriptor.<br><br>       <b>EINVAL </b>An invalid flag value was specified in <i>flags</i>.<br><br>       <b>ENOENT AT_EMPTY_PATH </b>was specified in <i>flags</i>, but the caller did not<br>              have the <b>CAP_DAC_READ_SEARCH </b>capability.<br><br>       <b>ENOENT </b>An attempt was made to link to the <i>/proc/self/fd/NN</i> file<br>              corresponding to a file descriptor created with<br><br>                  open(path, O_TMPFILE | O_EXCL, mode);<br><br>              See open(2).<br><br>       <b>ENOENT </b><i>oldpath</i> is a relative pathname and <i>olddirfd</i> refers to a<br>              directory that has been deleted, or <i>newpath</i> is a relative<br>              pathname and <i>newdirfd</i> refers to a directory that has been<br>              deleted.<br><br>       <b>ENOTDIR</b><br>              <i>oldpath</i> is relative and <i>olddirfd</i> is a file descriptor<br>              referring to a file other than a directory; or similar for<br>              <i>newpath</i> and <i>newdirfd</i><br><br>       <b>EPERM  AT_EMPTY_PATH </b>was specified in <i>flags</i>, <i>oldpath</i> is an empty<br>              string, and <i>olddirfd</i> refers to a directory.<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>linkat</b>() was added to Linux in kernel 2.6.16; library support was<br>       added to glibc in version 2.4.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>link</b>(): SVr4, 4.3BSD, POSIX.1-2001 (but see NOTES), POSIX.1-2008.<br><br>       <b>linkat</b>(): POSIX.1-2008.<br></pre><br><h2>NOTES  </h2><pre><br>       Hard links, as created by <b>link</b>(), cannot span filesystems.  Use<br>       symlink(2) if this is required.<br><br>       POSIX.1-2001 says that <b>link</b>() should dereference <i>oldpath</i> if it is a<br>       symbolic link.  However, since kernel 2.0, Linux does not do so: if<br>       <i>oldpath</i> is a symbolic link, then <i>newpath</i> is created as a (hard) link<br>       to the same symbolic link file (i.e., <i>newpath</i> becomes a symbolic link<br>       to the same file that <i>oldpath</i> refers to).  Some other implementations<br>       behave in the same manner as Linux.  POSIX.1-2008 changes the<br>       specification of <b>link</b>(), making it implementation-dependent whether<br>       or not <i>oldpath</i> is dereferenced if it is a symbolic link.  For precise<br>       control over the treatment of symbolic links when creating a link,<br>       use linkat(2).<br><br>   <b>Glibc notes</b><br>       On older kernels where <b>linkat</b>() is unavailable, the glibc wrapper<br>       function falls back to the use of <b>link</b>(), unless the<br>       <b>AT_SYMLINK_FOLLOW </b>is specified.  When <i>oldpath</i> and <i>newpath</i> are<br>       relative pathnames, glibc constructs pathnames based on the symbolic<br>       links in <i>/proc/self/fd</i> that correspond to the <i>olddirfd</i> and <i>newdirfd</i><br>       arguments.<br></pre><br><h2>BUGS  </h2><pre><br>       On NFS filesystems, the return code may be wrong in case the NFS<br>       server performs the link creation and dies before it can say so.  Use<br>       stat(2) to find out if the link got created.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       ln(1), open(2), rename(2), stat(2), symlink(2), unlink(2),<br>       path_resolution(7), symlink(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2014-08-19                          LINK(2)</span><br></pre><br>"}