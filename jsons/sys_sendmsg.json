{"Man page": "<pre><br><span class=\"headline\">SEND(2)                   Linux Programmer's Manual                  SEND(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       send, sendto, sendmsg - send a message on a socket<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/types.h&gt;</b><br>       <b>#include &lt;sys/socket.h&gt;</b><br><br>       <b>ssize_t send(int </b><i>sockfd</i><b>, const void *</b><i>buf</i><b>, size_t </b><i>len</i><b>, int </b><i>flags</i><b>);</b><br><br>       <b>ssize_t sendto(int </b><i>sockfd</i><b>, const void *</b><i>buf</i><b>, size_t </b><i>len</i><b>, int </b><i>flags</i><b>,</b><br>                      <b>const struct sockaddr *</b><i>dest_addr</i><b>, socklen_t </b><i>addrlen</i><b>);</b><br><br>       <b>ssize_t sendmsg(int </b><i>sockfd</i><b>, const struct msghdr *</b><i>msg</i><b>, int </b><i>flags</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The system calls <b>send</b>(), <b>sendto</b>(), and <b>sendmsg</b>() are used to transmit<br>       a message to another socket.<br><br>       The <b>send</b>() call may be used only when the socket is in a <i>connected</i><br>       state (so that the intended recipient is known).  The only difference<br>       between <b>send</b>() and write(2) is the presence of <i>flags</i>.  With a zero<br>       <i>flags</i> argument, <b>send</b>() is equivalent to write(2).  Also, the<br>       following call<br><br>           send(sockfd, buf, len, flags);<br><br>       is equivalent to<br><br>           sendto(sockfd, buf, len, flags, NULL, 0);<br><br>       The argument <i>sockfd</i> is the file descriptor of the sending socket.<br><br>       If <b>sendto</b>() is used on a connection-mode (<b>SOCK_STREAM</b>,<br>       <b>SOCK_SEQPACKET</b>) socket, the arguments <i>dest_addr</i> and <i>addrlen</i> are<br>       ignored (and the error <b>EISCONN </b>may be returned when they are not NULL<br>       and 0), and the error <b>ENOTCONN </b>is returned when the socket was not<br>       actually connected.  Otherwise, the address of the target is given by<br>       <i>dest_addr</i> with <i>addrlen</i> specifying its size.  For <b>sendmsg</b>(), the<br>       address of the target is given by <i>msg.msg_name</i>, with <i>msg.msg_namelen</i><br>       specifying its size.<br><br>       For <b>send</b>() and <b>sendto</b>(), the message is found in <i>buf</i> and has length<br>       <i>len</i>.  For <b>sendmsg</b>(), the message is pointed to by the elements of the<br>       array <i>msg.msg_iov</i>.  The <b>sendmsg</b>() call also allows sending ancillary<br>       data (also known as control information).<br><br>       If the message is too long to pass atomically through the underlying<br>       protocol, the error <b>EMSGSIZE </b>is returned, and the message is not<br>       transmitted.<br><br>       No indication of failure to deliver is implicit in a <b>send</b>().  Locally<br>       detected errors are indicated by a return value of -1.<br><br>       When the message does not fit into the send buffer of the socket,<br>       <b>send</b>() normally blocks, unless the socket has been placed in<br>       nonblocking I/O mode.  In nonblocking mode it would fail with the<br>       error <b>EAGAIN </b>or <b>EWOULDBLOCK </b>in this case.  The select(2) call may be<br>       used to determine when it is possible to send more data.<br><br>   <b>The flags argument</b><br>       The <i>flags</i> argument is the bitwise OR of zero or more of the following<br>       flags.<br><br>       <b>MSG_CONFIRM </b>(since Linux 2.3.15)<br>              Tell the link layer that forward progress happened: you got a<br>              successful reply from the other side.  If the link layer<br>              doesn't get this it will regularly reprobe the neighbor (e.g.,<br>              via a unicast ARP).  Only valid on <b>SOCK_DGRAM </b>and <b>SOCK_RAW</b><br>              sockets and currently implemented only for IPv4 and IPv6.  See<br>              arp(7) for details.<br><br>       <b>MSG_DONTROUTE</b><br>              Don't use a gateway to send out the packet, send to hosts only<br>              on directly connected networks.  This is usually used only by<br>              diagnostic or routing programs.  This is defined only for<br>              protocol families that route; packet sockets don't.<br><br>       <b>MSG_DONTWAIT </b>(since Linux 2.2)<br>              Enables nonblocking operation; if the operation would block,<br>              <b>EAGAIN </b>or <b>EWOULDBLOCK </b>is returned.  This provides similar<br>              behavior to setting the <b>O_NONBLOCK </b>flag (via the fcntl(2)<br>              <b>F_SETFL </b>operation), but differs in that <b>MSG_DONTWAIT </b>is a per-<br>              call option, whereas <b>O_NONBLOCK </b>is a setting on the open file<br>              description (see open(2)), which will affect all threads in<br>              the calling process and as well as other processes that hold<br>              file descriptors referring to the same open file description.<br><br>       <b>MSG_EOR </b>(since Linux 2.2)<br>              Terminates a record (when this notion is supported, as for<br>              sockets of type <b>SOCK_SEQPACKET</b>).<br><br>       <b>MSG_MORE </b>(since Linux 2.4.4)<br>              The caller has more data to send.  This flag is used with TCP<br>              sockets to obtain the same effect as the <b>TCP_CORK </b>socket<br>              option (see tcp(7)), with the difference that this flag can be<br>              set on a per-call basis.<br><br>              Since Linux 2.6, this flag is also supported for UDP sockets,<br>              and informs the kernel to package all of the data sent in<br>              calls with this flag set into a single datagram which is<br>              transmitted only when a call is performed that does not<br>              specify this flag.  (See also the <b>UDP_CORK </b>socket option<br>              described in udp(7).)<br><br>       <b>MSG_NOSIGNAL </b>(since Linux 2.2)<br>              Don't generate a <b>SIGPIPE </b>signal if the peer on a stream-<br>              oriented socket has closed the connection.  The <b>EPIPE </b>error is<br>              still returned.  This provides similar behavior to using<br>              sigaction(2) to ignore <b>SIGPIPE</b>, but, whereas <b>MSG_NOSIGNAL </b>is a<br>              per-call feature, ignoring <b>SIGPIPE </b>sets a process attribute<br>              that affects all threads in the process.<br><br>       <b>MSG_OOB</b><br>              Sends <i>out-of-band</i> data on sockets that support this notion<br>              (e.g., of type <b>SOCK_STREAM</b>); the underlying protocol must also<br>              support <i>out-of-band</i> data.<br><br>   <b>sendmsg()</b><br>       The definition of the <i>msghdr</i> structure employed by <b>sendmsg</b>() is as<br>       follows:<br><br>           struct msghdr {<br>               void         *msg_name;       /* optional address */<br>               socklen_t     msg_namelen;    /* size of address */<br>               struct iovec *msg_iov;        /* scatter/gather array */<br>               size_t        msg_iovlen;     /* # elements in msg_iov */<br>               void         *msg_control;    /* ancillary data, see below */<br>               size_t        msg_controllen; /* ancillary data buffer len */<br>               int           msg_flags;      /* flags (unused) */<br>           };<br><br>       The <i>msg_name</i> field is used on an unconnected socket to specify the<br>       target address for a datagram.  It points to a buffer containing the<br>       address; the <i>msg_namelen</i> field should be set to the size of the<br>       address.  For a connected socket, these fields should be specified as<br>       NULL and 0, respectively.<br><br>       The <i>msg_iov</i> and <i>msg_iovlen</i> fields specify scatter-gather locations,<br>       as for writev(2).<br><br>       You may send control information using the <i>msg_control</i> and<br>       <i>msg_controllen</i> members.  The maximum control buffer length the kernel<br>       can process is limited per socket by the value in<br>       <i>/proc/sys/net/core/optmem_max</i>; see socket(7).<br><br>       The <i>msg_flags</i> field is ignored.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, these calls return the number of bytes sent.  On error,<br>       -1 is returned, and <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       These are some standard errors generated by the socket layer.<br>       Additional errors may be generated and returned from the underlying<br>       protocol modules; see their respective manual pages.<br><br>       <b>EACCES </b>(For UNIX domain sockets, which are identified by pathname)<br>              Write permission is denied on the destination socket file, or<br>              search permission is denied for one of the directories the<br>              path prefix.  (See path_resolution(7).)<br><br>              (For UDP sockets) An attempt was made to send to a<br>              network/broadcast address as though it was a unicast address.<br><br>       <b>EAGAIN </b>or <b>EWOULDBLOCK</b><br>              The socket is marked nonblocking and the requested operation<br>              would block.  POSIX.1-2001 allows either error to be returned<br>              for this case, and does not require these constants to have<br>              the same value, so a portable application should check for<br>              both possibilities.<br><br>       <b>EAGAIN </b>(Internet domain datagram sockets) The socket referred to by<br>              <i>sockfd</i> had not previously been bound to an address and, upon<br>              attempting to bind it to an ephemeral port, it was determined<br>              that all port numbers in the ephemeral port range are<br>              currently in use.  See the discussion of<br>              <i>/proc/sys/net/ipv4/ip_local_port_range</i> in ip(7).<br><br>       <b>EBADF  </b>An invalid descriptor was specified.<br><br>       <b>ECONNRESET</b><br>              Connection reset by peer.<br><br>       <b>EDESTADDRREQ</b><br>              The socket is not connection-mode, and no peer address is set.<br><br>       <b>EFAULT </b>An invalid user space address was specified for an argument.<br><br>       <b>EINTR  </b>A signal occurred before any data was transmitted; see<br>              signal(7).<br><br>       <b>EINVAL </b>Invalid argument passed.<br><br>       <b>EISCONN</b><br>              The connection-mode socket was connected already but a<br>              recipient was specified.  (Now either this error is returned,<br>              or the recipient specification is ignored.)<br><br>       <b>EMSGSIZE</b><br>              The socket type requires that message be sent atomically, and<br>              the size of the message to be sent made this impossible.<br><br>       <b>ENOBUFS</b><br>              The output queue for a network interface was full.  This<br>              generally indicates that the interface has stopped sending,<br>              but may be caused by transient congestion.  (Normally, this<br>              does not occur in Linux.  Packets are just silently dropped<br>              when a device queue overflows.)<br><br>       <b>ENOMEM </b>No memory available.<br><br>       <b>ENOTCONN</b><br>              The socket is not connected, and no target has been given.<br><br>       <b>ENOTSOCK</b><br>              The argument <i>sockfd</i> is not a socket.<br><br>       <b>EOPNOTSUPP</b><br>              Some bit in the <i>flags</i> argument is inappropriate for the socket<br>              type.<br><br>       <b>EPIPE  </b>The local end has been shut down on a connection oriented<br>              socket.  In this case, the process will also receive a <b>SIGPIPE</b><br>              unless <b>MSG_NOSIGNAL </b>is set.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       4.4BSD, SVr4, POSIX.1-2001.  These interfaces first appeared in<br>       4.2BSD.<br><br>       POSIX.1-2001 describes only the <b>MSG_OOB </b>and <b>MSG_EOR </b>flags.<br>       POSIX.1-2008 adds a specification of <b>MSG_NOSIGNAL</b>.  The <b>MSG_CONFIRM</b><br>       flag is a Linux extension.<br></pre><br><h2>NOTES  </h2><pre><br>       According to POSIX.1-2001, the <i>msg_controllen</i> field of the <i>msghdr</i><br>       structure should be typed as <i>socklen_t</i>, but glibc currently types it<br>       as <i>size_t</i>.<br><br>       See sendmmsg(2) for information about a Linux-specific system call<br>       that can be used to transmit multiple datagrams in a single call.<br></pre><br><h2>BUGS  </h2><pre><br>       Linux may return <b>EPIPE </b>instead of <b>ENOTCONN</b>.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       An example of the use of <b>sendto</b>() is shown in getaddrinfo(3).<br></pre><br><h2>SEE ALSO  </h2><pre><br>       fcntl(2), getsockopt(2), recv(2), select(2), sendfile(2),<br>       sendmmsg(2), shutdown(2), socket(2), write(2), cmsg(3), ip(7),<br>       socket(7), tcp(7), udp(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                          SEND(2)</span><br></pre><br>"}