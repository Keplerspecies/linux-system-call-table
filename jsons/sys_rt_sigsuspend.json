{"Man page": "<pre><br><span class=\"headline\">SIGSUSPEND(2)             Linux Programmer's Manual            SIGSUSPEND(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       sigsuspend, rt_sigsuspend - wait for a signal<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;signal.h&gt;</b><br><br>       <b>int sigsuspend(const sigset_t *</b><i>mask</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>sigsuspend</b>(): _POSIX_C_SOURCE &gt;= 1 || _XOPEN_SOURCE || _POSIX_SOURCE<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>sigsuspend</b>() temporarily replaces the signal mask of the calling<br>       process with the mask given by <i>mask</i> and then suspends the process<br>       until delivery of a signal whose action is to invoke a signal handler<br>       or to terminate a process.<br><br>       If the signal terminates the process, then <b>sigsuspend</b>() does not<br>       return.  If the signal is caught, then <b>sigsuspend</b>() returns after the<br>       signal handler returns, and the signal mask is restored to the state<br>       before the call to <b>sigsuspend</b>().<br><br>       It is not possible to block <b>SIGKILL </b>or <b>SIGSTOP</b>; specifying these<br>       signals in <i>mask</i>, has no effect on the process's signal mask.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       <b>sigsuspend</b>() always returns -1, with <i>errno</i> set to indicate the error<br>       (normally, <b>EINTR</b>).<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EFAULT </b><i>mask</i> points to memory which is not a valid part of the process<br>              address space.<br><br>       <b>EINTR  </b>The call was interrupted by a signal.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008.<br></pre><br><h2>NOTES  </h2><pre><br>       Normally, <b>sigsuspend</b>() is used in conjunction with sigprocmask(2) in<br>       order to prevent delivery of a signal during the execution of a<br>       critical code section.  The caller first blocks the signals with<br>       sigprocmask(2).  When the critical code has completed, the caller<br>       then waits for the signals by calling <b>sigsuspend</b>() with the signal<br>       mask that was returned by sigprocmask(2) (in the <i>oldset</i> argument).<br><br>       See sigsetops(3) for details on manipulating signal sets.<br><br>   <b>C library/kernel differences</b><br>       The original Linux system call was named <b>sigsuspend</b>().  However, with<br>       the addition of real-time signals in Linux 2.2, the fixed-size,<br>       32-bit <i>sigset_t</i> type supported by that system call was no longer fit<br>       for purpose.  Consequently, a new system call, <b>rt_sigsuspend</b>(), was<br>       added to support an enlarged <i>sigset_t</i> type.  The new system call<br>       takes a second argument, <i>size_t sigsetsize</i>, which specifies the size<br>       in bytes of the signal set in <i>mask</i>.  This argument is currently<br>       required to have the value <i>sizeof(sigset_t)</i> (or the error <b>EINVAL</b><br>       results).  The glibc <b>sigsuspend</b>() wrapper function hides these<br>       details from us, transparently calling <b>rt_sigsuspend</b>() when the<br>       kernel provides it.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       kill(2), pause(2), sigaction(2), signal(2), sigprocmask(2),<br>       sigwaitinfo(2), sigsetops(3), sigwait(3), signal(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                    SIGSUSPEND(2)</span><br></pre><br>"}