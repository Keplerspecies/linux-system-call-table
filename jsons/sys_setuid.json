{"Man page": "<pre><br><span class=\"headline\">SETUID(2)                 Linux Programmer's Manual                SETUID(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       setuid - set user identity<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/types.h&gt;</b><br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>int setuid(uid_t </b><i>uid</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>setuid</b>() sets the effective user ID of the calling process.  If the<br>       effective UID of the caller is root (more precisely: if the caller<br>       has the <b>CAP_SETUID </b>capability), the real UID and saved set-user-ID<br>       are also set.<br><br>       Under Linux, <b>setuid</b>() is implemented like the POSIX version with the<br>       <b>_POSIX_SAVED_IDS </b>feature.  This allows a set-user-ID (other than<br>       root) program to drop all of its user privileges, do some un-<br>       privileged work, and then reengage the original effective user ID in<br>       a secure manner.<br><br>       If the user is root or the program is set-user-ID-root, special care<br>       must be taken.  The <b>setuid</b>() function checks the effective user ID of<br>       the caller and if it is the superuser, all process-related user ID's<br>       are set to <i>uid</i>.  After this has occurred, it is impossible for the<br>       program to regain root privileges.<br><br>       Thus, a set-user-ID-root program wishing to temporarily drop root<br>       privileges, assume the identity of an unprivileged user, and then<br>       regain root privileges afterward cannot use <b>setuid</b>().  You can<br>       accomplish this with seteuid(2).<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, zero is returned.  On error, -1 is returned, and <i>errno</i> is<br>       set appropriately.<br><br>       <i>Note</i>: there are cases where <b>setuid</b>() can fail even when the caller is<br>       UID 0; it is a grave security error to omit checking for a failure<br>       return from <b>setuid</b>().<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EAGAIN </b>The call would change the caller's real UID (i.e., <i>uid</i> does<br>              not match the caller's real UID), but there was a temporary<br>              failure allocating the necessary kernel data structures.<br><br>       <b>EAGAIN </b><i>uid</i> does not match the real user ID of the caller and this<br>              call would bring the number of processes belonging to the real<br>              user ID <i>uid</i> over the caller's <b>RLIMIT_NPROC </b>resource limit.<br>              Since Linux 3.1, this error case no longer occurs (but robust<br>              applications should check for this error); see the description<br>              of <b>EAGAIN </b>in execve(2).<br><br>       <b>EINVAL </b>The user ID specified in <i>uid</i> is not valid in this user<br>              namespace.<br><br>       <b>EPERM  </b>The user is not privileged (Linux: does not have the<br>              <b>CAP_SETUID </b>capability) and <i>uid</i> does not match the real UID or<br>              saved set-user-ID of the calling process.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008, SVr4.  Not quite compatible with the<br>       4.4BSD call, which sets all of the real, saved, and effective user<br>       IDs.<br></pre><br><h2>NOTES  </h2><pre><br>       Linux has the concept of the filesystem user ID, normally equal to<br>       the effective user ID.  The <b>setuid</b>() call also sets the filesystem<br>       user ID of the calling process.  See setfsuid(2).<br><br>       If <i>uid</i> is different from the old effective UID, the process will be<br>       forbidden from leaving core dumps.<br><br>       The original Linux <b>setuid</b>() system call supported only 16-bit user<br>       IDs.  Subsequently, Linux 2.4 added <b>setuid32</b>() supporting 32-bit IDs.<br>       The glibc <b>setuid</b>() wrapper function transparently deals with the<br>       variation across kernel versions.<br><br>   <b>C library/kernel differences</b><br>       At the kernel level, user IDs and group IDs are a per-thread<br>       attribute.  However, POSIX requires that all threads in a process<br>       share the same credentials.  The NPTL threading implementation<br>       handles the POSIX requirements by providing wrapper functions for the<br>       various system calls that change process UIDs and GIDs.  These<br>       wrapper functions (including the one for <b>setuid</b>()) employ a signal-<br>       based technique to ensure that when one thread changes credentials,<br>       all of the other threads in the process also change their<br>       credentials.  For details, see nptl(7).<br></pre><br><h2>SEE ALSO  </h2><pre><br>       getuid(2), seteuid(2), setfsuid(2), setreuid(2), capabilities(7),<br>       credentials(7), user_namespaces(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                        SETUID(2)</span><br></pre><br>"}