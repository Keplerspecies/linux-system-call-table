{"Man page": "<pre><br><span class=\"headline\">INIT_MODULE(2)            Linux Programmer's Manual           INIT_MODULE(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       init_module, finit_module - load a kernel module<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>int init_module(void *</b><i>module_image</i><b>, unsigned long </b><i>len</i><b>,</b><br>                       <b>const char *</b><i>param_values</i><b>);</b><br><br>       <b>int finit_module(int </b><i>fd</i><b>, const char *</b><i>param_values</i><b>,</b><br>                        <b>int </b><i>flags</i><b>);</b><br><br>       <i>Note</i>: glibc provides no header file declaration of <b>init_module</b>() and<br>       no wrapper function for <b>finit_module</b>(); see NOTES.<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>init_module</b>() loads an ELF image into kernel space, performs any<br>       necessary symbol relocations, initializes module parameters to values<br>       provided by the caller, and then runs the module's <i>init</i> function.<br>       This system call requires privilege.<br><br>       The <i>module_image</i> argument points to a buffer containing the binary<br>       image to be loaded; <i>len</i> specifies the size of that buffer.  The<br>       module image should be a valid ELF image, built for the running<br>       kernel.<br><br>       The <i>param_values</i> argument is a string containing space-delimited<br>       specifications of the values for module parameters (defined inside<br>       the module using <b>module_param</b>() and <b>module_param_array</b>()).  The<br>       kernel parses this string and initializes the specified parameters.<br>       Each of the parameter specifications has the form:<br><br>               <i>name</i>[<b>=</b><i>value</i>[<b>,</b><i>value</i>...]]<br><br>       The parameter <i>name</i> is one of those defined within the module using<br>       <i>module_param</i>() (see the Linux kernel source file<br>       <i>include/linux/moduleparam.h</i>).  The parameter <i>value</i> is optional in the<br>       case of <i>bool</i> and <i>invbool</i> parameters.  Values for array parameters are<br>       specified as a comma-separated list.<br><br>   <b>finit_module()</b><br>       The <b>finit_module</b>() system call is like <b>init_module</b>(), but reads the<br>       module to be loaded from the file descriptor <i>fd</i>.  It is useful when<br>       the authenticity of a kernel module can be determined from its<br>       location in the filesystem; in cases where that is possible, the<br>       overhead of using cryptographically signed modules to determine the<br>       authenticity of a module can be avoided.  The <i>param_values</i> argument<br>       is as for <b>init_module</b>().<br><br>       The <i>flags</i> argument modifies the operation of <b>finit_module</b>().  It is a<br>       bit mask value created by ORing together zero or more of the<br>       following flags:<br><br>       <b>MODULE_INIT_IGNORE_MODVERSIONS</b><br>              Ignore symbol version hashes.<br><br>       <b>MODULE_INIT_IGNORE_VERMAGIC</b><br>              Ignore kernel version magic.<br><br>       There are some safety checks built into a module to ensure that it<br>       matches the kernel against which it is loaded.  These checks are<br>       recorded when the module is built and verified when the module is<br>       loaded.  First, the module records a \"vermagic\" string containing the<br>       kernel version number and prominent features (such as the CPU type).<br>       Second, if the module was built with the <b>CONFIG_MODVERSIONS</b><br>       configuration option enabled, a version hash is recorded for each<br>       symbol the module uses.  This hash is based on the types of the<br>       arguments and return value for the function named by the symbol.  In<br>       this case, the kernel version number within the \"vermagic\" string is<br>       ignored, as the symbol version hashes are assumed to be sufficiently<br>       reliable.<br><br>       Using the <b>MODULE_INIT_IGNORE_VERMAGIC </b>flag indicates that the<br>       \"vermagic\" string is to be ignored, and the<br>       <b>MODULE_INIT_IGNORE_MODVERSIONS </b>flag indicates that the symbol version<br>       hashes are to be ignored.  If the kernel is built to permit forced<br>       loading (i.e., configured with <b>CONFIG_MODULE_FORCE_LOAD</b>), then<br>       loading will continue, otherwise it will fail with <b>ENOEXEC </b>as<br>       expected for malformed modules.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, these system calls return 0.  On error, -1 is returned<br>       and <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EBADMSG </b>(since Linux 3.7)<br>              Module signature is misformatted.<br><br>       <b>EBUSY  </b>Timeout while trying to resolve a symbol reference by this<br>              module.<br><br>       <b>EFAULT </b>An address argument referred to a location that is outside the<br>              process's accessible address space.<br><br>       <b>ENOKEY </b>(since Linux 3.7)<br>              Module signature is invalid or the kernel does not have a key<br>              for this module.  This error is returned only if the kernel<br>              was configured with <b>CONFIG_MODULE_SIG_FORCE</b>; if the kernel was<br>              not configured with this option, then an invalid or unsigned<br>              module simply taints the kernel.<br><br>       <b>ENOMEM </b>Out of memory.<br><br>       <b>EPERM  </b>The caller was not privileged (did not have the <b>CAP_SYS_MODULE</b><br>              capability), or module loading is disabled (see<br>              <i>/proc/sys/kernel/modules_disabled</i> in proc(5)).<br><br>       The following errors may additionally occur for <b>init_module</b>():<br><br>       <b>EEXIST </b>A module with this name is already loaded.<br><br>       <b>EINVAL </b><i>param_values</i> is invalid, or some part of the ELF image in<br>              <i>module_image</i> contains inconsistencies.<br><br>       <b>ENOEXEC</b><br>              The binary image supplied in <i>module_image</i> is not an ELF image,<br>              or is an ELF image that is invalid or for a different<br>              architecture.<br><br>       The following errors may additionally occur for <b>finit_module</b>():<br><br>       <b>EBADF  </b>The file referred to by <i>fd</i> is not opened for reading.<br><br>       <b>EFBIG  </b>The file referred to by <i>fd</i> is too large.<br><br>       <b>EINVAL </b><i>flags</i> is invalid.<br><br>       <b>ENOEXEC</b><br>              <i>fd</i> does not refer to an open file.<br><br>       In addition to the above errors, if the module's <i>init</i> function is<br>       executed and returns an error, then <b>init_module</b>() or <b>finit_module</b>()<br>       fails and <i>errno</i> is set to the value returned by the <i>init</i> function.<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>finit_module</b>() is available since Linux 3.8.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>init_module</b>() and <b>finit_module</b>() are Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       The <b>init_module</b>() system call is not supported by glibc.  No<br>       declaration is provided in glibc headers, but, through a quirk of<br>       history, glibc does export an ABI for this system call.  Therefore,<br>       in order to employ this system call, it is sufficient to manually<br>       declare the interface in your code; alternatively, you can invoke the<br>       system call using syscall(2).<br><br>       Glibc does not provide a wrapper for <b>finit_module</b>(); call it using<br>       syscall(2).<br><br>       Information about currently loaded modules can be found in<br>       <i>/proc/modules</i> and in the file trees under the per-module<br>       subdirectories under <i>/sys/module</i>.<br><br>       See the Linux kernel source file <i>include/linux/module.h</i> for some<br>       useful background information.<br><br>   <b>Linux 2.4 and earlier</b><br>       In Linux 2.4 and earlier, the <b>init_module</b>() system call was rather<br>       different:<br><br>           <b>#include &lt;linux/module.h&gt;</b><br><br>           <b>int init_module(const char *</b><i>name</i><b>, struct module *</b><i>image</i><b>);</b><br><br>       (User-space applications can detect which version of <b>init_module</b>() is<br>       available by calling <b>query_module</b>(); the latter call fails with the<br>       error <b>ENOSYS </b>on Linux 2.6 and later.)<br><br>       The older version of the system call loads the relocated module image<br>       pointed to by <i>image</i> into kernel space and runs the module's <i>init</i><br>       function.  The caller is responsible for providing the relocated<br>       image (since Linux 2.6, the <b>init_module</b>() system call does the<br>       relocation).<br><br>       The module image begins with a module structure and is followed by<br>       code and data as appropriate.  Since Linux 2.2, the module structure<br>       is defined as follows:<br><br>           struct module {<br>               unsigned long         size_of_struct;<br>               struct module        *next;<br>               const char           *name;<br>               unsigned long         size;<br>               long                  usecount;<br>               unsigned long         flags;<br>               unsigned int          nsyms;<br>               unsigned int          ndeps;<br>               struct module_symbol *syms;<br>               struct module_ref    *deps;<br>               struct module_ref    *refs;<br>               int                 (*init)(void);<br>               void                (*cleanup)(void);<br>               const struct exception_table_entry *ex_table_start;<br>               const struct exception_table_entry *ex_table_end;<br>           #ifdef __alpha__<br>               unsigned long gp;<br>           #endif<br>           };<br><br>       All of the pointer fields, with the exception of <i>next</i> and <i>refs</i>, are<br>       expected to point within the module body and be initialized as<br>       appropriate for kernel space, that is, relocated with the rest of the<br>       module.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       create_module(2), delete_module(2), query_module(2), lsmod(8),<br>       modprobe(8)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2014-05-10                   INIT_MODULE(2)</span><br></pre><br>"}