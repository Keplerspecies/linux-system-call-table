{"Man page": "<pre><br><span class=\"headline\">SENDFILE(2)               Linux Programmer's Manual              SENDFILE(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       sendfile - transfer data between file descriptors<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/sendfile.h&gt;</b><br><br>       <b>ssize_t sendfile(int </b><i>out_fd</i><b>, int </b><i>in_fd</i><b>, off_t *</b><i>offset</i><b>, size_t </b><i>count</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>sendfile</b>() copies data between one file descriptor and another.<br>       Because this copying is done within the kernel, <b>sendfile</b>() is more<br>       efficient than the combination of read(2) and write(2), which would<br>       require transferring data to and from user space.<br><br>       <i>in_fd</i> should be a file descriptor opened for reading and <i>out_fd</i><br>       should be a descriptor opened for writing.<br><br>       If <i>offset</i> is not NULL, then it points to a variable holding the file<br>       offset from which <b>sendfile</b>() will start reading data from <i>in_fd</i>.<br>       When <b>sendfile</b>() returns, this variable will be set to the offset of<br>       the byte following the last byte that was read.  If <i>offset</i> is not<br>       NULL, then <b>sendfile</b>() does not modify the current file offset of<br>       <i>in_fd</i>; otherwise the current file offset is adjusted to reflect the<br>       number of bytes read from <i>in_fd</i>.<br><br>       If <i>offset</i> is NULL, then data will be read from <i>in_fd</i> starting at the<br>       current file offset, and the file offset will be updated by the call.<br><br>       <i>count</i> is the number of bytes to copy between the file descriptors.<br><br>       The <i>in_fd</i> argument must correspond to a file which supports<br>       mmap(2)-like operations (i.e., it cannot be a socket).<br><br>       In Linux kernels before 2.6.33, <i>out_fd</i> must refer to a socket.  Since<br>       Linux 2.6.33 it can be any file.  If it is a regular file, then<br>       <b>sendfile</b>() changes the file offset appropriately.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       If the transfer was successful, the number of bytes written to <i>out_fd</i><br>       is returned.  Note that a successful call to <b>sendfile</b>() may write<br>       fewer bytes than requested; the caller should be prepared to retry<br>       the call if there were unsent bytes.  See also NOTES.<br><br>       On error, -1 is returned, and <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EAGAIN </b>Nonblocking I/O has been selected using <b>O_NONBLOCK </b>and the<br>              write would block.<br><br>       <b>EBADF  </b>The input file was not opened for reading or the output file<br>              was not opened for writing.<br><br>       <b>EFAULT </b>Bad address.<br><br>       <b>EINVAL </b>Descriptor is not valid or locked, or an mmap(2)-like<br>              operation is not available for <i>in_fd</i>.<br><br>       <b>EINVAL </b><i>out_fd</i> has the <b>O_APPEND </b>flag set.  This is not currently<br>              supported by <b>sendfile</b>().<br><br>       <b>EIO    </b>Unspecified error while reading from <i>in_fd</i>.<br><br>       <b>ENOMEM </b>Insufficient memory to read from <i>in_fd</i>.<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>sendfile</b>() first appeared in Linux 2.2.  The include file<br>       <i>&lt;sys/sendfile.h&gt;</i> is present since glibc 2.1.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       Not specified in POSIX.1-2001, nor in other standards.<br><br>       Other UNIX systems implement <b>sendfile</b>() with different semantics and<br>       prototypes.  It should not be used in portable programs.<br></pre><br><h2>NOTES  </h2><pre><br>       <b>sendfile</b>() will transfer at most 0x7ffff000 (2,147,479,552) bytes,<br>       returning the number of bytes actually transferred.  (This is true on<br>       both 32-bit and 64-bit systems.)<br><br>       If you plan to use <b>sendfile</b>() for sending files to a TCP socket, but<br>       need to send some header data in front of the file contents, you will<br>       find it useful to employ the <b>TCP_CORK </b>option, described in tcp(7), to<br>       minimize the number of packets and to tune performance.<br><br>       In Linux 2.4 and earlier, <i>out_fd</i> could also refer to a regular file;<br>       this possibility went away in the Linux 2.6.x kernel series, but was<br>       restored in Linux 2.6.33.<br><br>       The original Linux <b>sendfile</b>() system call was not designed to handle<br>       large file offsets.  Consequently, Linux 2.4 added <b>sendfile64</b>(), with<br>       a wider type for the <i>offset</i> argument.  The glibc <b>sendfile</b>() wrapper<br>       function transparently deals with the kernel differences.<br><br>       Applications may wish to fall back to read(2)/write(2) in the case<br>       where <b>sendfile</b>() fails with <b>EINVAL </b>or <b>ENOSYS</b>.<br><br>       If <i>out_fd</i> refers to a socket or pipe with zero-copy support, callers<br>       must ensure the transferred portions of the file referred to by <i>in_fd</i><br>       remain unmodified until the reader on the other end of <i>out_fd</i> has<br>       consumed the transferred data.<br><br>       The Linux-specific splice(2) call supports transferring data between<br>       arbitrary files (e.g., a pair of sockets).<br></pre><br><h2>SEE ALSO  </h2><pre><br>       mmap(2), open(2), socket(2), splice(2)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-05-07                      SENDFILE(2)</span><br></pre><br>"}