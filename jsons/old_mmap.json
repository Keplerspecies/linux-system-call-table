{"Man page": "<pre><br><span class=\"headline\">MMAP(2)                   Linux Programmer's Manual                  MMAP(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       mmap, munmap - map or unmap files or devices into memory<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/mman.h&gt;</b><br><br>       <b>void *mmap(void *</b><i>addr</i><b>, size_t </b><i>length</i><b>, int </b><i>prot</i><b>, int </b><i>flags</i><b>,</b><br>                  <b>int </b><i>fd</i><b>, off_t </b><i>offset</i><b>);</b><br>       <b>int munmap(void *</b><i>addr</i><b>, size_t </b><i>length</i><b>);</b><br><br>       See NOTES for information on feature test macro requirements.<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>mmap</b>() creates a new mapping in the virtual address space of the<br>       calling process.  The starting address for the new mapping is<br>       specified in <i>addr</i>.  The <i>length</i> argument specifies the length of the<br>       mapping.<br><br>       If <i>addr</i> is NULL, then the kernel chooses the address at which to<br>       create the mapping; this is the most portable method of creating a<br>       new mapping.  If <i>addr</i> is not NULL, then the kernel takes it as a hint<br>       about where to place the mapping; on Linux, the mapping will be<br>       created at a nearby page boundary.  The address of the new mapping is<br>       returned as the result of the call.<br><br>       The contents of a file mapping (as opposed to an anonymous mapping;<br>       see <b>MAP_ANONYMOUS </b>below), are initialized using <i>length</i> bytes starting<br>       at offset <i>offset</i> in the file (or other object) referred to by the<br>       file descriptor <i>fd</i>.  <i>offset</i> must be a multiple of the page size as<br>       returned by <i>sysconf(_SC_PAGE_SIZE)</i>.<br><br>       The <i>prot</i> argument describes the desired memory protection of the<br>       mapping (and must not conflict with the open mode of the file).  It<br>       is either <b>PROT_NONE </b>or the bitwise OR of one or more of the following<br>       flags:<br><br>       <b>PROT_EXEC  </b>Pages may be executed.<br><br>       <b>PROT_READ  </b>Pages may be read.<br><br>       <b>PROT_WRITE </b>Pages may be written.<br><br>       <b>PROT_NONE  </b>Pages may not be accessed.<br><br>       The <i>flags</i> argument determines whether updates to the mapping are<br>       visible to other processes mapping the same region, and whether<br>       updates are carried through to the underlying file.  This behavior is<br>       determined by including exactly one of the following values in <i>flags</i>:<br><br>       <b>MAP_SHARED</b><br>              Share this mapping.  Updates to the mapping are visible to<br>              other processes that map this file, and are carried through to<br>              the underlying file.  (To precisely control when updates are<br>              carried through to the underlying file requires the use of<br>              msync(2).)<br><br>       <b>MAP_PRIVATE</b><br>              Create a private copy-on-write mapping.  Updates to the<br>              mapping are not visible to other processes mapping the same<br>              file, and are not carried through to the underlying file.  It<br>              is unspecified whether changes made to the file after the<br>              <b>mmap</b>() call are visible in the mapped region.<br><br>       Both of these flags are described in POSIX.1-2001 and POSIX.1-2008.<br><br>       In addition, zero or more of the following values can be ORed in<br>       <i>flags</i>:<br><br>       <b>MAP_32BIT </b>(since Linux 2.4.20, 2.6)<br>              Put the mapping into the first 2 Gigabytes of the process<br>              address space.  This flag is supported only on x86-64, for<br>              64-bit programs.  It was added to allow thread stacks to be<br>              allocated somewhere in the first 2GB of memory, so as to<br>              improve context-switch performance on some early 64-bit<br>              processors.  Modern x86-64 processors no longer have this<br>              performance problem, so use of this flag is not required on<br>              those systems.  The <b>MAP_32BIT </b>flag is ignored when <b>MAP_FIXED</b><br>              is set.<br><br>       <b>MAP_ANON</b><br>              Synonym for <b>MAP_ANONYMOUS</b>.  Deprecated.<br><br>       <b>MAP_ANONYMOUS</b><br>              The mapping is not backed by any file; its contents are<br>              initialized to zero.  The <i>fd</i> and <i>offset</i> arguments are ignored;<br>              however, some implementations require <i>fd</i> to be -1 if<br>              <b>MAP_ANONYMOUS </b>(or <b>MAP_ANON</b>) is specified, and portable<br>              applications should ensure this.  The use of <b>MAP_ANONYMOUS </b>in<br>              conjunction with <b>MAP_SHARED </b>is supported on Linux only since<br>              kernel 2.4.<br><br>       <b>MAP_DENYWRITE</b><br>              This flag is ignored.  (Long ago, it signaled that attempts to<br>              write to the underlying file should fail with <b>ETXTBUSY</b>.  But<br>              this was a source of denial-of-service attacks.)<br><br>       <b>MAP_EXECUTABLE</b><br>              This flag is ignored.<br><br>       <b>MAP_FILE</b><br>              Compatibility flag.  Ignored.<br><br>       <b>MAP_FIXED</b><br>              Don't interpret <i>addr</i> as a hint: place the mapping at exactly<br>              that address.  <i>addr</i> must be a multiple of the page size.  If<br>              the memory region specified by <i>addr</i> and <i>len</i> overlaps pages of<br>              any existing mapping(s), then the overlapped part of the<br>              existing mapping(s) will be discarded.  If the specified<br>              address cannot be used, <b>mmap</b>() will fail.  Because requiring a<br>              fixed address for a mapping is less portable, the use of this<br>              option is discouraged.<br><br>       <b>MAP_GROWSDOWN</b><br>              Used for stacks.  Indicates to the kernel virtual memory<br>              system that the mapping should extend downward in memory.<br><br>       <b>MAP_HUGETLB </b>(since Linux 2.6.32)<br>              Allocate the mapping using \"huge pages.\"  See the Linux kernel<br>              source file <i>Documentation/vm/hugetlbpage.txt</i> for further<br>              information, as well as NOTES, below.<br><br>       <b>MAP_HUGE_2MB</b>, <b>MAP_HUGE_1GB </b>(since Linux 3.8)<br>              Used in conjunction with <b>MAP_HUGETLB </b>to select alternative<br>              hugetlb page sizes (respectively, 2 MB and 1 GB) on systems<br>              that support multiple hugetlb page sizes.<br><br>              More generally, the desired huge page size can be configured<br>              by encoding the base-2 logarithm of the desired page size in<br>              the six bits at the offset <b>MAP_HUGE_SHIFT</b>.  (A value of zero<br>              in this bit field provides the default huge page size; the<br>              default huge page size can be discovered vie the <i>Hugepagesize</i><br>              field exposed by <i>/proc/meminfo</i>.)  Thus, the above two<br>              constants are defined as:<br><br>                  #define MAP_HUGE_2MB    (21 &lt;&lt; MAP_HUGE_SHIFT)<br>                  #define MAP_HUGE_1GB    (30 &lt;&lt; MAP_HUGE_SHIFT)<br><br>              The range of huge page sizes that are supported by the system<br>              can be discovered by listing the subdirectories in<br>              <i>/sys/kernel/mm/hugepages</i>.<br><br>       <b>MAP_LOCKED </b>(since Linux 2.5.37)<br>              Mark the mmaped region to be locked in the same way as<br>              mlock(2).  This implementation will try to populate (prefault)<br>              the whole range but the mmap call doesn't fail with <b>ENOMEM </b>if<br>              this fails.  Therefore major faults might happen later on.  So<br>              the semantic is not as strong as mlock(2).  One should use<br>              mmap(2) plus mlock(2) when major faults are not acceptable<br>              after the initialization of the mapping.  The <b>MAP_LOCKED </b>flag<br>              is ignored in older kernels.<br><br>       <b>MAP_NONBLOCK </b>(since Linux 2.5.46)<br>              Only meaningful in conjunction with <b>MAP_POPULATE</b>.  Don't<br>              perform read-ahead: create page tables entries only for pages<br>              that are already present in RAM.  Since Linux 2.6.23, this<br>              flag causes <b>MAP_POPULATE </b>to do nothing.  One day, the<br>              combination of <b>MAP_POPULATE </b>and <b>MAP_NONBLOCK </b>may be<br>              reimplemented.<br><br>       <b>MAP_NORESERVE</b><br>              Do not reserve swap space for this mapping.  When swap space<br>              is reserved, one has the guarantee that it is possible to<br>              modify the mapping.  When swap space is not reserved one might<br>              get <b>SIGSEGV </b>upon a write if no physical memory is available.<br>              See also the discussion of the file<br>              <i>/proc/sys/vm/overcommit_memory</i> in proc(5).  In kernels before<br>              2.6, this flag had effect only for private writable mappings.<br><br>       <b>MAP_POPULATE </b>(since Linux 2.5.46)<br>              Populate (prefault) page tables for a mapping.  For a file<br>              mapping, this causes read-ahead on the file.  This will help<br>              to reduce blocking on page faults later.  <b>MAP_POPULATE </b>is<br>              supported for private mappings only since Linux 2.6.23.<br><br>       <b>MAP_STACK </b>(since Linux 2.6.27)<br>              Allocate the mapping at an address suitable for a process or<br>              thread stack.  This flag is currently a no-op, but is used in<br>              the glibc threading implementation so that if some<br>              architectures require special treatment for stack allocations,<br>              support can later be transparently implemented for glibc.<br><br>       <b>MAP_UNINITIALIZED </b>(since Linux 2.6.33)<br>              Don't clear anonymous pages.  This flag is intended to improve<br>              performance on embedded devices.  This flag is honored only if<br>              the kernel was configured with the<br>              <b>CONFIG_MMAP_ALLOW_UNINITIALIZED </b>option.  Because of the<br>              security implications, that option is normally enabled only on<br>              embedded devices (i.e., devices where one has complete control<br>              of the contents of user memory).<br><br>       Of the above flags, only <b>MAP_FIXED </b>is specified in POSIX.1-2001 and<br>       POSIX.1-2008.  However, most systems also support <b>MAP_ANONYMOUS </b>(or<br>       its synonym <b>MAP_ANON</b>).<br><br>       Some systems document the additional flags <b>MAP_AUTOGROW</b>,<br>       <b>MAP_AUTORESRV</b>, <b>MAP_COPY</b>, and <b>MAP_LOCAL</b>.<br><br>       Memory mapped by <b>mmap</b>() is preserved across fork(2), with the same<br>       attributes.<br><br>       A file is mapped in multiples of the page size.  For a file that is<br>       not a multiple of the page size, the remaining memory is zeroed when<br>       mapped, and writes to that region are not written out to the file.<br>       The effect of changing the size of the underlying file of a mapping<br>       on the pages that correspond to added or removed regions of the file<br>       is unspecified.<br><br>   <b>munmap()</b><br>       The <b>munmap</b>() system call deletes the mappings for the specified<br>       address range, and causes further references to addresses within the<br>       range to generate invalid memory references.  The region is also<br>       automatically unmapped when the process is terminated.  On the other<br>       hand, closing the file descriptor does not unmap the region.<br><br>       The address <i>addr</i> must be a multiple of the page size (but <i>length</i> need<br>       not be).  All pages containing a part of the indicated range are<br>       unmapped, and subsequent references to these pages will generate<br>       <b>SIGSEGV</b>.  It is not an error if the indicated range does not contain<br>       any mapped pages.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>mmap</b>() returns a pointer to the mapped area.  On error,<br>       the value <b>MAP_FAILED </b>(that is, <i>(void *) -1</i>) is returned, and <i>errno</i> is<br>       set to indicate the cause of the error.<br><br>       On success, <b>munmap</b>() returns 0.  On failure, it returns -1, and <i>errno</i><br>       is set to indicate the cause of the error (probably to <b>EINVAL</b>).<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EACCES </b>A file descriptor refers to a non-regular file.  Or a file<br>              mapping was requested, but <i>fd</i> is not open for reading.  Or<br>              <b>MAP_SHARED </b>was requested and <b>PROT_WRITE </b>is set, but <i>fd</i> is not<br>              open in read/write (<b>O_RDWR</b>) mode.  Or <b>PROT_WRITE </b>is set, but<br>              the file is append-only.<br><br>       <b>EAGAIN </b>The file has been locked, or too much memory has been locked<br>              (see setrlimit(2)).<br><br>       <b>EBADF  </b><i>fd</i> is not a valid file descriptor (and <b>MAP_ANONYMOUS </b>was not<br>              set).<br><br>       <b>EINVAL </b>We don't like <i>addr</i>, <i>length</i>, or <i>offset</i> (e.g., they are too<br>              large, or not aligned on a page boundary).<br><br>       <b>EINVAL </b>(since Linux 2.6.12) <i>length</i> was 0.<br><br>       <b>EINVAL </b><i>flags</i> contained neither <b>MAP_PRIVATE </b>or <b>MAP_SHARED</b>, or<br>              contained both of these values.<br><br>       <b>ENFILE </b>The system limit on the total number of open files has been<br>              reached.<br><br>       <b>ENODEV </b>The underlying filesystem of the specified file does not<br>              support memory mapping.<br><br>       <b>ENOMEM </b>No memory is available.<br><br>       <b>ENOMEM </b>The process's maximum number of mappings would have been<br>              exceeded.  This error can also occur for munmap(2), when<br>              unmapping a region in the middle of an existing mapping, since<br>              this results in two smaller mappings on either side of the<br>              region being unmapped.<br><br>       <b>EPERM  </b>The <i>prot</i> argument asks for <b>PROT_EXEC </b>but the mapped area<br>              belongs to a file on a filesystem that was mounted no-exec.<br><br>       <b>EPERM  </b>The operation was prevented by a file seal; see fcntl(2).<br><br>       <b>ETXTBSY</b><br>              <b>MAP_DENYWRITE </b>was set but the object specified by <i>fd</i> is open<br>              for writing.<br><br>       <b>EOVERFLOW</b><br>              On 32-bit architecture together with the large file extension<br>              (i.e., using 64-bit <i>off_t</i>): the number of pages used for<br>              <i>length</i> plus number of pages used for <i>offset</i> would overflow<br>              <i>unsigned long</i> (32 bits).<br><br>       Use of a mapped region can result in these signals:<br><br>       <b>SIGSEGV</b><br>              Attempted write into a region mapped as read-only.<br><br>       <b>SIGBUS </b>Attempted access to a portion of the buffer that does not<br>              correspond to the file (for example, beyond the end of the<br>              file, including the case where another process has truncated<br>              the file).<br></pre><br><h2>ATTRIBUTES  </h2><pre><br>       For an explanation of the terms used in this section, see<br>       attributes(7).<br><br>       &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9516;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9516;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;<br>       &#9474;<b>Interface          </b>&#9474; <b>Attribute     </b>&#9474; <b>Value   </b>&#9474;<br>       &#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;<br>       &#9474;<b>mmap</b>(), <b>munmap</b>()   &#9474; Thread safety &#9474; MT-Safe &#9474;<br>       &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9524;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9524;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD.<br></pre><br><h2>AVAILABILITY  </h2><pre><br>       On POSIX systems on which <b>mmap</b>(), msync(2), and <b>munmap</b>() are<br>       available, <b>_POSIX_MAPPED_FILES </b>is defined in <i>&lt;unistd.h&gt;</i> to a value<br>       greater than 0.  (See also sysconf(3).)<br></pre><br><h2>NOTES  </h2><pre><br>       On some hardware architectures (e.g., i386), <b>PROT_WRITE </b>implies<br>       <b>PROT_READ</b>.  It is architecture dependent whether <b>PROT_READ </b>implies<br>       <b>PROT_EXEC </b>or not.  Portable programs should always set <b>PROT_EXEC </b>if<br>       they intend to execute code in the new mapping.<br><br>       The portable way to create a mapping is to specify <i>addr</i> as 0 (NULL),<br>       and omit <b>MAP_FIXED </b>from <i>flags</i>.  In this case, the system chooses the<br>       address for the mapping; the address is chosen so as not to conflict<br>       with any existing mapping, and will not be 0.  If the <b>MAP_FIXED </b>flag<br>       is specified, and <i>addr</i> is 0 (NULL), then the mapped address will be 0<br>       (NULL).<br><br>       Certain <i>flags</i> constants are defined only if either <b>_BSD_SOURCE </b>or<br>       <b>_SVID_SOURCE </b>is defined.  (Requiring <b>_GNU_SOURCE </b>also suffices, and<br>       requiring that macro specifically would have been more logical, since<br>       these flags are all Linux-specific.)  The relevant flags are:<br>       <b>MAP_32BIT</b>, <b>MAP_ANONYMOUS </b>(and the synonym <b>MAP_ANON</b>), <b>MAP_DENYWRITE</b>,<br>       <b>MAP_EXECUTABLE</b>, <b>MAP_FILE</b>, <b>MAP_GROWSDOWN</b>, <b>MAP_HUGETLB</b>, <b>MAP_LOCKED</b>,<br>       <b>MAP_NONBLOCK</b>, <b>MAP_NORESERVE</b>, <b>MAP_POPULATE</b>, and <b>MAP_STACK</b>.<br><br>   <b>Timestamps changes for file-backed mappings</b><br>       For file-backed mappings, the <i>st_atime</i> field for the mapped file may<br>       be updated at any time between the <b>mmap</b>() and the corresponding<br>       unmapping; the first reference to a mapped page will update the field<br>       if it has not been already.<br><br>       The <i>st_ctime</i> and <i>st_mtime</i> field for a file mapped with <b>PROT_WRITE </b>and<br>       <b>MAP_SHARED </b>will be updated after a write to the mapped region, and<br>       before a subsequent msync(2) with the <b>MS_SYNC </b>or <b>MS_ASYNC </b>flag, if<br>       one occurs.<br><br>   <b>Huge page (Huge TLB) mappings</b><br>       For mappings that employ huge pages, the requirements for the<br>       arguments of <b>mmap</b>() and <b>munmap</b>() differ somewhat from the<br>       requirements for mappings that use the native system page size.<br><br>       For <b>mmap</b>(), <i>offset</i> must be a multiple of the underlying huge page<br>       size.  The system automatically aligns <i>length</i> to be a multiple of the<br>       underlying huge page size.<br><br>       For <b>munmap</b>(), <i>addr</i> and <i>length</i> must both be a multiple of the<br>       underlying huge page size.<br><br>   <b>C library/kernel differences</b><br>       This page describes the interface provided by the glibc <b>mmap</b>()<br>       wrapper function.  Originally, this function invoked a system call of<br>       the same name.  Since kernel 2.4, that system call has been<br>       superseded by mmap2(2), and nowadays the glibc <b>mmap</b>() wrapper<br>       function invokes mmap2(2) with a suitably adjusted value for <i>offset</i>.<br></pre><br><h2>BUGS  </h2><pre><br>       On Linux there are no guarantees like those suggested above under<br>       <b>MAP_NORESERVE</b>.  By default, any process can be killed at any moment<br>       when the system runs out of memory.<br><br>       In kernels before 2.6.7, the <b>MAP_POPULATE </b>flag has effect only if<br>       <i>prot</i> is specified as <b>PROT_NONE</b>.<br><br>       SUSv3 specifies that <b>mmap</b>() should fail if <i>length</i> is 0.  However, in<br>       kernels before 2.6.12, <b>mmap</b>() succeeded in this case: no mapping was<br>       created and the call returned <i>addr</i>.  Since kernel 2.6.12, <b>mmap</b>()<br>       fails with the error <b>EINVAL </b>for this case.<br><br>       POSIX specifies that the system shall always zero fill any partial<br>       page at the end of the object and that system will never write any<br>       modification of the object beyond its end.  On Linux, when you write<br>       data to such partial page after the end of the object, the data stays<br>       in the page cache even after the file is closed and unmapped and even<br>       though the data is never written to the file itself, subsequent<br>       mappings may see the modified content.  In some cases, this could be<br>       fixed by calling msync(2) before the unmap takes place; however, this<br>       doesn't work on tmpfs (for example, when using POSIX shared memory<br>       interface documented in shm_overview(7)).<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The following program prints part of the file specified in its first<br>       command-line argument to standard output.  The range of bytes to be<br>       printed is specified via offset and length values in the second and<br>       third command-line arguments.  The program creates a memory mapping<br>       of the required pages of the file and then uses write(2) to output<br>       the desired bytes.<br><br>   <b>Program source</b><br>       #include &lt;sys/mman.h&gt;<br>       #include &lt;sys/stat.h&gt;<br>       #include &lt;fcntl.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;unistd.h&gt;<br><br>       #define handle_error(msg) \\<br>           do { perror(msg); exit(EXIT_FAILURE); } while (0)<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           char *addr;<br>           int fd;<br>           struct stat sb;<br>           off_t offset, pa_offset;<br>           size_t length;<br>           ssize_t s;<br><br>           if (argc &lt; 3 || argc &gt; 4) {<br>               fprintf(stderr, \"%s file offset [length]\\n\", argv[0]);<br>               exit(EXIT_FAILURE);<br>           }<br><br>           fd = open(argv[1], O_RDONLY);<br>           if (fd == -1)<br>               handle_error(\"open\");<br><br>           if (fstat(fd, &amp;sb) == -1)           /* To obtain file size */<br>               handle_error(\"fstat\");<br><br>           offset = atoi(argv[2]);<br>           pa_offset = offset &amp; ~(sysconf(_SC_PAGE_SIZE) - 1);<br>               /* offset for mmap() must be page aligned */<br><br>           if (offset &gt;= sb.st_size) {<br>               fprintf(stderr, \"offset is past end of file\\n\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           if (argc == 4) {<br>               length = atoi(argv[3]);<br>               if (offset + length &gt; sb.st_size)<br>                   length = sb.st_size - offset;<br>                       /* Can't display bytes past end of file */<br><br>           } else {    /* No length arg ==&gt; display to end of file */<br>               length = sb.st_size - offset;<br>           }<br><br>           addr = mmap(NULL, length + offset - pa_offset, PROT_READ,<br>                       MAP_PRIVATE, fd, pa_offset);<br>           if (addr == MAP_FAILED)<br>               handle_error(\"mmap\");<br><br>           s = write(STDOUT_FILENO, addr + offset - pa_offset, length);<br>           if (s != length) {<br>               if (s == -1)<br>                   handle_error(\"write\");<br><br>               fprintf(stderr, \"partial write\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           exit(EXIT_SUCCESS);<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       getpagesize(2), memfd_create(2), mincore(2), mlock(2), mmap2(2),<br>       mprotect(2), mremap(2), msync(2), remap_file_pages(2), setrlimit(2),<br>       shmat(2), shm_open(3), shm_overview(7)<br><br>       The descriptions of the following files in proc(5): <i>/proc/[pid]/maps</i>,<br>       <i>/proc/[pid]/map_files</i>, and <i>/proc/[pid]/smaps</i>.<br><br>       B.O. Gallmeister, POSIX.4, O'Reilly, pp. 128-129 and 389-391.<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-08-08                          MMAP(2)</span><br></pre><br>"}