{"Man page": "<pre><br><span class=\"headline\">READV(2)                  Linux Programmer's Manual                 READV(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       readv,  writev,  preadv,  pwritev  - read or write data into multiple<br>       buffers<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/uio.h&gt;</b><br><br>       <b>ssize_t readv(int </b><i>fd</i><b>, const struct iovec *</b><i>iov</i><b>, int </b><i>iovcnt</i><b>);</b><br><br>       <b>ssize_t writev(int </b><i>fd</i><b>, const struct iovec *</b><i>iov</i><b>, int </b><i>iovcnt</i><b>);</b><br><br>       <b>ssize_t preadv(int </b><i>fd</i><b>, const struct iovec *</b><i>iov</i><b>, int </b><i>iovcnt</i><b>,</b><br>                      <b>off_t </b><i>offset</i><b>);</b><br><br>       <b>ssize_t pwritev(int </b><i>fd</i><b>, const struct iovec *</b><i>iov</i><b>, int </b><i>iovcnt</i><b>,</b><br>                       <b>off_t </b><i>offset</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>preadv</b>(), <b>pwritev</b>(): _BSD_SOURCE<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>readv</b>() system call reads <i>iovcnt</i> buffers from the file associated<br>       with the file descriptor <i>fd</i> into the buffers described by <i>iov</i><br>       (\"scatter input\").<br><br>       The <b>writev</b>() system call writes <i>iovcnt</i> buffers of data described by<br>       <i>iov</i> to the file associated with the file descriptor <i>fd</i> (\"gather<br>       output\").<br><br>       The pointer <i>iov</i> points to an array of <i>iovec</i> structures, defined in<br>       <i>&lt;sys/uio.h&gt;</i> as:<br><br>           struct iovec {<br>               void  *iov_base;    /* Starting address */<br>               size_t iov_len;     /* Number of bytes to transfer */<br>           };<br><br>       The <b>readv</b>() system call works just like read(2) except that multiple<br>       buffers are filled.<br><br>       The <b>writev</b>() system call works just like write(2) except that<br>       multiple buffers are written out.<br><br>       Buffers are processed in array order.  This means that <b>readv</b>()<br>       completely fills <i>iov</i>[0] before proceeding to <i>iov</i>[1], and so on.  (If<br>       there is insufficient data, then not all buffers pointed to by <i>iov</i><br>       may be filled.)  Similarly, <b>writev</b>() writes out the entire contents<br>       of <i>iov</i>[0] before proceeding to <i>iov</i>[1], and so on.<br><br>       The data transfers performed by <b>readv</b>() and <b>writev</b>() are atomic: the<br>       data written by <b>writev</b>() is written as a single block that is not<br>       intermingled with output from writes in other processes (but see<br>       pipe(7) for an exception); analogously, <b>readv</b>() is guaranteed to read<br>       a contiguous block of data from the file, regardless of read<br>       operations performed in other threads or processes that have file<br>       descriptors referring to the same open file description (see<br>       open(2)).<br><br>   <b>preadv() and pwritev()</b><br>       The <b>preadv</b>() system call combines the functionality of <b>readv</b>() and<br>       pread(2).  It performs the same task as <b>readv</b>(), but adds a fourth<br>       argument, <i>offset</i>, which specifies the file offset at which the input<br>       operation is to be performed.<br><br>       The <b>pwritev</b>() system call combines the functionality of <b>writev</b>() and<br>       pwrite(2).  It performs the same task as <b>writev</b>(), but adds a fourth<br>       argument, <i>offset</i>, which specifies the file offset at which the output<br>       operation is to be performed.<br><br>       The file offset is not changed by these system calls.  The file<br>       referred to by <i>fd</i> must be capable of seeking.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>readv</b>() and <b>preadv</b>() return the number of bytes read;<br>       <b>writev</b>() and <b>pwritev</b>() return the number of bytes written.<br><br>       Note that is not an error for a successful call to transfer fewer<br>       bytes than requested (see read(2) and write(2)).<br><br>       On error, -1 is returned, and <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       The errors are as given for read(2) and write(2).  Furthermore,<br>       <b>preadv</b>() and <b>pwritev</b>() can also fail for the same reasons as<br>       lseek(2).  Additionally, the following error is defined:<br><br>       <b>EINVAL </b>The sum of the <i>iov_len</i> values overflows an <i>ssize_t</i> value.<br><br>       <b>EINVAL </b>The vector count <i>iovcnt</i> is less than zero or greater than the<br>              permitted maximum.<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>preadv</b>() and <b>pwritev</b>() first appeared in Linux 2.6.30; library<br>       support was added in glibc 2.10.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>readv</b>(), <b>writev</b>(): POSIX.1-2001, POSIX.1-2008, 4.4BSD (these system<br>       calls first appeared in 4.2BSD).<br><br>       <b>preadv</b>(), <b>pwritev</b>(): nonstandard, but present also on the modern<br>       BSDs.<br></pre><br><h2>NOTES  </h2><pre><br>       POSIX.1 allows an implementation to place a limit on the number of<br>       items that can be passed in <i>iov</i>.  An implementation can advertise its<br>       limit by defining <b>IOV_MAX </b>in <i>&lt;limits.h&gt;</i> or at run time via the return<br>       value from <i>sysconf(_SC_IOV_MAX)</i>.  On modern Linux systems, the limit<br>       is 1024.  Back in Linux 2.0 days, this limit was 16.<br><br>   <b>C library/kernel differences</b><br>       The raw <b>preadv</b>() and <b>pwritev</b>() system calls have call signatures that<br>       differ slightly from that of the corresponding GNU C library wrapper<br>       functions shown in the SYNOPSIS.  The final argument, <i>offset</i>, is<br>       unpacked by the wrapper functions into two arguments in the system<br>       calls:<br><br>           <b>unsigned long </b><i>pos_l</i><b>, unsigned long </b><i>pos</i><br><br>       These arguments contain, respectively, the low order and high order<br>       32 bits of <i>offset</i>.<br><br>   <b>Historical C library/kernel differences</b><br>       To deal with the fact that <b>IOV_MAX </b>was so low on early versions of<br>       Linux, the glibc wrapper functions for <b>readv</b>() and <b>writev</b>() did some<br>       extra work if they detected that the underlying kernel system call<br>       failed because this limit was exceeded.  In the case of <b>readv</b>(), the<br>       wrapper function allocated a temporary buffer large enough for all of<br>       the items specified by <i>iov</i>, passed that buffer in a call to read(2),<br>       copied data from the buffer to the locations specified by the<br>       <i>iov_base</i> fields of the elements of <i>iov</i>, and then freed the buffer.<br>       The wrapper function for <b>writev</b>() performed the analogous task using<br>       a temporary buffer and a call to write(2).<br><br>       The need for this extra effort in the glibc wrapper functions went<br>       away with Linux 2.2 and later.  However, glibc continued to provide<br>       this behavior until version 2.10.  Starting with glibc version 2.9,<br>       the wrapper functions provide this behavior only if the library<br>       detects that the system is running a Linux kernel older than version<br>       2.6.18 (an arbitrarily selected kernel version).  And since glibc<br>       2.20 (which requires a minimum Linux kernel version of 2.6.32), the<br>       glibc wrapper functions always just directly invoke the system calls.<br><br>       It is not advisable to mix calls to <b>readv</b>() or <b>writev</b>(), which<br>       operate on file descriptors, with the functions from the stdio<br>       library; the results will be undefined and probably not what you<br>       want.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The following code sample demonstrates the use of <b>writev</b>():<br><br>           char *str0 = \"hello \";<br>           char *str1 = \"world\\n\";<br>           struct iovec iov[2];<br>           ssize_t nwritten;<br><br>           iov[0].iov_base = str0;<br>           iov[0].iov_len = strlen(str0);<br>           iov[1].iov_base = str1;<br>           iov[1].iov_len = strlen(str1);<br><br>           nwritten = writev(STDOUT_FILENO, iov, 2);<br></pre><br><h2>SEE ALSO  </h2><pre><br>       pread(2), read(2), write(2)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                         READV(2)</span><br></pre><br>"}