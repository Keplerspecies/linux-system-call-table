{"Man page": "<pre><br><span class=\"headline\">REQUEST_KEY(2)           Linux Key Management Calls           REQUEST_KEY(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       request_key - request a key from the kernel's key management facility<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;keyutils.h&gt;</b><br><br>       <b>key_serial_t request_key(const char *</b><i>type</i><b>, const char *</b><i>description</i><b>,</b><br>                                <b>const char *</b><i>callout_info</i><b>,</b><br>                                <b>key_serial_t </b><i>keyring</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>request_key</b>() asks the kernel to find a key of the given <i>type</i> that<br>       matches the specified <i>description</i> and, if successful, to attach it to<br>       the nominated <i>keyring</i> and to return its serial number.<br><br>       <b>request_key</b>() first recursively searches all the keyrings attached to<br>       the calling process in the order thread-specific keyring, process-<br>       specific keyring and then session keyring for a matching key.<br><br>       If <b>request_key</b>() is called from a program invoked by <b>request_key</b>() on<br>       behalf of some other process to generate a key, then the keyrings of<br>       that other process will be searched next, using that other process's<br>       UID, GID, groups, and security context to control access.<br><br>       The keys in each keyring searched are checked for a match before any<br>       child keyrings are recursed into.  Only keys that are <b>searchable </b>for<br>       the caller may be found, and only <b>searchable </b>keyrings may be<br>       searched.<br><br>       If the key is not found, then, if <i>callout_info</i> is set, this function<br>       will attempt to look further afield.  In such a case, the<br>       <i>callout_info</i> is passed to a user-space service such as<br>       <b>/sbin/request-key </b>to generate the key.<br><br>       If that is unsuccessful also, then an error will be returned, and a<br>       temporary negative key will be installed in the nominated <i>keyring</i>.<br>       This will expire after a few seconds, but will cause subsequent calls<br>       to <b>request_key</b>() to fail until it does.<br><br>       The <i>keyring</i> serial number may be that of a valid keyring to which the<br>       caller has write permission, or it may be a special keyring ID:<br><br>       <b>KEY_SPEC_THREAD_KEYRING</b><br>              This specifies the caller's thread-specific keyring.<br><br>       <b>KEY_SPEC_PROCESS_KEYRING</b><br>              This specifies the caller's process-specific keyring.<br><br>       <b>KEY_SPEC_SESSION_KEYRING</b><br>              This specifies the caller's session-specific keyring.<br><br>       <b>KEY_SPEC_USER_KEYRING</b><br>              This specifies the caller's UID-specific keyring.<br><br>       <b>KEY_SPEC_USER_SESSION_KEYRING</b><br>              This specifies the caller's UID-session keyring.<br><br>       If a key is created, no matter whether it's a valid key or a negative<br>       key, it will displace any other key of the same type and description<br>       from the destination <i>keyring</i>.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success <b>request_key</b>() returns the serial number of the key it<br>       found.  On error, the value -1 will be returned and errno will have<br>       been set to an appropriate error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EACCES </b>The keyring wasn't available for modification by the user.<br><br>       <b>EINTR  </b>The request was interrupted by a signal.<br><br>       <b>EDQUOT </b>The key quota for this user would be exceeded by creating this<br>              key or linking it to the keyring.<br><br>       <b>EKEYEXPIRED</b><br>              An expired key was found, but no replacement could be<br>              obtained.<br><br>       <b>EKEYREJECTED</b><br>              The attempt to generate a new key was rejected.<br><br>       <b>EKEYREVOKED</b><br>              A revoked key was found, but no replacement could be obtained.<br><br>       <b>ENOMEM </b>Insufficient memory to create a key.<br><br>       <b>ENOKEY </b>No matching key was found.<br></pre><br><h2>LINKING  </h2><pre><br>       Although this is a Linux system call, it is not present in <i>libc</i> but<br>       can be found rather in <i>libkeyutils</i>.  When linking, <b>-lkeyutils </b>should<br>       be specified to the linker.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       keyctl(1), add_key(2), keyctl(2), keyctl(3), keyrings(7),<br>       request-key(8)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-05-07                   REQUEST_KEY(2)</span><br></pre><br>"}