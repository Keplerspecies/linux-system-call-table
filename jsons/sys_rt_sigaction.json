{"Man page": "<pre><br><span class=\"headline\">SIGACTION(2)              Linux Programmer's Manual             SIGACTION(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       sigaction, rt_sigaction - examine and change a signal action<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;signal.h&gt;</b><br><br>       <b>int sigaction(int </b><i>signum</i><b>, const struct sigaction *</b><i>act</i><b>,</b><br>                     <b>struct sigaction *</b><i>oldact</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>sigaction</b>(): _POSIX_C_SOURCE &gt;= 1 || _XOPEN_SOURCE || _POSIX_SOURCE<br><br>       <i>siginfo_t</i>: _POSIX_C_SOURCE &gt;= 199309L<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>sigaction</b>() system call is used to change the action taken by a<br>       process on receipt of a specific signal.  (See signal(7) for an<br>       overview of signals.)<br><br>       <i>signum</i> specifies the signal and can be any valid signal except<br>       <b>SIGKILL </b>and <b>SIGSTOP</b>.<br><br>       If <i>act</i> is non-NULL, the new action for signal <i>signum</i> is installed<br>       from <i>act</i>.  If <i>oldact</i> is non-NULL, the previous action is saved in<br>       <i>oldact</i>.<br><br>       The <i>sigaction</i> structure is defined as something like:<br><br>           struct sigaction {<br>               void     (*sa_handler)(int);<br>               void     (*sa_sigaction)(int, siginfo_t *, void *);<br>               sigset_t   sa_mask;<br>               int        sa_flags;<br>               void     (*sa_restorer)(void);<br>           };<br><br>       On some architectures a union is involved: do not assign to both<br>       <i>sa_handler</i> and <i>sa_sigaction</i>.<br><br>       The <i>sa_restorer</i> field is not intended for application use.  (POSIX<br>       does not specify a <i>sa_restorer</i> field.)  Some further details of<br>       purpose of this field can be found in sigreturn(2).<br><br>       <i>sa_handler</i> specifies the action to be associated with <i>signum</i> and may<br>       be <b>SIG_DFL </b>for the default action, <b>SIG_IGN </b>to ignore this signal, or<br>       a pointer to a signal handling function.  This function receives the<br>       signal number as its only argument.<br><br>       If <b>SA_SIGINFO </b>is specified in <i>sa_flags</i>, then <i>sa_sigaction</i> (instead of<br>       <i>sa_handler</i>) specifies the signal-handling function for <i>signum</i>.  This<br>       function receives the signal number as its first argument, a pointer<br>       to a <i>siginfo_t</i> as its second argument and a pointer to a <i>ucontext_t</i><br>       (cast to <i>void *</i>) as its third argument.  (Commonly, the handler<br>       function doesn't make any use of the third argument.  See<br>       getcontext(3) for further information about <i>ucontext_t</i>.)<br><br>       <i>sa_mask</i> specifies a mask of signals which should be blocked (i.e.,<br>       added to the signal mask of the thread in which the signal handler is<br>       invoked) during execution of the signal handler.  In addition, the<br>       signal which triggered the handler will be blocked, unless the<br>       <b>SA_NODEFER </b>flag is used.<br><br>       <i>sa_flags</i> specifies a set of flags which modify the behavior of the<br>       signal.  It is formed by the bitwise OR of zero or more of the<br>       following:<br><br>           <b>SA_NOCLDSTOP</b><br>                  If <i>signum</i> is <b>SIGCHLD</b>, do not receive notification when<br>                  child processes stop (i.e., when they receive one of<br>                  <b>SIGSTOP</b>, <b>SIGTSTP</b>, <b>SIGTTIN</b>, or <b>SIGTTOU</b>) or resume (i.e.,<br>                  they receive <b>SIGCONT</b>) (see wait(2)).  This flag is<br>                  meaningful only when establishing a handler for <b>SIGCHLD</b>.<br><br>           <b>SA_NOCLDWAIT </b>(since Linux 2.6)<br>                  If <i>signum</i> is <b>SIGCHLD</b>, do not transform children into<br>                  zombies when they terminate.  See also waitpid(2).  This<br>                  flag is meaningful only when establishing a handler for<br>                  <b>SIGCHLD</b>, or when setting that signal's disposition to<br>                  <b>SIG_DFL</b>.<br><br>                  If the <b>SA_NOCLDWAIT </b>flag is set when establishing a<br>                  handler for <b>SIGCHLD</b>, POSIX.1 leaves it unspecified whether<br>                  a <b>SIGCHLD </b>signal is generated when a child process<br>                  terminates.  On Linux, a <b>SIGCHLD </b>signal is generated in<br>                  this case; on some other implementations, it is not.<br><br>           <b>SA_NODEFER</b><br>                  Do not prevent the signal from being received from within<br>                  its own signal handler.  This flag is meaningful only when<br>                  establishing a signal handler.  <b>SA_NOMASK </b>is an obsolete,<br>                  nonstandard synonym for this flag.<br><br>           <b>SA_ONSTACK</b><br>                  Call the signal handler on an alternate signal stack<br>                  provided by sigaltstack(2).  If an alternate stack is not<br>                  available, the default stack will be used.  This flag is<br>                  meaningful only when establishing a signal handler.<br><br>           <b>SA_RESETHAND</b><br>                  Restore the signal action to the default upon entry to the<br>                  signal handler.  This flag is meaningful only when<br>                  establishing a signal handler.  <b>SA_ONESHOT </b>is an obsolete,<br>                  nonstandard synonym for this flag.<br><br>           <b>SA_RESTART</b><br>                  Provide behavior compatible with BSD signal semantics by<br>                  making certain system calls restartable across signals.<br>                  This flag is meaningful only when establishing a signal<br>                  handler.  See signal(7) for a discussion of system call<br>                  restarting.<br><br>           <b>SA_RESTORER</b><br>                  <i>Not intended for application use</i>.  This flag is used by C<br>                  libraries to indicate that the <i>sa_restorer</i> field contains<br>                  the address of a \"signal trampoline\".  See sigreturn(2)<br>                  for more details.<br><br>           <b>SA_SIGINFO </b>(since Linux 2.2)<br>                  The signal handler takes three arguments, not one.  In<br>                  this case, <i>sa_sigaction</i> should be set instead of<br>                  <i>sa_handler</i>.  This flag is meaningful only when<br>                  establishing a signal handler.<br><br>       The <i>siginfo_t</i> argument to <i>sa_sigaction</i> is a struct with the following<br>       fields:<br><br>           siginfo_t {<br>               int      si_signo;     /* Signal number */<br>               int      si_errno;     /* An errno value */<br>               int      si_code;      /* Signal code */<br>               int      si_trapno;    /* Trap number that caused<br>                                         hardware-generated signal<br>                                         (unused on most architectures) */<br>               pid_t    si_pid;       /* Sending process ID */<br>               uid_t    si_uid;       /* Real user ID of sending process */<br>               int      si_status;    /* Exit value or signal */<br>               clock_t  si_utime;     /* User time consumed */<br>               clock_t  si_stime;     /* System time consumed */<br>               sigval_t si_value;     /* Signal value */<br>               int      si_int;       /* POSIX.1b signal */<br>               void    *si_ptr;       /* POSIX.1b signal */<br>               int      si_overrun;   /* Timer overrun count;<br>                                         POSIX.1b timers */<br>               int      si_timerid;   /* Timer ID; POSIX.1b timers */<br>               void    *si_addr;      /* Memory location which caused fault */<br>               long     si_band;      /* Band event (was <i>int</i> in<br>                                         glibc 2.3.2 and earlier) */<br>               int      si_fd;        /* File descriptor */<br>               short    si_addr_lsb;  /* Least significant bit of address<br>                                         (since Linux 2.6.32) */<br>               void    *si_call_addr; /* Address of system call instruction<br>                                         (since Linux 3.5) */<br>               int      si_syscall;   /* Number of attempted system call<br>                                         (since Linux 3.5) */<br>               unsigned int si_arch;  /* Architecture of attempted system call<br>                                         (since Linux 3.5) */<br>           }<br><br>       <i>si_signo</i>, <i>si_errno</i> and <i>si_code</i> are defined for all signals.<br>       (<i>si_errno</i> is generally unused on Linux.)  The rest of the struct may<br>       be a union, so that one should read only the fields that are<br>       meaningful for the given signal:<br><br>       * Signals sent with kill(2) and sigqueue(3) fill in <i>si_pid</i> and<br>         <i>si_uid</i>.  In addition, signals sent with sigqueue(3) fill in <i>si_int</i><br>         and <i>si_ptr</i> with the values specified by the sender of the signal;<br>         see sigqueue(3) for more details.<br><br>       * Signals sent by POSIX.1b timers (since Linux 2.6) fill in<br>         <i>si_overrun</i> and <i>si_timerid</i>.  The <i>si_timerid</i> field is an internal ID<br>         used by the kernel to identify the timer; it is not the same as the<br>         timer ID returned by timer_create(2).  The <i>si_overrun</i> field is the<br>         timer overrun count; this is the same information as is obtained by<br>         a call to timer_getoverrun(2).  These fields are nonstandard Linux<br>         extensions.<br><br>       * Signals sent for message queue notification (see the description of<br>         <b>SIGEV_SIGNAL </b>in mq_notify(3)) fill in <i>si_int</i>/<i>si_ptr</i>, with the<br>         <i>sigev_value</i> supplied to mq_notify(3); <i>si_pid</i>, with the process ID<br>         of the message sender; and <i>si_uid</i>, with the real user ID of the<br>         message sender.<br><br>       * <b>SIGCHLD </b>fills in <i>si_pid</i>, <i>si_uid</i>, <i>si_status</i>, <i>si_utime</i>, and <i>si_stime</i>,<br>         providing information about the child.  The <i>si_pid</i> field is the<br>         process ID of the child; <i>si_uid</i> is the child's real user ID.  The<br>         <i>si_status</i> field contains the exit status of the child (if <i>si_code</i><br>         is <b>CLD_EXITED</b>), or the signal number that caused the process to<br>         change state.  The <i>si_utime</i> and <i>si_stime</i> contain the user and<br>         system CPU time used by the child process; these fields do not<br>         include the times used by waited-for children (unlike getrusage(2)<br>         and times(2)).  In kernels up to 2.6, and since 2.6.27, these<br>         fields report CPU time in units of <i>sysconf(_SC_CLK_TCK)</i>.  In 2.6<br>         kernels before 2.6.27, a bug meant that these fields reported time<br>         in units of the (configurable) system jiffy (see time(7)).<br><br>       * <b>SIGILL</b>, <b>SIGFPE</b>, <b>SIGSEGV</b>, <b>SIGBUS</b>, and <b>SIGTRAP </b>fill in <i>si_addr</i> with<br>         the address of the fault.  On some architectures, these signals<br>         also fill in the <i>si_trapno</i> field.  Some suberrors of <b>SIGBUS</b>, in<br>         particular <b>BUS_MCEERR_AO </b>and <b>BUS_MCEERR_AR</b>, also fill in<br>         <i>si_addr_lsb</i>.  This field indicates the least significant bit of the<br>         reported address and therefore the extent of the corruption.  For<br>         example, if a full page was corrupted, <i>si_addr_lsb</i> contains<br>         <i>log2(sysconf(_SC_PAGESIZE))</i>.  When <b>SIGTRAP </b>is delivered in response<br>         to a ptrace(2) event (PTRACE_EVENT_foo), <i>si_addr</i> is not populated,<br>         but <i>si_pid</i> and <i>si_uid</i> are populated with the respective process ID<br>         and user ID responsible for delivering the trap.  In the case of<br>         seccomp(2), the tracee will be shown as delivering the event.<br>         <b>BUS_MCEERR_* </b>and <i>si_addr_lsb</i> are Linux-specific extensions.<br><br>       * <b>SIGIO</b>/<b>SIGPOLL </b>(the two names are synonyms on Linux) fills in<br>         <i>si_band</i> and <i>si_fd</i>.  The <i>si_band</i> event is a bit mask containing the<br>         same values as are filled in the <i>revents</i> field by poll(2).  The<br>         <i>si_fd</i> field indicates the file descriptor for which the I/O event<br>         occurred; for further details, see the description of <b>F_SETSIG </b>in<br>         fcntl(2).<br><br>       * <b>SIGSYS</b>, generated (since Linux 3.5) when a seccomp filter returns<br>         <b>SECCOMP_RET_TRAP</b>, fills in <i>si_call_addr</i>, <i>si_syscall</i>, <i>si_arch</i>,<br>         <i>si_errno</i>, and other fields as described in seccomp(2).<br><br>       <i>si_code</i> is a value (not a bit mask) indicating why this signal was<br>       sent.  For a ptrace(2) event, <i>si_code</i> will contain <b>SIGTRAP </b>and have<br>       the ptrace event in the high byte:<br><br>           (SIGTRAP | PTRACE_EVENT_foo &lt;&lt; 8).<br><br>       For a regular signal, the following list shows the values which can<br>       be placed in <i>si_code</i> for any signal, along with reason that the<br>       signal was generated.<br><br>           <b>SI_USER</b><br>                  kill(2).<br><br>           <b>SI_KERNEL</b><br>                  Sent by the kernel.<br><br>           <b>SI_QUEUE</b><br>                  sigqueue(3).<br><br>           <b>SI_TIMER</b><br>                  POSIX timer expired.<br><br>           <b>SI_MESGQ </b>(since Linux 2.6.6)<br>                  POSIX message queue state changed; see mq_notify(3).<br><br>           <b>SI_ASYNCIO</b><br>                  AIO completed.<br><br>           <b>SI_SIGIO</b><br>                  Queued <b>SIGIO </b>(only in kernels up to Linux 2.2; from Linux<br>                  2.4 onward <b>SIGIO</b>/<b>SIGPOLL </b>fills in <i>si_code</i> as described<br>                  below).<br><br>           <b>SI_TKILL </b>(since Linux 2.4.19)<br>                  tkill(2) or tgkill(2).<br><br>       The following values can be placed in <i>si_code</i> for a <b>SIGILL </b>signal:<br><br>           <b>ILL_ILLOPC</b><br>                  Illegal opcode.<br><br>           <b>ILL_ILLOPN</b><br>                  Illegal operand.<br><br>           <b>ILL_ILLADR</b><br>                  Illegal addressing mode.<br><br>           <b>ILL_ILLTRP</b><br>                  Illegal trap.<br><br>           <b>ILL_PRVOPC</b><br>                  Privileged opcode.<br><br>           <b>ILL_PRVREG</b><br>                  Privileged register.<br><br>           <b>ILL_COPROC</b><br>                  Coprocessor error.<br><br>           <b>ILL_BADSTK</b><br>                  Internal stack error.<br><br>       The following values can be placed in <i>si_code</i> for a <b>SIGFPE </b>signal:<br><br>           <b>FPE_INTDIV</b><br>                  Integer divide by zero.<br><br>           <b>FPE_INTOVF</b><br>                  Integer overflow.<br><br>           <b>FPE_FLTDIV</b><br>                  Floating-point divide by zero.<br><br>           <b>FPE_FLTOVF</b><br>                  Floating-point overflow.<br><br>           <b>FPE_FLTUND</b><br>                  Floating-point underflow.<br><br>           <b>FPE_FLTRES</b><br>                  Floating-point inexact result.<br><br>           <b>FPE_FLTINV</b><br>                  Floating-point invalid operation.<br><br>           <b>FPE_FLTSUB</b><br>                  Subscript out of range.<br><br>       The following values can be placed in <i>si_code</i> for a <b>SIGSEGV </b>signal:<br><br>           <b>SEGV_MAPERR</b><br>                  Address not mapped to object.<br><br>           <b>SEGV_ACCERR</b><br>                  Invalid permissions for mapped object.<br><br>       The following values can be placed in <i>si_code</i> for a <b>SIGBUS </b>signal:<br><br>           <b>BUS_ADRALN</b><br>                  Invalid address alignment.<br><br>           <b>BUS_ADRERR</b><br>                  Nonexistent physical address.<br><br>           <b>BUS_OBJERR</b><br>                  Object-specific hardware error.<br><br>           <b>BUS_MCEERR_AR </b>(since Linux 2.6.32)<br>                  Hardware memory error consumed on a machine check; action<br>                  required.<br><br>           <b>BUS_MCEERR_AO </b>(since Linux 2.6.32)<br>                  Hardware memory error detected in process but not<br>                  consumed; action optional.<br><br>       The following values can be placed in <i>si_code</i> for a <b>SIGTRAP </b>signal:<br><br>           <b>TRAP_BRKPT</b><br>                  Process breakpoint.<br><br>           <b>TRAP_TRACE</b><br>                  Process trace trap.<br><br>           <b>TRAP_BRANCH </b>(since Linux 2.4)<br>                  Process taken branch trap.<br><br>           <b>TRAP_HWBKPT </b>(since Linux 2.4)<br>                  Hardware breakpoint/watchpoint.<br><br>       The following values can be placed in <i>si_code</i> for a <b>SIGCHLD </b>signal:<br><br>           <b>CLD_EXITED</b><br>                  Child has exited.<br><br>           <b>CLD_KILLED</b><br>                  Child was killed.<br><br>           <b>CLD_DUMPED</b><br>                  Child terminated abnormally.<br><br>           <b>CLD_TRAPPED</b><br>                  Traced child has trapped.<br><br>           <b>CLD_STOPPED</b><br>                  Child has stopped.<br><br>           <b>CLD_CONTINUED </b>(since Linux 2.6.9)<br>                  Stopped child has continued.<br><br>       The following values can be placed in <i>si_code</i> for a <b>SIGIO</b>/<b>SIGPOLL</b><br>       signal:<br><br>           <b>POLL_IN</b><br>                  Data input available.<br><br>           <b>POLL_OUT</b><br>                  Output buffers available.<br><br>           <b>POLL_MSG</b><br>                  Input message available.<br><br>           <b>POLL_ERR</b><br>                  I/O error.<br><br>           <b>POLL_PRI</b><br>                  High priority input available.<br><br>           <b>POLL_HUP</b><br>                  Device disconnected.<br><br>       The following value can be placed in <i>si_code</i> for a <b>SIGSYS </b>signal:<br><br>           <b>SYS_SECCOMP </b>(since Linux 3.5)<br>                  Triggered by a seccomp(2) filter rule.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       <b>sigaction</b>() returns 0 on success; on error, -1 is returned, and <i>errno</i><br>       is set to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EFAULT </b><i>act</i> or <i>oldact</i> points to memory which is not a valid part of<br>              the process address space.<br><br>       <b>EINVAL </b>An invalid signal was specified.  This will also be generated<br>              if an attempt is made to change the action for <b>SIGKILL </b>or<br>              <b>SIGSTOP</b>, which cannot be caught or ignored.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008, SVr4.<br></pre><br><h2>NOTES  </h2><pre><br>       A child created via fork(2) inherits a copy of its parent's signal<br>       dispositions.  During an execve(2), the dispositions of handled<br>       signals are reset to the default; the dispositions of ignored signals<br>       are left unchanged.<br><br>       According to POSIX, the behavior of a process is undefined after it<br>       ignores a <b>SIGFPE</b>, <b>SIGILL</b>, or <b>SIGSEGV </b>signal that was not generated by<br>       kill(2) or raise(3).  Integer division by zero has undefined result.<br>       On some architectures it will generate a <b>SIGFPE </b>signal.  (Also<br>       dividing the most negative integer by -1 may generate <b>SIGFPE</b>.)<br>       Ignoring this signal might lead to an endless loop.<br><br>       POSIX.1-1990 disallowed setting the action for <b>SIGCHLD </b>to <b>SIG_IGN</b>.<br>       POSIX.1-2001 and later allow this possibility, so that ignoring<br>       <b>SIGCHLD </b>can be used to prevent the creation of zombies (see wait(2)).<br>       Nevertheless, the historical BSD and System V behaviors for ignoring<br>       <b>SIGCHLD </b>differ, so that the only completely portable method of<br>       ensuring that terminated children do not become zombies is to catch<br>       the <b>SIGCHLD </b>signal and perform a wait(2) or similar.<br><br>       POSIX.1-1990 specified only <b>SA_NOCLDSTOP</b>.  POSIX.1-2001 added<br>       <b>SA_NOCLDSTOP</b>, <b>SA_NOCLDWAIT</b>, <b>SA_NODEFER</b>, <b>SA_ONSTACK</b>, <b>SA_RESETHAND</b>,<br>       <b>SA_RESTART</b>, and <b>SA_SIGINFO</b>.  Use of these latter values in <i>sa_flags</i><br>       may be less portable in applications intended for older UNIX<br>       implementations.<br><br>       The <b>SA_RESETHAND </b>flag is compatible with the SVr4 flag of the same<br>       name.<br><br>       The <b>SA_NODEFER </b>flag is compatible with the SVr4 flag of the same name<br>       under kernels 1.3.9 and newer.  On older kernels the Linux<br>       implementation allowed the receipt of any signal, not just the one we<br>       are installing (effectively overriding any <i>sa_mask</i> settings).<br><br>       <b>sigaction</b>() can be called with a NULL second argument to query the<br>       current signal handler.  It can also be used to check whether a given<br>       signal is valid for the current machine by calling it with NULL<br>       second and third arguments.<br><br>       It is not possible to block <b>SIGKILL </b>or <b>SIGSTOP </b>(by specifying them in<br>       <i>sa_mask</i>).  Attempts to do so are silently ignored.<br><br>       See sigsetops(3) for details on manipulating signal sets.<br><br>       See signal(7) for a list of the async-signal-safe functions that can<br>       be safely called inside from inside a signal handler.<br><br>   <b>C library/kernel differences</b><br>       The glibc wrapper function for <b>sigaction</b>() gives an error (<b>EINVAL</b>) on<br>       attempts to change the disposition of the two real-time signals used<br>       internally by the NPTL threading implementation.  See nptl(7) for<br>       details.<br><br>       The original Linux system call was named <b>sigaction</b>().  However, with<br>       the addition of real-time signals in Linux 2.2, the fixed-size,<br>       32-bit <i>sigset_t</i> type supported by that system call was no longer fit<br>       for purpose.  Consequently, a new system call, <b>rt_sigaction</b>(), was<br>       added to support an enlarged <i>sigset_t</i> type.  The new system call<br>       takes a fourth argument, <i>size_t sigsetsize</i>, which specifies the size<br>       in bytes of the signal sets in <i>act.sa_mask</i> and <i>oldact.sa_mask</i>.  This<br>       argument is currently required to have the value <i>sizeof(sigset_t)</i> (or<br>       the error <b>EINVAL </b>results).  The glibc <b>sigaction</b>() wrapper function<br>       hides these details from us, transparently calling <b>rt_sigaction</b>()<br>       when the kernel provides it.<br><br>   <b>Undocumented</b><br>       Before the introduction of <b>SA_SIGINFO</b>, it was also possible to get<br>       some additional information, namely by using a <i>sa_handler</i> with second<br>       argument of type <i>struct sigcontext</i>.  See the relevant Linux kernel<br>       sources for details.  This use is obsolete now.<br></pre><br><h2>BUGS  </h2><pre><br>       In kernels up to and including 2.6.13, specifying <b>SA_NODEFER </b>in<br>       <i>sa_flags</i> prevents not only the delivered signal from being masked<br>       during execution of the handler, but also the signals specified in<br>       <i>sa_mask</i>.  This bug was fixed in kernel 2.6.14.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       See mprotect(2).<br></pre><br><h2>SEE ALSO  </h2><pre><br>       kill(1), kill(2), killpg(2), pause(2), restart_syscall(2), seccomp(2)<br>       sigaltstack(2), signal(2), signalfd(2), sigpending(2), sigreturn(2),<br>       sigprocmask(2), sigsuspend(2), wait(2), raise(3), siginterrupt(3),<br>       sigqueue(3), sigsetops(3), sigvec(3), core(5), signal(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-08-08                     SIGACTION(2)</span><br></pre><br>"}