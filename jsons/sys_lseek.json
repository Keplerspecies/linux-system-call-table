{"Man page": "<pre><br><span class=\"headline\">LSEEK(2)                  Linux Programmer's Manual                 LSEEK(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       lseek - reposition read/write file offset<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/types.h&gt;</b><br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>off_t lseek(int </b><i>fd</i><b>, off_t </b><i>offset</i><b>, int </b><i>whence</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>lseek</b>() function repositions the offset of the open file<br>       associated with the file descriptor <i>fd</i> to the argument <i>offset</i><br>       according to the directive <i>whence</i> as follows:<br><br>       <b>SEEK_SET</b><br>              The offset is set to <i>offset</i> bytes.<br><br>       <b>SEEK_CUR</b><br>              The offset is set to its current location plus <i>offset</i> bytes.<br><br>       <b>SEEK_END</b><br>              The offset is set to the size of the file plus <i>offset</i> bytes.<br><br>       The <b>lseek</b>() function allows the file offset to be set beyond the end<br>       of the file (but this does not change the size of the file).  If data<br>       is later written at this point, subsequent reads of the data in the<br>       gap (a \"hole\") return null bytes ('\\0') until data is actually<br>       written into the gap.<br><br>   <b>Seeking file data and holes</b><br>       Since version 3.1, Linux supports the following additional values for<br>       <i>whence</i>:<br><br>       <b>SEEK_DATA</b><br>              Adjust the file offset to the next location in the file<br>              greater than or equal to <i>offset</i> containing data.  If <i>offset</i><br>              points to data, then the file offset is set to <i>offset</i>.<br><br>       <b>SEEK_HOLE</b><br>              Adjust the file offset to the next hole in the file greater<br>              than or equal to <i>offset</i>.  If <i>offset</i> points into the middle of<br>              a hole, then the file offset is set to <i>offset</i>.  If there is no<br>              hole past <i>offset</i>, then the file offset is adjusted to the end<br>              of the file (i.e., there is an implicit hole at the end of any<br>              file).<br><br>       In both of the above cases, <b>lseek</b>() fails if <i>offset</i> points past the<br>       end of the file.<br><br>       These operations allow applications to map holes in a sparsely<br>       allocated file.  This can be useful for applications such as file<br>       backup tools, which can save space when creating backups and preserve<br>       holes, if they have a mechanism for discovering holes.<br><br>       For the purposes of these operations, a hole is a sequence of zeros<br>       that (normally) has not been allocated in the underlying file<br>       storage.  However, a filesystem is not obliged to report holes, so<br>       these operations are not a guaranteed mechanism for mapping the<br>       storage space actually allocated to a file.  (Furthermore, a sequence<br>       of zeros that actually has been written to the underlying storage may<br>       not be reported as a hole.)  In the simplest implementation, a<br>       filesystem can support the operations by making <b>SEEK_HOLE </b>always<br>       return the offset of the end of the file, and making <b>SEEK_DATA </b>always<br>       return <i>offset</i> (i.e., even if the location referred to by <i>offset</i> is a<br>       hole, it can be considered to consist of data that is a sequence of<br>       zeros).<br><br>       The <b>_GNU_SOURCE </b>feature test macro must be defined in order to obtain<br>       the definitions of <b>SEEK_DATA </b>and <b>SEEK_HOLE </b>from <i>&lt;unistd.h&gt;</i>.<br><br>       The <b>SEEK_HOLE </b>and <b>SEEK_DATA </b>operations are supported for the<br>       following filesystems:<br><br>       *  Btrfs (since Linux 3.1)<br><br>       *  OCFS (since Linux 3.2)<br><br>       *  XFS (since Linux 3.5)<br><br>       *  ext4 (since Linux 3.8)<br><br>       *  tmpfs (since Linux 3.8)<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       Upon successful completion, <b>lseek</b>() returns the resulting offset<br>       location as measured in bytes from the beginning of the file.  On<br>       error, the value <i>(off_t) -1</i> is returned and <i>errno</i> is set to indicate<br>       the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EBADF  </b><i>fd</i> is not an open file descriptor.<br><br>       <b>EINVAL </b><i>whence</i> is not valid.  Or: the resulting file offset would be<br>              negative, or beyond the end of a seekable device.<br><br>       <b>EOVERFLOW</b><br>              The resulting file offset cannot be represented in an <i>off_t</i>.<br><br>       <b>ESPIPE </b><i>fd</i> is associated with a pipe, socket, or FIFO.<br><br>       <b>ENXIO  </b><i>whence</i> is <b>SEEK_DATA </b>or <b>SEEK_HOLE</b>, and the current file offset<br>              is beyond the end of the file.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.<br><br>       <b>SEEK_DATA </b>and <b>SEEK_HOLE </b>are nonstandard extensions also present in<br>       Solaris, FreeBSD, and DragonFly BSD; they are proposed for inclusion<br>       in the next POSIX revision (Issue 8).<br></pre><br><h2>NOTES  </h2><pre><br>       See open(2) for a discussion of the relationship between file<br>       descriptors, open file descriptions, and files.<br><br>       Some devices are incapable of seeking and POSIX does not specify<br>       which devices must support <b>lseek</b>().<br><br>       On Linux, using <b>lseek</b>() on a terminal device returns <b>ESPIPE</b>.<br><br>       When converting old code, substitute values for <i>whence</i> with the<br>       following macros:<br><br>        old       new<br>       0        SEEK_SET<br>       1        SEEK_CUR<br>       2        SEEK_END<br>       L_SET    SEEK_SET<br><br>       L_INCR   SEEK_CUR<br>       L_XTND   SEEK_END<br><br>       Note that file descriptors created by dup(2) or fork(2) share the<br>       current file position pointer, so seeking on such files may be<br>       subject to race conditions.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       dup(2), fork(2), open(2), fseek(3), lseek64(3), posix_fallocate(3)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-08-08                         LSEEK(2)</span><br></pre><br>"}