{"Man page": "<pre><br><span class=\"headline\">TIMERFD_CREATE(2)         Linux Programmer's Manual        TIMERFD_CREATE(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       timerfd_create, timerfd_settime, timerfd_gettime - timers that notify<br>       via file descriptors<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/timerfd.h&gt;</b><br><br>       <b>int timerfd_create(int </b><i>clockid</i><b>, int </b><i>flags</i><b>);</b><br><br>       <b>int timerfd_settime(int </b><i>fd</i><b>, int </b><i>flags</i><b>,</b><br>                           <b>const struct itimerspec *</b><i>new_value</i><b>,</b><br>                           <b>struct itimerspec *</b><i>old_value</i><b>);</b><br><br>       <b>int timerfd_gettime(int </b><i>fd</i><b>, struct itimerspec *</b><i>curr_value</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       These system calls create and operate on a timer that delivers timer<br>       expiration notifications via a file descriptor.  They provide an<br>       alternative to the use of setitimer(2) or timer_create(2), with the<br>       advantage that the file descriptor may be monitored by select(2),<br>       poll(2), and epoll(7).<br><br>       The use of these three system calls is analogous to the use of<br>       timer_create(2), timer_settime(2), and timer_gettime(2).  (There is<br>       no analog of timer_getoverrun(2), since that functionality is<br>       provided by read(2), as described below.)<br><br>   <b>timerfd_create()</b><br>       <b>timerfd_create</b>() creates a new timer object, and returns a file<br>       descriptor that refers to that timer.  The <i>clockid</i> argument specifies<br>       the clock that is used to mark the progress of the timer, and must be<br>       either <b>CLOCK_REALTIME </b>or <b>CLOCK_MONOTONIC</b>.  <b>CLOCK_REALTIME </b>is a<br>       settable system-wide clock.  <b>CLOCK_MONOTONIC </b>is a nonsettable clock<br>       that is not affected by discontinuous changes in the system clock<br>       (e.g., manual changes to system time).  The current value of each of<br>       these clocks can be retrieved using clock_gettime(2).<br><br>       Starting with Linux 2.6.27, the following values may be bitwise ORed<br>       in <i>flags</i> to change the behavior of <b>timerfd_create</b>():<br><br>       <b>TFD_NONBLOCK  </b>Set the <b>O_NONBLOCK </b>file status flag on the new open<br>                     file description.  Using this flag saves extra calls to<br>                     fcntl(2) to achieve the same result.<br><br>       <b>TFD_CLOEXEC   </b>Set the close-on-exec (<b>FD_CLOEXEC</b>) flag on the new file<br>                     descriptor.  See the description of the <b>O_CLOEXEC </b>flag<br>                     in open(2) for reasons why this may be useful.<br><br>       In Linux versions up to and including 2.6.26, <i>flags</i> must be specified<br>       as zero.<br><br>   <b>timerfd_settime()</b><br>       <b>timerfd_settime</b>() arms (starts) or disarms (stops) the timer referred<br>       to by the file descriptor <i>fd</i>.<br><br>       The <i>new_value</i> argument specifies the initial expiration and interval<br>       for the timer.  The <i>itimer</i> structure used for this argument contains<br>       two fields, each of which is in turn a structure of type <i>timespec</i>:<br><br>           struct timespec {<br>               time_t tv_sec;                /* Seconds */<br>               long   tv_nsec;               /* Nanoseconds */<br>           };<br><br>           struct itimerspec {<br>               struct timespec it_interval;  /* Interval for periodic timer */<br>               struct timespec it_value;     /* Initial expiration */<br>           };<br><br>       <i>new_value.it_value</i> specifies the initial expiration of the timer, in<br>       seconds and nanoseconds.  Setting either field of <i>new_value.it_value</i><br>       to a nonzero value arms the timer.  Setting both fields of<br>       <i>new_value.it_value</i> to zero disarms the timer.<br><br>       Setting one or both fields of <i>new_value.it_interval</i> to nonzero values<br>       specifies the period, in seconds and nanoseconds, for repeated timer<br>       expirations after the initial expiration.  If both fields of<br>       <i>new_value.it_interval</i> are zero, the timer expires just once, at the<br>       time specified by <i>new_value.it_value</i>.<br><br>       The <i>flags</i> argument is either 0, to start a relative timer<br>       (<i>new_value.it_value</i> specifies a time relative to the current value of<br>       the clock specified by <i>clockid</i>), or <b>TFD_TIMER_ABSTIME</b>, to start an<br>       absolute timer (<i>new_value.it_value</i> specifies an absolute time for the<br>       clock specified by <i>clockid</i>; that is, the timer will expire when the<br>       value of that clock reaches the value specified in<br>       <i>new_value.it_value</i>).<br><br>       If the <i>old_value</i> argument is not NULL, then the <i>itimerspec</i> structure<br>       that it points to is used to return the setting of the timer that was<br>       current at the time of the call; see the description of<br>       <b>timerfd_gettime</b>() following.<br><br>   <b>timerfd_gettime()</b><br>       <b>timerfd_gettime</b>() returns, in <i>curr_value</i>, an <i>itimerspec</i> structure<br>       that contains the current setting of the timer referred to by the<br>       file descriptor <i>fd</i>.<br><br>       The <i>it_value</i> field returns the amount of time until the timer will<br>       next expire.  If both fields of this structure are zero, then the<br>       timer is currently disarmed.  This field always contains a relative<br>       value, regardless of whether the <b>TFD_TIMER_ABSTIME </b>flag was specified<br>       when setting the timer.<br><br>       The <i>it_interval</i> field returns the interval of the timer.  If both<br>       fields of this structure are zero, then the timer is set to expire<br>       just once, at the time specified by <i>curr_value.it_value</i>.<br><br>   <b>Operating on a timer file descriptor</b><br>       The file descriptor returned by <b>timerfd_create</b>() supports the<br>       following operations:<br><br>       read(2)<br>              If the timer has already expired one or more times since its<br>              settings were last modified using <b>timerfd_settime</b>(), or since<br>              the last successful read(2), then the buffer given to read(2)<br>              returns an unsigned 8-byte integer (<i>uint64_t</i>) containing the<br>              number of expirations that have occurred.  (The returned value<br>              is in host byte order&#8212;that is, the native byte order for<br>              integers on the host machine.)<br><br>              If no timer expirations have occurred at the time of the<br>              read(2), then the call either blocks until the next timer<br>              expiration, or fails with the error <b>EAGAIN </b>if the file<br>              descriptor has been made nonblocking (via the use of the<br>              fcntl(2) <b>F_SETFL </b>operation to set the <b>O_NONBLOCK </b>flag).<br><br>              A read(2) will fail with the error <b>EINVAL </b>if the size of the<br>              supplied buffer is less than 8 bytes.<br><br>       poll(2), select(2) (and similar)<br>              The file descriptor is readable (the select(2) <i>readfds</i><br>              argument; the poll(2) <b>POLLIN </b>flag) if one or more timer<br>              expirations have occurred.<br><br>              The file descriptor also supports the other file-descriptor<br>              multiplexing APIs: pselect(2), ppoll(2), and epoll(7).<br><br>       ioctl(2)<br>              The following timerfd-specific command is supported:<br><br>              <b>TFD_IOC_SET_TICKS </b>(since Linux 3.17)<br>                     Adjust the number of timer expirations that have<br>                     occurred.  The argument is a pointer to a nonzero<br>                     8-byte integer (<i>uint64_t</i>*) containing the new number of<br>                     expirations.  Once the number is set, any waiter on the<br>                     timer is woken up.  The only purpose of this command is<br>                     to restore the expirations for the purpose of<br>                     checkpoint/restore.  This operation is available only<br>                     if the kernel was configured with the<br>                     <b>CONFIG_CHECKPOINT_RESTORE </b>option.<br><br>       close(2)<br>              When the file descriptor is no longer required it should be<br>              closed.  When all file descriptors associated with the same<br>              timer object have been closed, the timer is disarmed and its<br>              resources are freed by the kernel.<br><br>   <b>fork(2) semantics</b><br>       After a fork(2), the child inherits a copy of the file descriptor<br>       created by <b>timerfd_create</b>().  The file descriptor refers to the same<br>       underlying timer object as the corresponding file descriptor in the<br>       parent, and read(2)s in the child will return information about<br>       expirations of the timer.<br><br>   <b>execve(2) semantics</b><br>       A file descriptor created by <b>timerfd_create</b>() is preserved across<br>       execve(2), and continues to generate timer expirations if the timer<br>       was armed.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>timerfd_create</b>() returns a new file descriptor.  On<br>       error, -1 is returned and <i>errno</i> is set to indicate the error.<br><br>       <b>timerfd_settime</b>() and <b>timerfd_gettime</b>() return 0 on success; on error<br>       they return -1, and set <i>errno</i> to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>timerfd_create</b>() can fail with the following errors:<br><br>       <b>EINVAL </b>The <i>clockid</i> argument is neither <b>CLOCK_MONOTONIC </b>nor<br>              <b>CLOCK_REALTIME</b>;<br><br>       <b>EINVAL </b><i>flags</i> is invalid; or, in Linux 2.6.26 or earlier, <i>flags</i> is<br>              nonzero.<br><br>       <b>EMFILE </b>The per-process limit of open file descriptors has been<br>              reached.<br><br>       <b>ENFILE </b>The system-wide limit on the total number of open files has<br>              been reached.<br><br>       <b>ENODEV </b>Could not mount (internal) anonymous inode device.<br><br>       <b>ENOMEM </b>There was insufficient kernel memory to create the timer.<br><br>       <b>timerfd_settime</b>() and <b>timerfd_gettime</b>() can fail with the following<br>       errors:<br><br>       <b>EBADF  </b><i>fd</i> is not a valid file descriptor.<br><br>       <b>EFAULT </b><i>new_value</i>, <i>old_value</i>, or <i>curr_value</i> is not valid a pointer.<br><br>       <b>EINVAL </b><i>fd</i> is not a valid timerfd file descriptor.<br><br>       <b>timerfd_settime</b>() can also fail with the following errors:<br><br>       <b>EINVAL </b><i>new_value</i> is not properly initialized (one of the <i>tv_nsec</i><br>              falls outside the range zero to 999,999,999).<br><br>       <b>EINVAL </b><i>flags</i> is invalid.<br></pre><br><h2>VERSIONS  </h2><pre><br>       These system calls are available on Linux since kernel 2.6.25.<br>       Library support is provided by glibc since version 2.8.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       These system calls are Linux-specific.<br></pre><br><h2>BUGS  </h2><pre><br>       Currently, <b>timerfd_create</b>() supports fewer types of clock IDs than<br>       timer_create(2).<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The following program creates a timer and then monitors its progress.<br>       The program accepts up to three command-line arguments.  The first<br>       argument specifies the number of seconds for the initial expiration<br>       of the timer.  The second argument specifies the interval for the<br>       timer, in seconds.  The third argument specifies the number of times<br>       the program should allow the timer to expire before terminating.  The<br>       second and third command-line arguments are optional.<br><br>       The following shell session demonstrates the use of the program:<br><br>           $ <b>a.out 3 1 100</b><br>           0.000: timer started<br>           3.000: read: 1; total=1<br>           4.000: read: 1; total=2<br>           <b>^Z                  </b># type control-Z to suspend the program<br>           [1]+  Stopped                 ./timerfd3_demo 3 1 100<br>           $ <b>fg                </b># Resume execution after a few seconds<br>           a.out 3 1 100<br>           9.660: read: 5; total=7<br>           10.000: read: 1; total=8<br>           11.000: read: 1; total=9<br>           <b>^C                  </b># type control-C to suspend the program<br><br>   <b>Program source</b><br><br>       #include &lt;sys/timerfd.h&gt;<br>       #include &lt;time.h&gt;<br>       #include &lt;unistd.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;stdint.h&gt;        /* Definition of uint64_t */<br><br>       #define handle_error(msg) \\<br>               do { perror(msg); exit(EXIT_FAILURE); } while (0)<br><br>       static void<br>       print_elapsed_time(void)<br>       {<br>           static struct timespec start;<br>           struct timespec curr;<br>           static int first_call = 1;<br>           int secs, nsecs;<br><br>           if (first_call) {<br>               first_call = 0;<br>               if (clock_gettime(CLOCK_MONOTONIC, &amp;start) == -1)<br>                   handle_error(\"clock_gettime\");<br>           }<br><br>           if (clock_gettime(CLOCK_MONOTONIC, &amp;curr) == -1)<br>               handle_error(\"clock_gettime\");<br><br>           secs = curr.tv_sec - start.tv_sec;<br>           nsecs = curr.tv_nsec - start.tv_nsec;<br>           if (nsecs &lt; 0) {<br>               secs--;<br>               nsecs += 1000000000;<br>           }<br>           printf(\"%d.%03d: \", secs, (nsecs + 500000) / 1000000);<br>       }<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           struct itimerspec new_value;<br>           int max_exp, fd;<br>           struct timespec now;<br>           uint64_t exp, tot_exp;<br>           ssize_t s;<br><br>           if ((argc != 2) &amp;&amp; (argc != 4)) {<br>               fprintf(stderr, \"%s init-secs [interval-secs max-exp]\\n\",<br>                       argv[0]);<br>               exit(EXIT_FAILURE);<br>           }<br><br>           if (clock_gettime(CLOCK_REALTIME, &amp;now) == -1)<br>               handle_error(\"clock_gettime\");<br><br>           /* Create a CLOCK_REALTIME absolute timer with initial<br>              expiration and interval as specified in command line */<br><br>           new_value.it_value.tv_sec = now.tv_sec + atoi(argv[1]);<br>           new_value.it_value.tv_nsec = now.tv_nsec;<br>           if (argc == 2) {<br>               new_value.it_interval.tv_sec = 0;<br>               max_exp = 1;<br>           } else {<br>               new_value.it_interval.tv_sec = atoi(argv[2]);<br>               max_exp = atoi(argv[3]);<br>           }<br>           new_value.it_interval.tv_nsec = 0;<br><br>           fd = timerfd_create(CLOCK_REALTIME, 0);<br>           if (fd == -1)<br>               handle_error(\"timerfd_create\");<br><br>           if (timerfd_settime(fd, TFD_TIMER_ABSTIME, &amp;new_value, NULL) == -1)<br>               handle_error(\"timerfd_settime\");<br><br>           print_elapsed_time();<br>           printf(\"timer started\\n\");<br><br>           for (tot_exp = 0; tot_exp &lt; max_exp;) {<br>               s = read(fd, &amp;exp, sizeof(uint64_t));<br>               if (s != sizeof(uint64_t))<br>                   handle_error(\"read\");<br><br>               tot_exp += exp;<br>               print_elapsed_time();<br>               printf(\"read: %llu; total=%llu\\n\",<br>                       (unsigned long long) exp,<br>                       (unsigned long long) tot_exp);<br>           }<br><br>           exit(EXIT_SUCCESS);<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       eventfd(2), poll(2), read(2), select(2), setitimer(2), signalfd(2),<br>       timer_create(2), timer_gettime(2), timer_settime(2), epoll(7),<br>       time(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-04-19                TIMERFD_CREATE(2)</span><br></pre><br>"}