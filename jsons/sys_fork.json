{"Man page": "<pre><br><span class=\"headline\">FORK(2)                   Linux Programmer's Manual                  FORK(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       fork - create a child process<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>pid_t fork(void);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>fork</b>() creates a new process by duplicating the calling process.  The<br>       new process is referred to as the <i>child</i> process.  The calling process<br>       is referred to as the <i>parent</i> process.<br><br>       The child process and the parent process run in separate memory<br>       spaces.  At the time of <b>fork</b>() both memory spaces have the same<br>       content.  Memory writes, file mappings (mmap(2)), and unmappings<br>       (munmap(2)) performed by one of the processes do not affect the<br>       other.<br><br>       The child process is an exact duplicate of the parent process except<br>       for the following points:<br><br>       *  The child has its own unique process ID, and this PID does not<br>          match the ID of any existing process group (setpgid(2)).<br><br>       *  The child's parent process ID is the same as the parent's process<br>          ID.<br><br>       *  The child does not inherit its parent's memory locks (mlock(2),<br>          mlockall(2)).<br><br>       *  Process resource utilizations (getrusage(2)) and CPU time counters<br>          (times(2)) are reset to zero in the child.<br><br>       *  The child's set of pending signals is initially empty<br>          (sigpending(2)).<br><br>       *  The child does not inherit semaphore adjustments from its parent<br>          (semop(2)).<br><br>       *  The child does not inherit process-associated record locks from<br>          its parent (fcntl(2)).  (On the other hand, it does inherit<br>          fcntl(2) open file description locks and flock(2) locks from its<br>          parent.)<br><br>       *  The child does not inherit timers from its parent (setitimer(2),<br>          alarm(2), timer_create(2)).<br><br>       *  The child does not inherit outstanding asynchronous I/O operations<br>          from its parent (aio_read(3), aio_write(3)), nor does it inherit<br>          any asynchronous I/O contexts from its parent (see io_setup(2)).<br><br>       The process attributes in the preceding list are all specified in<br>       POSIX.1.  The parent and child also differ with respect to the<br>       following Linux-specific process attributes:<br><br>       *  The child does not inherit directory change notifications<br>          (dnotify) from its parent (see the description of <b>F_NOTIFY </b>in<br>          fcntl(2)).<br><br>       *  The prctl(2) <b>PR_SET_PDEATHSIG </b>setting is reset so that the child<br>          does not receive a signal when its parent terminates.<br><br>       *  The default timer slack value is set to the parent's current timer<br>          slack value.  See the description of <b>PR_SET_TIMERSLACK </b>in<br>          prctl(2).<br><br>       *  Memory mappings that have been marked with the madvise(2)<br>          <b>MADV_DONTFORK </b>flag are not inherited across a <b>fork</b>().<br><br>       *  The termination signal of the child is always <b>SIGCHLD </b>(see<br>          clone(2)).<br><br>       *  The port access permission bits set by ioperm(2) are not inherited<br>          by the child; the child must turn on any bits that it requires<br>          using ioperm(2).<br><br>       Note the following further points:<br><br>       *  The child process is created with a single thread&#8212;the one that<br>          called <b>fork</b>().  The entire virtual address space of the parent is<br>          replicated in the child, including the states of mutexes,<br>          condition variables, and other pthreads objects; the use of<br>          <b>pthread_atfork</b>(3) may be helpful for dealing with problems that<br>          this can cause.<br><br>       *  The child inherits copies of the parent's set of open file<br>          descriptors.  Each file descriptor in the child refers to the same<br>          open file description (see open(2)) as the corresponding file<br>          descriptor in the parent.  This means that the two descriptors<br>          share open file status flags, current file offset, and signal-<br>          driven I/O attributes (see the description of <b>F_SETOWN </b>and<br>          <b>F_SETSIG </b>in fcntl(2)).<br><br>       *  The child inherits copies of the parent's set of open message<br>          queue descriptors (see mq_overview(7)).  Each descriptor in the<br>          child refers to the same open message queue description as the<br>          corresponding descriptor in the parent.  This means that the two<br>          descriptors share the same flags (<i>mq_flags</i>).<br><br>       *  The child inherits copies of the parent's set of open directory<br>          streams (see opendir(3)).  POSIX.1 says that the corresponding<br>          directory streams in the parent and child <i>may</i> share the directory<br>          stream positioning; on Linux/glibc they do not.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, the PID of the child process is returned in the parent,<br>       and 0 is returned in the child.  On failure, -1 is returned in the<br>       parent, no child process is created, and <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EAGAIN</b><br><br>              A system-imposed limit on the number of threads was<br>              encountered.  There are a number of limits that may trigger<br>              this error: the <b>RLIMIT_NPROC </b>soft resource limit (set via<br>              setrlimit(2)), which limits the number of processes and<br>              threads for a real user ID, was reached; the kernel's system-<br>              wide limit on the number of processes and threads,<br>              <i>/proc/sys/kernel/threads-max</i>, was reached (see proc(5)); or<br>              the maximum number of PIDs, <i>/proc/sys/kernel/pid_max</i>, was<br>              reached (see proc(5)).<br><br>       <b>EAGAIN </b>The caller is operating under the <b>SCHED_DEADLINE </b>scheduling<br>              policy and does not have the reset-on-fork flag set.  See<br>              sched(7).<br><br>       <b>ENOMEM fork</b>() failed to allocate the necessary kernel structures<br>              because memory is tight.<br><br>       <b>ENOSYS fork</b>() is not supported on this platform (for example,<br>              hardware without a Memory-Management Unit).<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.<br></pre><br><h2>NOTES  </h2><pre><br>       Under Linux, <b>fork</b>() is implemented using copy-on-write pages, so the<br>       only penalty that it incurs is the time and memory required to<br>       duplicate the parent's page tables, and to create a unique task<br>       structure for the child.<br><br>   <b>C library/kernel differences</b><br>       Since version 2.3.3, rather than invoking the kernel's <b>fork</b>() system<br>       call, the glibc <b>fork</b>() wrapper that is provided as part of the NPTL<br>       threading implementation invokes clone(2) with flags that provide the<br>       same effect as the traditional system call.  (A call to <b>fork</b>() is<br>       equivalent to a call to clone(2) specifying <i>flags</i> as just <b>SIGCHLD</b>.)<br>       The glibc wrapper invokes any fork handlers that have been<br>       established using <b>pthread_atfork</b>(3).<br></pre><br><h2>EXAMPLE  </h2><pre><br>       See pipe(2) and wait(2).<br></pre><br><h2>SEE ALSO  </h2><pre><br>       clone(2), execve(2), exit(2), setrlimit(2), unshare(2), vfork(2),<br>       wait(2), daemon(3), capabilities(7), credentials(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                          FORK(2)</span><br></pre><br>"}