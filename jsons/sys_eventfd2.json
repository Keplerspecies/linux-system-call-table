{"Man page": "<pre><br><span class=\"headline\">EVENTFD(2)                Linux Programmer's Manual               EVENTFD(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       eventfd - create a file descriptor for event notification<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/eventfd.h&gt;</b><br><br>       <b>int eventfd(unsigned int </b><i>initval</i><b>, int </b><i>flags</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>eventfd</b>() creates an \"eventfd object\" that can be used as an event<br>       wait/notify mechanism by user-space applications, and by the kernel<br>       to notify user-space applications of events.  The object contains an<br>       unsigned 64-bit integer (<i>uint64_t</i>) counter that is maintained by the<br>       kernel.  This counter is initialized with the value specified in the<br>       argument <i>initval</i>.<br><br>       The following values may be bitwise ORed in <i>flags</i> to change the<br>       behavior of <b>eventfd</b>():<br><br>       <b>EFD_CLOEXEC </b>(since Linux 2.6.27)<br>              Set the close-on-exec (<b>FD_CLOEXEC</b>) flag on the new file<br>              descriptor.  See the description of the <b>O_CLOEXEC </b>flag in<br>              open(2) for reasons why this may be useful.<br><br>       <b>EFD_NONBLOCK </b>(since Linux 2.6.27)<br>              Set the <b>O_NONBLOCK </b>file status flag on the new open file<br>              description.  Using this flag saves extra calls to fcntl(2) to<br>              achieve the same result.<br><br>       <b>EFD_SEMAPHORE </b>(since Linux 2.6.30)<br>              Provide semaphore-like semantics for reads from the new file<br>              descriptor.  See below.<br><br>       In Linux up to version 2.6.26, the <i>flags</i> argument is unused, and must<br>       be specified as zero.<br><br>       As its return value, <b>eventfd</b>() returns a new file descriptor that can<br>       be used to refer to the eventfd object.  The following operations can<br>       be performed on the file descriptor:<br><br>       read(2)<br>              Each successful read(2) returns an 8-byte integer.  A read(2)<br>              will fail with the error <b>EINVAL </b>if the size of the supplied<br>              buffer is less than 8 bytes.<br><br>              The value returned by read(2) is in host byte order&#8212;that is,<br>              the native byte order for integers on the host machine.<br><br>              The semantics of read(2) depend on whether the eventfd counter<br>              currently has a nonzero value and whether the <b>EFD_SEMAPHORE</b><br>              flag was specified when creating the eventfd file descriptor:<br><br>              *  If <b>EFD_SEMAPHORE </b>was not specified and the eventfd counter<br>                 has a nonzero value, then a read(2) returns 8 bytes<br>                 containing that value, and the counter's value is reset to<br>                 zero.<br><br>              *  If <b>EFD_SEMAPHORE </b>was specified and the eventfd counter has<br>                 a nonzero value, then a read(2) returns 8 bytes containing<br>                 the value 1, and the counter's value is decremented by 1.<br><br>              *  If the eventfd counter is zero at the time of the call to<br>                 read(2), then the call either blocks until the counter<br>                 becomes nonzero (at which time, the read(2) proceeds as<br>                 described above) or fails with the error <b>EAGAIN </b>if the file<br>                 descriptor has been made nonblocking.<br><br>       write(2)<br>              A write(2) call adds the 8-byte integer value supplied in its<br>              buffer to the counter.  The maximum value that may be stored<br>              in the counter is the largest unsigned 64-bit value minus 1<br>              (i.e., 0xfffffffffffffffe).  If the addition would cause the<br>              counter's value to exceed the maximum, then the write(2)<br>              either blocks until a read(2) is performed on the file<br>              descriptor, or fails with the error <b>EAGAIN </b>if the file<br>              descriptor has been made nonblocking.<br><br>              A write(2) will fail with the error <b>EINVAL </b>if the size of the<br>              supplied buffer is less than 8 bytes, or if an attempt is made<br>              to write the value 0xffffffffffffffff.<br><br>       poll(2), select(2) (and similar)<br>              The returned file descriptor supports poll(2) (and analogously<br>              epoll(7)) and select(2), as follows:<br><br>              *  The file descriptor is readable (the select(2) <i>readfds</i><br>                 argument; the poll(2) <b>POLLIN </b>flag) if the counter has a<br>                 value greater than 0.<br><br>              *  The file descriptor is writable (the select(2) <i>writefds</i><br>                 argument; the poll(2) <b>POLLOUT </b>flag) if it is possible to<br>                 write a value of at least \"1\" without blocking.<br><br>              *  If an overflow of the counter value was detected, then<br>                 select(2) indicates the file descriptor as being both<br>                 readable and writable, and poll(2) returns a <b>POLLERR </b>event.<br>                 As noted above, write(2) can never overflow the counter.<br>                 However an overflow can occur if 2^64 eventfd \"signal<br>                 posts\" were performed by the KAIO subsystem (theoretically<br>                 possible, but practically unlikely).  If an overflow has<br>                 occurred, then read(2) will return that maximum <i>uint64_t</i><br>                 value (i.e., 0xffffffffffffffff).<br><br>              The eventfd file descriptor also supports the other file-<br>              descriptor multiplexing APIs: pselect(2) and ppoll(2).<br><br>       close(2)<br>              When the file descriptor is no longer required it should be<br>              closed.  When all file descriptors associated with the same<br>              eventfd object have been closed, the resources for object are<br>              freed by the kernel.<br><br>       A copy of the file descriptor created by <b>eventfd</b>() is inherited by<br>       the child produced by fork(2).  The duplicate file descriptor is<br>       associated with the same eventfd object.  File descriptors created by<br>       <b>eventfd</b>() are preserved across execve(2), unless the close-on-exec<br>       flag has been set.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>eventfd</b>() returns a new eventfd file descriptor.  On<br>       error, -1 is returned and <i>errno</i> is set to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EINVAL </b>An unsupported value was specified in <i>flags</i>.<br><br>       <b>EMFILE </b>The per-process limit on open file descriptors has been<br>              reached.<br><br>       <b>ENFILE </b>The system-wide limit on the total number of open files has<br>              been reached.<br><br>       <b>ENODEV </b>Could not mount (internal) anonymous inode device.<br><br>       <b>ENOMEM </b>There was insufficient memory to create a new eventfd file<br>              descriptor.<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>eventfd</b>() is available on Linux since kernel 2.6.22.  Working support<br>       is provided in glibc since version 2.8.  The <b>eventfd2</b>() system call<br>       (see NOTES) is available on Linux since kernel 2.6.27.  Since version<br>       2.9, the glibc <b>eventfd</b>() wrapper will employ the <b>eventfd2</b>() system<br>       call, if it is supported by the kernel.<br></pre><br><h2>ATTRIBUTES  </h2><pre><br>       For an explanation of the terms used in this section, see<br>       attributes(7).<br><br>       &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9516;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9516;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;<br>       &#9474;<b>Interface </b>&#9474; <b>Attribute     </b>&#9474; <b>Value   </b>&#9474;<br>       &#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;<br>       &#9474;<b>eventfd</b>() &#9474; Thread safety &#9474; MT-Safe &#9474;<br>       &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9524;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9524;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>eventfd</b>() and <b>eventfd2</b>() are Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       Applications can use an eventfd file descriptor instead of a pipe<br>       (see pipe(2)) in all cases where a pipe is used simply to signal<br>       events.  The kernel overhead of an eventfd file descriptor is much<br>       lower than that of a pipe, and only one file descriptor is required<br>       (versus the two required for a pipe).<br><br>       When used in the kernel, an eventfd file descriptor can provide a<br>       bridge from kernel to user space, allowing, for example,<br>       functionalities like KAIO (kernel AIO) to signal to a file descriptor<br>       that some operation is complete.<br><br>       A key point about an eventfd file descriptor is that it can be<br>       monitored just like any other file descriptor using select(2),<br>       poll(2), or epoll(7).  This means that an application can<br>       simultaneously monitor the readiness of \"traditional\" files and the<br>       readiness of other kernel mechanisms that support the eventfd<br>       interface.  (Without the <b>eventfd</b>() interface, these mechanisms could<br>       not be multiplexed via select(2), poll(2), or epoll(7).)<br><br>   <b>C library/kernel differences</b><br>       There are two underlying Linux system calls: <b>eventfd</b>() and the more<br>       recent <b>eventfd2</b>().  The former system call does not implement a <i>flags</i><br>       argument.  The latter system call implements the <i>flags</i> values<br>       described above.  The glibc wrapper function will use <b>eventfd2</b>()<br>       where it is available.<br><br>   <b>Additional glibc features</b><br>       The GNU C library defines an additional type, and two functions that<br>       attempt to abstract some of the details of reading and writing on an<br>       eventfd file descriptor:<br><br>           typedef uint64_t eventfd_t;<br><br>           int eventfd_read(int fd, eventfd_t *value);<br>           int eventfd_write(int fd, eventfd_t value);<br><br>       The functions perform the read and write operations on an eventfd<br>       file descriptor, returning 0 if the correct number of bytes was<br>       transferred, or -1 otherwise.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The following program creates an eventfd file descriptor and then<br>       forks to create a child process.  While the parent briefly sleeps,<br>       the child writes each of the integers supplied in the program's<br>       command-line arguments to the eventfd file descriptor.  When the<br>       parent has finished sleeping, it reads from the eventfd file<br>       descriptor.<br><br>       The following shell session shows a sample run of the program:<br><br>           $ <b>./a.out 1 2 4 7 14</b><br>           Child writing 1 to efd<br>           Child writing 2 to efd<br>           Child writing 4 to efd<br>           Child writing 7 to efd<br>           Child writing 14 to efd<br>           Child completed write loop<br>           Parent about to read<br>           Parent read 28 (0x1c) from efd<br><br>   <b>Program source</b><br><br>       #include &lt;sys/eventfd.h&gt;<br>       #include &lt;unistd.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;stdint.h&gt;             /* Definition of uint64_t */<br><br>       #define handle_error(msg) \\<br>           do { perror(msg); exit(EXIT_FAILURE); } while (0)<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           int efd, j;<br>           uint64_t u;<br>           ssize_t s;<br><br>           if (argc &lt; 2) {<br>               fprintf(stderr, \"Usage: %s &lt;num&gt;...\\n\", argv[0]);<br>               exit(EXIT_FAILURE);<br>           }<br><br>           efd = eventfd(0, 0);<br>           if (efd == -1)<br>               handle_error(\"eventfd\");<br><br>           switch (fork()) {<br>           case 0:<br>               for (j = 1; j &lt; argc; j++) {<br>                   printf(\"Child writing %s to efd\\n\", argv[j]);<br>                   u = strtoull(argv[j], NULL, 0);<br>                           /* strtoull() allows various bases */<br>                   s = write(efd, &amp;u, sizeof(uint64_t));<br>                   if (s != sizeof(uint64_t))<br>                       handle_error(\"write\");<br>               }<br>               printf(\"Child completed write loop\\n\");<br><br>               exit(EXIT_SUCCESS);<br><br>           default:<br>               sleep(2);<br><br>               printf(\"Parent about to read\\n\");<br>               s = read(efd, &amp;u, sizeof(uint64_t));<br>               if (s != sizeof(uint64_t))<br>                   handle_error(\"read\");<br>               printf(\"Parent read %llu (0x%llx) from efd\\n\",<br>                       (unsigned long long) u, (unsigned long long) u);<br>               exit(EXIT_SUCCESS);<br><br>           case -1:<br>               handle_error(\"fork\");<br>           }<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       futex(2), pipe(2), poll(2), read(2), select(2), signalfd(2),<br>       timerfd_create(2), write(2), epoll(7), sem_overview(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                       EVENTFD(2)</span><br></pre><br>"}