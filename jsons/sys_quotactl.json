{"Man page": "<pre><br><span class=\"headline\">QUOTACTL(2)               Linux Programmer's Manual              QUOTACTL(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       quotactl - manipulate disk quotas<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/quota.h&gt;</b><br>       <b>#include &lt;xfs/xqm.h&gt;</b><br><br>       <b>int quotactl(int </b><i>cmd</i><b>, const char *</b><i>special</i><b>, int </b><i>id</i><b>, caddr_t </b><i>addr</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The quota system can be used to set per-user and per-group limits on<br>       the amount of disk space used on a filesystem.  For each user and/or<br>       group, a soft limit and a hard limit can be set for each filesystem.<br>       The hard limit can't be exceeded.  The soft limit can be exceeded,<br>       but warnings will ensue.  Moreover, the user can't exceed the soft<br>       limit for more than one week (by default) at a time; after this time,<br>       the soft limit counts as a hard limit.<br><br>       The <b>quotactl</b>() call manipulates disk quotas.  The <i>cmd</i> argument<br>       indicates a command to be applied to the user or group ID specified<br>       in <i>id</i>.  To initialize the <i>cmd</i> argument, use the <i>QCMD(subcmd, type)</i><br>       macro.  The <i>type</i> value is either <b>USRQUOTA</b>, for user quotas, or<br>       <b>GRPQUOTA</b>, for group quotas.  The <i>subcmd</i> value is described below.<br><br>       The <i>special</i> argument is a pointer to a null-terminated string<br>       containing the pathname of the (mounted) block special device for the<br>       filesystem being manipulated.<br><br>       The <i>addr</i> argument is the address of an optional, command-specific,<br>       data structure that is copied in or out of the system.  The<br>       interpretation of <i>addr</i> is given with each command below.<br><br>       The <i>subcmd</i> value is one of the following:<br><br>       <b>Q_QUOTAON</b><br>               Turn on quotas for a filesystem.  The <i>id</i> argument is the<br>               identification number of the quota format to be used.<br>               Currently, there are three supported quota formats:<br><br>               <b>QFMT_VFS_OLD </b>The original quota format.<br><br>               <b>QFMT_VFS_V0  </b>The standard VFS v0 quota format, which can<br>                            handle 32-bit UIDs and GIDs and quota limits up<br>                            to 2^42 bytes and 2^32 inodes.<br><br>               <b>QFMT_VFS_V1  </b>A quota format that can handle 32-bit UIDs and<br>                            GIDs and quota limits of 2^64 bytes and 2^64<br>                            inodes.<br><br>               The <i>addr</i> argument points to the pathname of a file containing<br>               the quotas for the filesystem.  The quota file must exist; it<br>               is normally created with the quotacheck(8) program.  This<br>               operation requires privilege (<b>CAP_SYS_ADMIN</b>).<br><br>       <b>Q_QUOTAOFF</b><br>               Turn off quotas for a filesystem.  The <i>addr</i> and <i>id</i> arguments<br>               are ignored.  This operation requires privilege<br>               (<b>CAP_SYS_ADMIN</b>).<br><br>       <b>Q_GETQUOTA</b><br>               Get disk quota limits and current usage for user or group <i>id</i>.<br>               The <i>addr</i> argument is a pointer to a <i>dqblk</i> structure defined<br>               in <i>&lt;sys/quota.h&gt;</i> as follows:<br><br>                   /* uint64_t is an unsigned 64-bit integer;<br>                      uint32_t is an unsigned 32-bit integer */<br><br>                   struct dqblk {          /* Definition since Linux 2.4.22 */<br>                       uint64_t dqb_bhardlimit;   /* absolute limit on disk<br>                                                     quota blocks alloc */<br>                       uint64_t dqb_bsoftlimit;   /* preferred limit on<br>                                                     disk quota blocks */<br>                       uint64_t dqb_curspace;     /* current quota block<br>                                                     count */<br>                       uint64_t dqb_ihardlimit;   /* maximum number of<br>                                                     allocated inodes */<br>                       uint64_t dqb_isoftlimit;   /* preferred inode limit */<br>                       uint64_t dqb_curinodes;    /* current number of<br>                                                     allocated inodes */<br>                       uint64_t dqb_btime;        /* time limit for excessive<br>                                                     disk use */<br>                       uint64_t dqb_itime;        /* time limit for excessive<br>                                                     files */<br>                       uint32_t dqb_valid;        /* bit mask of QIF_*<br>                                                     constants */<br>                   };<br><br>                   /* Flags in dqb_valid that indicate which fields in<br>                      dqblk structure are valid. */<br><br>                   #define QIF_BLIMITS   1<br>                   #define QIF_SPACE     2<br>                   #define QIF_ILIMITS   4<br>                   #define QIF_INODES    8<br>                   #define QIF_BTIME     16<br>                   #define QIF_ITIME     32<br>                   #define QIF_LIMITS    (QIF_BLIMITS | QIF_ILIMITS)<br>                   #define QIF_USAGE     (QIF_SPACE | QIF_INODES)<br>                   #define QIF_TIMES     (QIF_BTIME | QIF_ITIME)<br>                   #define QIF_ALL       (QIF_LIMITS | QIF_USAGE | QIF_TIMES)<br><br>               The <i>dqb_valid</i> field is a bit mask that is set to indicate the<br>               entries in the <i>dqblk</i> structure that are valid.  Currently,<br>               the kernel fills in all entries of the <i>dqblk</i> structure and<br>               marks them as valid in the <i>dqb_valid</i> field.  Unprivileged<br>               users may retrieve only their own quotas; a privileged user<br>               (<b>CAP_SYS_ADMIN</b>) can retrieve the quotas of any user.<br><br>       <b>Q_SETQUOTA</b><br>               Set quota information for user or group <i>id</i>, using the<br>               information supplied in the <i>dqblk</i> structure pointed to by<br>               <i>addr</i>.  The <i>dqb_valid</i> field of the <i>dqblk</i> structure indicates<br>               which entries in the structure have been set by the caller.<br>               This operation supersedes the <b>Q_SETQLIM </b>and <b>Q_SETUSE</b><br>               operations in the previous quota interfaces.  This operation<br>               requires privilege (<b>CAP_SYS_ADMIN</b>).<br><br>       <b>Q_GETINFO</b><br>               Get information (like grace times) about quotafile.  The <i>addr</i><br>               argument should be a pointer to a <i>dqinfo</i> structure.  This<br>               structure is defined in <i>&lt;sys/quota.h&gt;</i> as follows:<br><br>                   /* uint64_t is an unsigned 64-bit integer;<br>                      uint32_t is an unsigned 32-bit integer */<br><br>                   struct dqinfo {         /* Defined since kernel 2.4.22 */<br>                       uint64_t dqi_bgrace;    /* Time before block soft limit<br>                                                  becomes hard limit */<br><br>                       uint64_t dqi_igrace;    /* Time before inode soft limit<br>                                                  becomes hard limit */<br>                       uint32_t dqi_flags;     /* Flags for quotafile<br>                                                  (DQF_*) */<br>                       uint32_t dqi_valid;<br>                   };<br><br>                   /* Bits for dqi_flags */<br><br>                   /* Quota format QFMT_VFS_OLD */<br><br>                   #define V1_DQF_RSQUASH   1   /* Root squash enabled */<br><br>                   /* Other quota formats have no dqi_flags bits defined */<br><br>                   /* Flags in dqi_valid that indicate which fields in<br>                      dqinfo structure are valid. */<br><br>                   # define IIF_BGRACE 1<br>                   # define IIF_IGRACE 2<br>                   # define IIF_FLAGS  4<br>                   # define IIF_ALL        (IIF_BGRACE | IIF_IGRACE | IIF_FLAGS)<br><br>               The <i>dqi_valid</i> field in the <i>dqinfo</i> structure indicates the<br>               entries in the structure that are valid.  Currently, the<br>               kernel fills in all entries of the <i>dqinfo</i> structure and marks<br>               them all as valid in the <i>dqi_valid</i> field.  The <i>id</i> argument is<br>               ignored.<br><br>       <b>Q_SETINFO</b><br>               Set information about quotafile.  The <i>addr</i> argument should be<br>               a pointer to a <i>dqinfo</i> structure.  The <i>dqi_valid</i> field of the<br>               <i>dqinfo</i> structure indicates the entries in the structure that<br>               have been set by the caller.  This operation supersedes the<br>               <b>Q_SETGRACE </b>and <b>Q_SETFLAGS </b>operations in the previous quota<br>               interfaces.  The <i>id</i> argument is ignored.  This operation<br>               requires privilege (<b>CAP_SYS_ADMIN</b>).<br><br>       <b>Q_GETFMT</b><br>               Get quota format used on the specified filesystem.  The <i>addr</i><br>               argument should be a pointer to a 4-byte buffer where the<br>               format number will be stored.<br><br>       <b>Q_SYNC  </b>Update the on-disk copy of quota usages for a filesystem.  If<br>               <i>special</i> is NULL, then all filesystems with active quotas are<br>               sync'ed.  The <i>addr</i> and <i>id</i> arguments are ignored.<br><br>       <b>Q_GETSTATS</b><br>               Get statistics and other generic information about the quota<br>               subsystem.  The <i>addr</i> argument should be a pointer to a<br>               <i>dqstats</i> structure in which data should be stored.  This<br>               structure is defined in <i>&lt;sys/quota.h&gt;</i>.  The <i>special</i> and <i>id</i><br>               arguments are ignored.  This operation is obsolete and not<br>               supported by recent kernels.  Files in <i>/proc/sys/fs/quota/</i><br>               carry the information instead.<br><br>       For XFS filesystems making use of the XFS Quota Manager (XQM), the<br>       above commands are bypassed and the following commands are used:<br><br>       <b>Q_XQUOTAON</b><br>               Turn on quotas for an XFS filesystem.  XFS provides the<br>               ability to turn on/off quota limit enforcement with quota<br>               accounting.  Therefore, XFS expects <i>addr</i> to be a pointer to<br>               an <i>unsigned int</i> that contains either the flags<br>               <b>XFS_QUOTA_UDQ_ACCT </b>and/or <b>XFS_QUOTA_UDQ_ENFD </b>(for user<br>               quota), or <b>XFS_QUOTA_GDQ_ACCT </b>and/or <b>XFS_QUOTA_GDQ_ENFD </b>(for<br>               group quota), as defined in <i>&lt;xfs/xqm.h&gt;</i>.  This operation<br>               requires privilege (<b>CAP_SYS_ADMIN</b>).<br><br>       <b>Q_XQUOTAOFF</b><br>               Turn off quotas for an XFS filesystem.  As with <b>Q_QUOTAON</b>,<br>               XFS filesystems expect a pointer to an <i>unsigned int</i> that<br>               specifies whether quota accounting and/or limit enforcement<br>               need to be turned off.  This operation requires privilege<br>               (<b>CAP_SYS_ADMIN</b>).<br><br>       <b>Q_XGETQUOTA</b><br>               Get disk quota limits and current usage for user <i>id</i>.  The<br>               <i>addr</i> argument is a pointer to an <i>fs_disk_quota</i> structure<br>               (defined in <i>&lt;xfs/xqm.h&gt;</i>).  Unprivileged users may retrieve<br>               only their own quotas; a privileged user (<b>CAP_SYS_ADMIN</b>) may<br>               retrieve the quotas of any user.<br><br>       <b>Q_XSETQLIM</b><br>               Set disk quota limits for user <i>id</i>.  The <i>addr</i> argument is a<br>               pointer to an <i>fs_disk_quota</i> structure (defined in<br>               <i>&lt;xfs/xqm.h&gt;</i>).  This operation requires privilege<br>               (<b>CAP_SYS_ADMIN</b>).<br><br>       <b>Q_XGETQSTAT</b><br>               Returns an <i>fs_quota_stat</i> structure containing XFS filesystem-<br>               specific quota information.  This is useful for finding out<br>               how much space is used to store quota information, and also<br>               to get quotaon/off status of a given local XFS filesystem.<br><br>       <b>Q_XQUOTARM</b><br>               Free the disk space taken by disk quotas.  Quotas must have<br>               already been turned off.<br><br>       There is no command equivalent to <b>Q_SYNC </b>for XFS since sync(1) writes<br>       quota information to disk (in addition to the other filesystem<br>       metadata that it writes out).<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>quotactl</b>() returns 0; on error -1 is returned, and <i>errno</i><br>       is set to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EFAULT </b><i>addr</i> or <i>special</i> is invalid.<br><br>       <b>EINVAL </b><i>cmd</i> or <i>type</i> is invalid.<br><br>       <b>ENOENT </b>The file specified by <i>special</i> or <i>addr</i> does not exist.<br><br>       <b>ENOSYS </b>The kernel has not been compiled with the <b>CONFIG_QUOTA </b>option.<br><br>       <b>ENOTBLK</b><br>              <i>special</i> is not a block device.<br><br>       <b>EPERM  </b>The caller lacked the required privilege (<b>CAP_SYS_ADMIN</b>) for<br>              the specified operation.<br><br>       <b>ESRCH  </b>No disk quota is found for the indicated user.  Quotas have<br>              not been turned on for this filesystem.<br><br>       If <i>cmd</i> is <b>Q_SETQUOTA</b>, <b>quotactl</b>() may also set <i>errno</i> to:<br><br>       <b>ERANGE </b>Specified limits are out of range allowed by quota format.<br><br>       If <i>cmd</i> is <b>Q_QUOTAON</b>, <b>quotactl</b>() may also set <i>errno</i> to:<br><br>       <b>EACCES </b>The quota file pointed to by <i>addr</i> exists, but is not a regular<br>              file; or, the quota file pointed to by <i>addr</i> exists, but is not<br>              on the filesystem pointed to by <i>special</i>.<br><br>       <b>EBUSY  Q_QUOTAON </b>attempted, but another <b>Q_QUOTAON </b>had already been<br>              performed.<br><br>       <b>EINVAL </b>The quota file is corrupted.<br><br>       <b>ESRCH  </b>Specified quota format was not found.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       quota(1), getrlimit(2), quotacheck(8), quotaon(8)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2010-06-16                      QUOTACTL(2)</span><br></pre><br>"}