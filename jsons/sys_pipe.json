{"Man page": "<pre><br><span class=\"headline\">PIPE(2)                   Linux Programmer's Manual                  PIPE(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       pipe, pipe2 - create pipe<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>int pipe(int </b><i>pipefd</i><b>[2]);</b><br><br>       <b>#define _GNU_SOURCE             </b>/* See feature_test_macros(7) */<br>       <b>#include &lt;fcntl.h&gt;              </b>/* Obtain O_* constant definitions */<br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>int pipe2(int </b><i>pipefd</i><b>[2], int </b><i>flags</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>pipe</b>() creates a pipe, a unidirectional data channel that can be used<br>       for interprocess communication.  The array <i>pipefd</i> is used to return<br>       two file descriptors referring to the ends of the pipe.  <i>pipefd[0]</i><br>       refers to the read end of the pipe.  <i>pipefd[1]</i> refers to the write<br>       end of the pipe.  Data written to the write end of the pipe is<br>       buffered by the kernel until it is read from the read end of the<br>       pipe.  For further details, see pipe(7).<br><br>       If <i>flags</i> is 0, then <b>pipe2</b>() is the same as <b>pipe</b>().  The following<br>       values can be bitwise ORed in <i>flags</i> to obtain different behavior:<br><br>       <b>O_CLOEXEC</b><br>              Set the close-on-exec (<b>FD_CLOEXEC</b>) flag on the two new file<br>              descriptors.  See the description of the same flag in open(2)<br>              for reasons why this may be useful.<br><br>       <b>O_DIRECT </b>(since Linux 3.4)<br>              Create a pipe that performs I/O in \"packet\" mode.  Each<br>              write(2) to the pipe is dealt with as a separate packet, and<br>              read(2)s from the pipe will read one packet at a time.  Note<br>              the following points:<br><br>              *  Writes of greater than <b>PIPE_BUF </b>bytes (see pipe(7)) will be<br>                 split into multiple packets.  The constant <b>PIPE_BUF </b>is<br>                 defined in <i>&lt;limits.h&gt;</i>.<br><br>              *  If a read(2) specifies a buffer size that is smaller than<br>                 the next packet, then the requested number of bytes are<br>                 read, and the excess bytes in the packet are discarded.<br>                 Specifying a buffer size of <b>PIPE_BUF </b>will be sufficient to<br>                 read the largest possible packets (see the previous point).<br><br>              *  Zero-length packets are not supported.  (A read(2) that<br>                 specifies a buffer size of zero is a no-op, and returns 0.)<br><br>              Older kernels that do not support this flag will indicate this<br>              via an <b>EINVAL </b>error.<br><br>       <b>O_NONBLOCK</b><br>              Set the <b>O_NONBLOCK </b>file status flag on the two new open file<br>              descriptions.  Using this flag saves extra calls to fcntl(2)<br>              to achieve the same result.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, zero is returned.  On error, -1 is returned, and <i>errno</i> is<br>       set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EFAULT </b><i>pipefd</i> is not valid.<br><br>       <b>EINVAL </b>(<b>pipe2</b>()) Invalid value in <i>flags</i>.<br><br>       <b>EMFILE </b>Too many file descriptors are in use by the process.<br><br>       <b>ENFILE </b>The system limit on the total number of open files has been<br>              reached.<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>pipe2</b>() was added to Linux in version 2.6.27; glibc support is<br>       available starting with version 2.9.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>pipe</b>(): POSIX.1-2001, POSIX.1-2008.<br><br>       <b>pipe2</b>() is Linux-specific.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The following program creates a pipe, and then fork(2)s to create a<br>       child process; the child inherits a duplicate set of file descriptors<br>       that refer to the same pipe.  After the fork(2), each process closes<br>       the descriptors that it doesn't need for the pipe (see pipe(7)).  The<br>       parent then writes the string contained in the program's command-line<br>       argument to the pipe, and the child reads this string a byte at a<br>       time from the pipe and echoes it on standard output.<br><br>   <b>Program source</b><br>       #include &lt;sys/types.h&gt;<br>       #include &lt;sys/wait.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;unistd.h&gt;<br>       #include &lt;string.h&gt;<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           int pipefd[2];<br>           pid_t cpid;<br>           char buf;<br><br>           if (argc != 2) {<br>               fprintf(stderr, \"Usage: %s &lt;string&gt;\\n\", argv[0]);<br>               exit(EXIT_FAILURE);<br>           }<br><br>           if (pipe(pipefd) == -1) {<br>               perror(\"pipe\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           cpid = fork();<br>           if (cpid == -1) {<br>               perror(\"fork\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           if (cpid == 0) {    /* Child reads from pipe */<br>               close(pipefd[1]);          /* Close unused write end */<br><br>               while (read(pipefd[0], &amp;buf, 1) &gt; 0)<br>                   write(STDOUT_FILENO, &amp;buf, 1);<br><br>               write(STDOUT_FILENO, \"\\n\", 1);<br>               close(pipefd[0]);<br>               _exit(EXIT_SUCCESS);<br><br>           } else {            /* Parent writes argv[1] to pipe */<br>               close(pipefd[0]);          /* Close unused read end */<br>               write(pipefd[1], argv[1], strlen(argv[1]));<br>               close(pipefd[1]);          /* Reader will see EOF */<br>               wait(NULL);                /* Wait for child */<br>               exit(EXIT_SUCCESS);<br>           }<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       fork(2), read(2), socketpair(2), write(2), popen(3), pipe(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-08-08                          PIPE(2)</span><br></pre><br>"}