{"Man page": "<pre><br><span class=\"headline\">CLONE(2)                  Linux Programmer's Manual                 CLONE(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       clone, __clone2 - create a child process<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       /* Prototype for the glibc wrapper function */<br><br>       <b>#include &lt;sched.h&gt;</b><br><br>       <b>int clone(int (*</b><i>fn</i><b>)(void *), void *</b><i>child_stack</i><b>,</b><br>                 <b>int </b><i>flags</i><b>, void *</b><i>arg</i><b>, ...</b><br>                 <b>/* pid_t *</b><i>ptid</i><b>, struct user_desc *</b><i>tls</i><b>, pid_t *</b><i>ctid</i> <b>*/ );</b><br><br>       /* Prototype for the raw system call */<br><br>       <b>long clone(unsigned long </b><i>flags</i><b>, void *</b><i>child_stack</i><b>,</b><br>                 <b>void *</b><i>ptid</i><b>, void *</b><i>ctid</i><b>,</b><br>                 <b>struct pt_regs *</b><i>regs</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc wrapper function (see<br>   feature_test_macros(7)):<br><br>       <b>clone</b>():<br>           Since glibc 2.14:<br>               _GNU_SOURCE<br>           Before glibc 2.14:<br>               _BSD_SOURCE || _SVID_SOURCE<br>                   /* _GNU_SOURCE also suffices */<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>clone</b>() creates a new process, in a manner similar to fork(2).<br><br>       This page describes both the glibc <b>clone</b>() wrapper function and the<br>       underlying system call on which it is based.  The main text describes<br>       the wrapper function; the differences for the raw system call are<br>       described toward the end of this page.<br><br>       Unlike fork(2), <b>clone</b>() allows the child process to share parts of<br>       its execution context with the calling process, such as the memory<br>       space, the table of file descriptors, and the table of signal<br>       handlers.  (Note that on this manual page, \"calling process\" normally<br>       corresponds to \"parent process\".  But see the description of<br>       <b>CLONE_PARENT </b>below.)<br><br>       One use of <b>clone</b>() is to implement threads: multiple threads of<br>       control in a program that run concurrently in a shared memory space.<br><br>       When the child process is created with <b>clone</b>(), it executes the<br>       function <i>fn</i>(<i>arg</i>).  (This differs from fork(2), where execution<br>       continues in the child from the point of the fork(2) call.)  The <i>fn</i><br>       argument is a pointer to a function that is called by the child<br>       process at the beginning of its execution.  The <i>arg</i> argument is<br>       passed to the <i>fn</i> function.<br><br>       When the <i>fn</i>(<i>arg</i>) function application returns, the child process<br>       terminates.  The integer returned by <i>fn</i> is the exit code for the<br>       child process.  The child process may also terminate explicitly by<br>       calling exit(2) or after receiving a fatal signal.<br><br>       The <i>child_stack</i> argument specifies the location of the stack used by<br>       the child process.  Since the child and calling process may share<br>       memory, it is not possible for the child process to execute in the<br>       same stack as the calling process.  The calling process must<br>       therefore set up memory space for the child stack and pass a pointer<br>       to this space to <b>clone</b>().  Stacks grow downward on all processors<br>       that run Linux (except the HP PA processors), so <i>child_stack</i> usually<br>       points to the topmost address of the memory space set up for the<br>       child stack.<br><br>       The low byte of <i>flags</i> contains the number of the <i>termination signal</i><br>       sent to the parent when the child dies.  If this signal is specified<br>       as anything other than <b>SIGCHLD</b>, then the parent process must specify<br>       the <b>__WALL </b>or <b>__WCLONE </b>options when waiting for the child with<br>       wait(2).  If no signal is specified, then the parent process is not<br>       signaled when the child terminates.<br><br>       <i>flags</i> may also be bitwise-or'ed with zero or more of the following<br>       constants, in order to specify what is shared between the calling<br>       process and the child process:<br><br>       <b>CLONE_CHILD_CLEARTID </b>(since Linux 2.5.49)<br>              Erase the child thread ID at the location <i>ctid</i> in child memory<br>              when the child exits, and do a wakeup on the futex at that<br>              address.  The address involved may be changed by the<br>              set_tid_address(2) system call.  This is used by threading<br>              libraries.<br><br>       <b>CLONE_CHILD_SETTID </b>(since Linux 2.5.49)<br>              Store the child thread ID at the location <i>ctid</i> in the child's<br>              memory.<br><br>       <b>CLONE_FILES </b>(since Linux 2.0)<br>              If <b>CLONE_FILES </b>is set, the calling process and the child<br>              process share the same file descriptor table.  Any file<br>              descriptor created by the calling process or by the child<br>              process is also valid in the other process.  Similarly, if one<br>              of the processes closes a file descriptor, or changes its<br>              associated flags (using the fcntl(2) <b>F_SETFD </b>operation), the<br>              other process is also affected.  If a process sharing a file<br>              descriptor table calls execve(2), its file descriptor table is<br>              duplicated (unshared).<br><br>              If <b>CLONE_FILES </b>is not set, the child process inherits a copy<br>              of all file descriptors opened in the calling process at the<br>              time of <b>clone</b>().  (The duplicated file descriptors in the<br>              child refer to the same open file descriptions (see open(2))<br>              as the corresponding file descriptors in the calling process.)<br>              Subsequent operations that open or close file descriptors, or<br>              change file descriptor flags, performed by either the calling<br>              process or the child process do not affect the other process.<br><br>       <b>CLONE_FS </b>(since Linux 2.0)<br>              If <b>CLONE_FS </b>is set, the caller and the child process share the<br>              same filesystem information.  This includes the root of the<br>              filesystem, the current working directory, and the umask.  Any<br>              call to chroot(2), chdir(2), or umask(2) performed by the<br>              calling process or the child process also affects the other<br>              process.<br><br>              If <b>CLONE_FS </b>is not set, the child process works on a copy of<br>              the filesystem information of the calling process at the time<br>              of the <b>clone</b>() call.  Calls to chroot(2), chdir(2), umask(2)<br>              performed later by one of the processes do not affect the<br>              other process.<br><br>       <b>CLONE_IO </b>(since Linux 2.6.25)<br>              If <b>CLONE_IO </b>is set, then the new process shares an I/O context<br>              with the calling process.  If this flag is not set, then (as<br>              with fork(2)) the new process has its own I/O context.<br><br>              The I/O context is the I/O scope of the disk scheduler (i.e,<br>              what the I/O scheduler uses to model scheduling of a process's<br>              I/O).  If processes share the same I/O context, they are<br>              treated as one by the I/O scheduler.  As a consequence, they<br>              get to share disk time.  For some I/O schedulers, if two<br>              processes share an I/O context, they will be allowed to<br>              interleave their disk access.  If several threads are doing<br>              I/O on behalf of the same process (aio_read(3), for instance),<br>              they should employ <b>CLONE_IO </b>to get better I/O performance.<br><br>              If the kernel is not configured with the <b>CONFIG_BLOCK </b>option,<br>              this flag is a no-op.<br><br>       <b>CLONE_NEWIPC </b>(since Linux 2.6.19)<br>              If <b>CLONE_NEWIPC </b>is set, then create the process in a new IPC<br>              namespace.  If this flag is not set, then (as with fork(2)),<br>              the process is created in the same IPC namespace as the<br>              calling process.  This flag is intended for the implementation<br>              of containers.<br><br>              An IPC namespace provides an isolated view of System V IPC<br>              objects (see svipc(7)) and (since Linux 2.6.30) POSIX message<br>              queues (see mq_overview(7)).  The common characteristic of<br>              these IPC mechanisms is that IPC objects are identified by<br>              mechanisms other than filesystem pathnames.<br><br>              Objects created in an IPC namespace are visible to all other<br>              processes that are members of that namespace, but are not<br>              visible to processes in other IPC namespaces.<br><br>              When an IPC namespace is destroyed (i.e., when the last<br>              process that is a member of the namespace terminates), all IPC<br>              objects in the namespace are automatically destroyed.<br><br>              Only a privileged process (<b>CAP_SYS_ADMIN</b>) can employ<br>              <b>CLONE_NEWIPC</b>.  This flag can't be specified in conjunction<br>              with <b>CLONE_SYSVSEM</b>.<br><br>              For further information on IPC namespaces, see namespaces(7).<br><br>       <b>CLONE_NEWNET </b>(since Linux 2.6.24)<br>              (The implementation of this flag was completed only by about<br>              kernel version 2.6.29.)<br><br>              If <b>CLONE_NEWNET </b>is set, then create the process in a new<br>              network namespace.  If this flag is not set, then (as with<br>              fork(2)) the process is created in the same network namespace<br>              as the calling process.  This flag is intended for the<br>              implementation of containers.<br><br>              A network namespace provides an isolated view of the<br>              networking stack (network device interfaces, IPv4 and IPv6<br>              protocol stacks, IP routing tables, firewall rules, the<br>              <i>/proc/net</i> and <i>/sys/class/net</i> directory trees, sockets, etc.).<br>              A physical network device can live in exactly one network<br>              namespace.  A virtual network device (\"veth\") pair provides a<br>              pipe-like abstraction that can be used to create tunnels<br>              between network namespaces, and can be used to create a bridge<br>              to a physical network device in another namespace.<br><br>              When a network namespace is freed (i.e., when the last process<br>              in the namespace terminates), its physical network devices are<br>              moved back to the initial network namespace (not to the parent<br>              of the process).  For further information on network<br>              namespaces, see namespaces(7).<br><br>              Only a privileged process (<b>CAP_SYS_ADMIN</b>) can employ<br>              <b>CLONE_NEWNET</b>.<br><br>       <b>CLONE_NEWNS </b>(since Linux 2.4.19)<br>              If <b>CLONE_NEWNS </b>is set, the cloned child is started in a new<br>              mount namespace, initialized with a copy of the namespace of<br>              the parent.  If <b>CLONE_NEWNS </b>is not set, the child lives in the<br>              same mount namespace as the parent.<br><br>              For further information on mount namespaces, see<br>              namespaces(7).<br><br>              Only a privileged process (<b>CAP_SYS_ADMIN</b>) can employ<br>              <b>CLONE_NEWNS</b>.  It is not permitted to specify both <b>CLONE_NEWNS</b><br>              and <b>CLONE_FS </b>in the same <b>clone</b>() call.<br><br>       <b>CLONE_NEWPID </b>(since Linux 2.6.24)<br>              If <b>CLONE_NEWPID </b>is set, then create the process in a new PID<br>              namespace.  If this flag is not set, then (as with fork(2))<br>              the process is created in the same PID namespace as the<br>              calling process.  This flag is intended for the implementation<br>              of containers.<br><br>              For further information on PID namespaces, see namespaces(7)<br>              and pid_namespaces(7)<br><br>              Only a privileged process (<b>CAP_SYS_ADMIN</b>) can employ<br>              <b>CLONE_NEWPID</b>.  This flag can't be specified in conjunction<br>              with <b>CLONE_THREAD </b>or <b>CLONE_PARENT</b>.<br><br>       <b>CLONE_NEWUSER</b><br>              (This flag first became meaningful for <b>clone</b>() in Linux<br>              2.6.23, the current <b>clone</b>() semantics were merged in Linux<br>              3.5, and the final pieces to make the user namespaces<br>              completely usable were merged in Linux 3.8.)<br><br>              If <b>CLONE_NEWUSER </b>is set, then create the process in a new user<br>              namespace.  If this flag is not set, then (as with fork(2))<br>              the process is created in the same user namespace as the<br>              calling process.<br><br>              For further information on user namespaces, see namespaces(7)<br>              and user_namespaces(7)<br><br>              Before Linux 3.8, use of <b>CLONE_NEWUSER </b>required that the<br>              caller have three capabilities: <b>CAP_SYS_ADMIN</b>, <b>CAP_SETUID</b>, and<br>              <b>CAP_SETGID</b>.  Starting with Linux 3.8, no privileges are needed<br>              to create a user namespace.<br><br>              This flag can't be specified in conjunction with <b>CLONE_THREAD</b><br>              or <b>CLONE_PARENT</b>.  For security reasons, <b>CLONE_NEWUSER </b>cannot<br>              be specified in conjunction with <b>CLONE_FS</b>.<br><br>              For further information on user namespaces, see<br>              user_namespaces(7).<br><br>       <b>CLONE_NEWUTS </b>(since Linux 2.6.19)<br>              If <b>CLONE_NEWUTS </b>is set, then create the process in a new UTS<br>              namespace, whose identifiers are initialized by duplicating<br>              the identifiers from the UTS namespace of the calling process.<br>              If this flag is not set, then (as with fork(2)) the process is<br>              created in the same UTS namespace as the calling process.<br>              This flag is intended for the implementation of containers.<br><br>              A UTS namespace is the set of identifiers returned by<br>              uname(2); among these, the domain name and the hostname can be<br>              modified by setdomainname(2) and sethostname(2), respectively.<br>              Changes made to the identifiers in a UTS namespace are visible<br>              to all other processes in the same namespace, but are not<br>              visible to processes in other UTS namespaces.<br><br>              Only a privileged process (<b>CAP_SYS_ADMIN</b>) can employ<br>              <b>CLONE_NEWUTS</b>.<br><br>              For further information on UTS namespaces, see namespaces(7).<br><br>       <b>CLONE_PARENT </b>(since Linux 2.3.12)<br>              If <b>CLONE_PARENT </b>is set, then the parent of the new child (as<br>              returned by getppid(2)) will be the same as that of the<br>              calling process.<br><br>              If <b>CLONE_PARENT </b>is not set, then (as with fork(2)) the child's<br>              parent is the calling process.<br><br>              Note that it is the parent process, as returned by getppid(2),<br>              which is signaled when the child terminates, so that if<br>              <b>CLONE_PARENT </b>is set, then the parent of the calling process,<br>              rather than the calling process itself, will be signaled.<br><br>       <b>CLONE_PARENT_SETTID </b>(since Linux 2.5.49)<br>              Store the child thread ID at the location <i>ptid</i> in the parent's<br>              memory.  (In Linux 2.5.32-2.5.48 there was a flag <b>CLONE_SETTID</b><br>              that did this.)<br><br>       <b>CLONE_PID </b>(obsolete)<br>              If <b>CLONE_PID </b>is set, the child process is created with the<br>              same process ID as the calling process.  This is good for<br>              hacking the system, but otherwise of not much use.  Since<br>              2.3.21 this flag can be specified only by the system boot<br>              process (PID 0).  It disappeared in Linux 2.5.16.  Since then,<br>              the kernel silently ignores it without error.<br><br>       <b>CLONE_PTRACE </b>(since Linux 2.2)<br>              If <b>CLONE_PTRACE </b>is specified, and the calling process is being<br>              traced, then trace the child also (see ptrace(2)).<br><br>       <b>CLONE_SETTLS </b>(since Linux 2.5.32)<br>              The <i>newtls</i> argument is the new TLS (Thread Local Storage)<br>              descriptor.  (See set_thread_area(2).)<br><br>       <b>CLONE_SIGHAND </b>(since Linux 2.0)<br>              If <b>CLONE_SIGHAND </b>is set, the calling process and the child<br>              process share the same table of signal handlers.  If the<br>              calling process or child process calls sigaction(2) to change<br>              the behavior associated with a signal, the behavior is changed<br>              in the other process as well.  However, the calling process<br>              and child processes still have distinct signal masks and sets<br>              of pending signals.  So, one of them may block or unblock some<br>              signals using sigprocmask(2) without affecting the other<br>              process.<br><br>              If <b>CLONE_SIGHAND </b>is not set, the child process inherits a copy<br>              of the signal handlers of the calling process at the time<br>              <b>clone</b>() is called.  Calls to sigaction(2) performed later by<br>              one of the processes have no effect on the other process.<br><br>              Since Linux 2.6.0-test6, <i>flags</i> must also include <b>CLONE_VM </b>if<br>              <b>CLONE_SIGHAND </b>is specified<br><br>       <b>CLONE_STOPPED </b>(since Linux 2.6.0-test2)<br>              If <b>CLONE_STOPPED </b>is set, then the child is initially stopped<br>              (as though it was sent a <b>SIGSTOP </b>signal), and must be resumed<br>              by sending it a <b>SIGCONT </b>signal.<br><br>              This flag was <i>deprecated</i> from Linux 2.6.25 onward, and was<br>              <i>removed</i> altogether in Linux 2.6.38.  Since then, the kernel<br>              silently ignores it without error.<br><br>       <b>CLONE_SYSVSEM </b>(since Linux 2.5.10)<br>              If <b>CLONE_SYSVSEM </b>is set, then the child and the calling<br>              process share a single list of System V semaphore adjustment<br>              (<i>semadj</i>) values (see semop(2)).  In this case, the shared list<br>              accumulates <i>semadj</i> values across all processes sharing the<br>              list, and semaphore adjustments are performed only when the<br>              last process that is sharing the list terminates (or ceases<br>              sharing the list using unshare(2)).  If this flag is not set,<br>              then the child has a separate <i>semadj</i> list that is initially<br>              empty.<br><br>       <b>CLONE_THREAD </b>(since Linux 2.4.0-test8)<br>              If <b>CLONE_THREAD </b>is set, the child is placed in the same thread<br>              group as the calling process.  To make the remainder of the<br>              discussion of <b>CLONE_THREAD </b>more readable, the term \"thread\" is<br>              used to refer to the processes within a thread group.<br><br>              Thread groups were a feature added in Linux 2.4 to support the<br>              POSIX threads notion of a set of threads that share a single<br>              PID.  Internally, this shared PID is the so-called thread<br>              group identifier (TGID) for the thread group.  Since Linux<br>              2.4, calls to getpid(2) return the TGID of the caller.<br><br>              The threads within a group can be distinguished by their<br>              (system-wide) unique thread IDs (TID).  A new thread's TID is<br>              available as the function result returned to the caller of<br>              <b>clone</b>(), and a thread can obtain its own TID using gettid(2).<br><br>              When a call is made to <b>clone</b>() without specifying<br>              <b>CLONE_THREAD</b>, then the resulting thread is placed in a new<br>              thread group whose TGID is the same as the thread's TID.  This<br>              thread is the <i>leader</i> of the new thread group.<br><br>              A new thread created with <b>CLONE_THREAD </b>has the same parent<br>              process as the caller of <b>clone</b>() (i.e., like <b>CLONE_PARENT</b>), so<br>              that calls to getppid(2) return the same value for all of the<br>              threads in a thread group.  When a <b>CLONE_THREAD </b>thread<br>              terminates, the thread that created it using <b>clone</b>() is not<br>              sent a <b>SIGCHLD </b>(or other termination) signal; nor can the<br>              status of such a thread be obtained using wait(2).  (The<br>              thread is said to be <i>detached</i>.)<br><br>              After all of the threads in a thread group terminate the<br>              parent process of the thread group is sent a <b>SIGCHLD </b>(or other<br>              termination) signal.<br><br>              If any of the threads in a thread group performs an execve(2),<br>              then all threads other than the thread group leader are<br>              terminated, and the new program is executed in the thread<br>              group leader.<br><br>              If one of the threads in a thread group creates a child using<br>              fork(2), then any thread in the group can wait(2) for that<br>              child.<br><br>              Since Linux 2.5.35, <i>flags</i> must also include <b>CLONE_SIGHAND </b>if<br>              <b>CLONE_THREAD </b>is specified (and note that, since Linux<br>              2.6.0-test6, <b>CLONE_SIGHAND </b>also requires <b>CLONE_VM </b>to be<br>              included).<br><br>              Signals may be sent to a thread group as a whole (i.e., a<br>              TGID) using kill(2), or to a specific thread (i.e., TID) using<br>              tgkill(2).<br><br>              Signal dispositions and actions are process-wide: if an<br>              unhandled signal is delivered to a thread, then it will affect<br>              (terminate, stop, continue, be ignored in) all members of the<br>              thread group.<br><br>              Each thread has its own signal mask, as set by sigprocmask(2),<br>              but signals can be pending either: for the whole process<br>              (i.e., deliverable to any member of the thread group), when<br>              sent with kill(2); or for an individual thread, when sent with<br>              tgkill(2).  A call to sigpending(2) returns a signal set that<br>              is the union of the signals pending for the whole process and<br>              the signals that are pending for the calling thread.<br><br>              If kill(2) is used to send a signal to a thread group, and the<br>              thread group has installed a handler for the signal, then the<br>              handler will be invoked in exactly one, arbitrarily selected<br>              member of the thread group that has not blocked the signal.<br>              If multiple threads in a group are waiting to accept the same<br>              signal using sigwaitinfo(2), the kernel will arbitrarily<br>              select one of these threads to receive a signal sent using<br>              kill(2).<br><br>       <b>CLONE_UNTRACED </b>(since Linux 2.5.46)<br>              If <b>CLONE_UNTRACED </b>is specified, then a tracing process cannot<br>              force <b>CLONE_PTRACE </b>on this child process.<br><br>       <b>CLONE_VFORK </b>(since Linux 2.2)<br>              If <b>CLONE_VFORK </b>is set, the execution of the calling process is<br>              suspended until the child releases its virtual memory<br>              resources via a call to execve(2) or _exit(2) (as with<br>              vfork(2)).<br><br>              If <b>CLONE_VFORK </b>is not set, then both the calling process and<br>              the child are schedulable after the call, and an application<br>              should not rely on execution occurring in any particular<br>              order.<br><br>       <b>CLONE_VM </b>(since Linux 2.0)<br>              If <b>CLONE_VM </b>is set, the calling process and the child process<br>              run in the same memory space.  In particular, memory writes<br>              performed by the calling process or by the child process are<br>              also visible in the other process.  Moreover, any memory<br>              mapping or unmapping performed with mmap(2) or munmap(2) by<br>              the child or calling process also affects the other process.<br><br>              If <b>CLONE_VM </b>is not set, the child process runs in a separate<br>              copy of the memory space of the calling process at the time of<br>              <b>clone</b>().  Memory writes or file mappings/unmappings performed<br>              by one of the processes do not affect the other, as with<br>              fork(2).<br><br>   <b>C library/kernel differences</b><br>       The raw <b>clone</b>() system call corresponds more closely to fork(2) in<br>       that execution in the child continues from the point of the call.  As<br>       such, the <i>fn</i> and <i>arg</i> arguments of the <b>clone</b>() wrapper function are<br>       omitted.  Furthermore, the argument order changes.  The raw system<br>       call interface on x86 and many other architectures is roughly:<br><br>           <b>long clone(unsigned long </b><i>flags</i><b>, void *</b><i>child_stack</i><b>,</b><br>                      <b>void *</b><i>ptid</i><b>, void *</b><i>ctid</i><b>,</b><br>                      <b>struct pt_regs *</b><i>regs</i><b>);</b><br><br>       Another difference for the raw system call is that the <i>child_stack</i><br>       argument may be zero, in which case copy-on-write semantics ensure<br>       that the child gets separate copies of stack pages when either<br>       process modifies the stack.  In this case, for correct operation, the<br>       <b>CLONE_VM </b>option should not be specified.<br><br>       For some architectures, the order of the arguments for the system<br>       call differs from that shown above.  On the score, microblaze, ARM,<br>       ARM 64, PA-RISC, arc, Power PC, xtensa, and MIPS architectures, the<br>       order of the fourth and fifth arguments is reversed.  On the cris and<br>       s390 architectures, the order of the first and second arguments is<br>       reversed.<br><br>   <b>blackfin, m68k, and sparc</b><br>       The argument-passing conventions on blackfin, m68k, and sparc are<br>       different from the descriptions above.  For details, see the kernel<br>       (and glibc) source.<br><br>   <b>ia64</b><br>       On ia64, a different interface is used:<br><br>       <b>int __clone2(int (*</b><i>fn</i><b>)(void *),</b><br>                    <b>void *</b><i>child_stack_base</i><b>, size_t </b><i>stack_size</i><b>,</b><br>                    <b>int </b><i>flags</i><b>, void *</b><i>arg</i><b>, ...</b><br>                 <b>/* pid_t *</b><i>ptid</i><b>, struct user_desc *</b><i>tls</i><b>, pid_t *</b><i>ctid</i> <b>*/ );</b><br><br>       The prototype shown above is for the glibc wrapper function; the raw<br>       system call interface has no <i>fn</i> or <i>arg</i> argument, and changes the<br>       order of the arguments so that <i>flags</i> is the first argument, and <i>tls</i><br>       is the last argument.<br><br>       <b>__clone2</b>() operates in the same way as <b>clone</b>(), except that<br>       <i>child_stack_base</i> points to the lowest address of the child's stack<br>       area, and <i>stack_size</i> specifies the size of the stack pointed to by<br>       <i>child_stack_base</i>.<br><br>   <b>Linux 2.4 and earlier</b><br>       In Linux 2.4 and earlier, <b>clone</b>() does not take arguments <i>ptid</i>, <i>tls</i>,<br>       and <i>ctid</i>.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, the thread ID of the child process is returned in the<br>       caller's thread of execution.  On failure, -1 is returned in the<br>       caller's context, no child process will be created, and <i>errno</i> will be<br>       set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EAGAIN </b>Too many processes are already running; see fork(2).<br><br>       <b>EINVAL CLONE_SIGHAND </b>was specified, but <b>CLONE_VM </b>was not.  (Since<br>              Linux 2.6.0-test6.)<br><br>       <b>EINVAL CLONE_THREAD </b>was specified, but <b>CLONE_SIGHAND </b>was not.  (Since<br>              Linux 2.5.35.)<br><br>       <b>EINVAL </b>Both <b>CLONE_FS </b>and <b>CLONE_NEWNS </b>were specified in <i>flags</i>.<br><br>       <b>EINVAL </b>(since Linux 3.9)<br>              Both <b>CLONE_NEWUSER </b>and <b>CLONE_FS </b>were specified in <i>flags</i>.<br><br>       <b>EINVAL </b>Both <b>CLONE_NEWIPC </b>and <b>CLONE_SYSVSEM </b>were specified in <i>flags</i>.<br><br>       <b>EINVAL </b>One (or both) of <b>CLONE_NEWPID </b>or <b>CLONE_NEWUSER </b>and one (or<br>              both) of <b>CLONE_THREAD </b>or <b>CLONE_PARENT </b>were specified in <i>flags</i>.<br><br>       <b>EINVAL </b>Returned by <b>clone</b>() when a zero value is specified for<br>              <i>child_stack</i>.<br><br>       <b>EINVAL CLONE_NEWIPC </b>was specified in <i>flags</i>, but the kernel was not<br>              configured with the <b>CONFIG_SYSVIPC </b>and <b>CONFIG_IPC_NS </b>options.<br><br>       <b>EINVAL CLONE_NEWNET </b>was specified in <i>flags</i>, but the kernel was not<br>              configured with the <b>CONFIG_NET_NS </b>option.<br><br>       <b>EINVAL CLONE_NEWPID </b>was specified in <i>flags</i>, but the kernel was not<br>              configured with the <b>CONFIG_PID_NS </b>option.<br><br>       <b>EINVAL CLONE_NEWUTS </b>was specified in <i>flags</i>, but the kernel was not<br>              configured with the <b>CONFIG_UTS </b>option.<br><br>       <b>ENOMEM </b>Cannot allocate sufficient memory to allocate a task structure<br>              for the child, or to copy those parts of the caller's context<br>              that need to be copied.<br><br>       <b>EPERM  CLONE_NEWIPC</b>, <b>CLONE_NEWNET</b>, <b>CLONE_NEWNS</b>, <b>CLONE_NEWPID</b>, or<br>              <b>CLONE_NEWUTS </b>was specified by an unprivileged process (process<br>              without <b>CAP_SYS_ADMIN</b>).<br><br>       <b>EPERM  CLONE_PID </b>was specified by a process other than process 0.<br><br>       <b>EPERM  CLONE_NEWUSER </b>was specified in <i>flags</i>, but either the effective<br>              user ID or the effective group ID of the caller does not have<br>              a mapping in the parent namespace (see user_namespaces(7)).<br><br>       <b>EPERM </b>(since Linux 3.9)<br>              <b>CLONE_NEWUSER </b>was specified in <i>flags</i> and the caller is in a<br>              chroot environment (i.e., the caller's root directory does not<br>              match the root directory of the mount namespace in which it<br>              resides).<br><br>       <b>EUSERS </b>(since Linux 3.11)<br>              <b>CLONE_NEWUSER </b>was specified in <i>flags</i>, and the call would cause<br>              the limit on the number of nested user namespaces to be<br>              exceeded.  See user_namespaces(7).<br></pre><br><h2>VERSIONS  </h2><pre><br>       There is no entry for <b>clone</b>() in libc5.  glibc2 provides <b>clone</b>() as<br>       described in this manual page.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>clone</b>() is Linux-specific and should not be used in programs intended<br>       to be portable.<br></pre><br><h2>NOTES  </h2><pre><br>       In the kernel 2.4.x series, <b>CLONE_THREAD </b>generally does not make the<br>       parent of the new thread the same as the parent of the calling<br>       process.  However, for kernel versions 2.4.7 to 2.4.18 the<br>       <b>CLONE_THREAD </b>flag implied the <b>CLONE_PARENT </b>flag (as in kernel 2.6).<br><br>       For a while there was <b>CLONE_DETACHED </b>(introduced in 2.5.32): parent<br>       wants no child-exit signal.  In 2.6.2 the need to give this together<br>       with <b>CLONE_THREAD </b>disappeared.  This flag is still defined, but has<br>       no effect.<br><br>       On i386, <b>clone</b>() should not be called through vsyscall, but directly<br>       through <i>int $0x80</i>.<br></pre><br><h2>BUGS  </h2><pre><br>       Versions of the GNU C library that include the NPTL threading library<br>       contain a wrapper function for getpid(2) that performs caching of<br>       PIDs.  This caching relies on support in the glibc wrapper for<br>       <b>clone</b>(), but as currently implemented, the cache may not be up to<br>       date in some circumstances.  In particular, if a signal is delivered<br>       to the child immediately after the <b>clone</b>() call, then a call to<br>       getpid(2) in a handler for the signal may return the PID of the<br>       calling process (\"the parent\"), if the clone wrapper has not yet had<br>       a chance to update the PID cache in the child.  (This discussion<br>       ignores the case where the child was created using <b>CLONE_THREAD</b>, when<br>       getpid(2) <i>should</i> return the same value in the child and in the<br>       process that called <b>clone</b>(), since the caller and the child are in<br>       the same thread group.  The stale-cache problem also does not occur<br>       if the <i>flags</i> argument includes <b>CLONE_VM</b>.)  To get the truth, it may<br>       be necessary to use code such as the following:<br><br>           #include &lt;syscall.h&gt;<br><br>           pid_t mypid;<br><br>           mypid = syscall(SYS_getpid);<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The following program demonstrates the use of <b>clone</b>() to create a<br>       child process that executes in a separate UTS namespace.  The child<br>       changes the hostname in its UTS namespace.  Both parent and child<br>       then display the system hostname, making it possible to see that the<br>       hostname differs in the UTS namespaces of the parent and child.  For<br>       an example of the use of this program, see setns(2).<br><br>   <b>Program source</b><br>       #define _GNU_SOURCE<br>       #include &lt;sys/wait.h&gt;<br>       #include &lt;sys/utsname.h&gt;<br>       #include &lt;sched.h&gt;<br>       #include &lt;string.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;unistd.h&gt;<br><br>       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\<br>                               } while (0)<br><br>       static int              /* Start function for cloned child */<br>       childFunc(void *arg)<br>       {<br>           struct utsname uts;<br><br>           /* Change hostname in UTS namespace of child */<br><br>           if (sethostname(arg, strlen(arg)) == -1)<br>               errExit(\"sethostname\");<br><br>           /* Retrieve and display hostname */<br><br>           if (uname(&amp;uts) == -1)<br>               errExit(\"uname\");<br>           printf(\"uts.nodename in child:  %s\\n\", uts.nodename);<br><br>           /* Keep the namespace open for a while, by sleeping.<br>              This allows some experimentation--for example, another<br>              process might join the namespace. */<br><br>           sleep(200);<br><br>           return 0;           /* Child terminates now */<br>       }<br><br>       #define STACK_SIZE (1024 * 1024)    /* Stack size for cloned child */<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           char *stack;                    /* Start of stack buffer */<br>           char *stackTop;                 /* End of stack buffer */<br>           pid_t pid;<br>           struct utsname uts;<br><br>           if (argc &lt; 2) {<br>               fprintf(stderr, \"Usage: %s &lt;child-hostname&gt;\\n\", argv[0]);<br>               exit(EXIT_SUCCESS);<br>           }<br><br>           /* Allocate stack for child */<br><br>           stack = malloc(STACK_SIZE);<br>           if (stack == NULL)<br>               errExit(\"malloc\");<br>           stackTop = stack + STACK_SIZE;  /* Assume stack grows downward */<br><br>           /* Create child that has its own UTS namespace;<br>              child commences execution in childFunc() */<br><br>           pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[1]);<br>           if (pid == -1)<br>               errExit(\"clone\");<br>           printf(\"clone() returned %ld\\n\", (long) pid);<br><br>           /* Parent falls through to here */<br><br>           sleep(1);           /* Give child time to change its hostname */<br><br>           /* Display hostname in parent's UTS namespace. This will be<br>              different from hostname in child's UTS namespace. */<br><br>           if (uname(&amp;uts) == -1)<br>               errExit(\"uname\");<br>           printf(\"uts.nodename in parent: %s\\n\", uts.nodename);<br><br>           if (waitpid(pid, NULL, 0) == -1)    /* Wait for child */<br>               errExit(\"waitpid\");<br>           printf(\"child has terminated\\n\");<br><br>           exit(EXIT_SUCCESS);<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       fork(2), futex(2), getpid(2), gettid(2), kcmp(2), set_thread_area(2),<br>       set_tid_address(2), setns(2), tkill(2), unshare(2), wait(2),<br>       capabilities(7), namespaces(7), pthreads(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                         CLONE(2)</span><br></pre><br>"}