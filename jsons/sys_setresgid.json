{"Man page": "<pre><br><span class=\"headline\">SETRESUID(2)              Linux Programmer's Manual             SETRESUID(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       setresuid, setresgid - set real, effective and saved user or group ID<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#define _GNU_SOURCE         </b>/* See feature_test_macros(7) */<br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>int setresuid(uid_t </b><i>ruid</i><b>, uid_t </b><i>euid</i><b>, uid_t </b><i>suid</i><b>);</b><br>       <b>int setresgid(gid_t </b><i>rgid</i><b>, gid_t </b><i>egid</i><b>, gid_t </b><i>sgid</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>setresuid</b>() sets the real user ID, the effective user ID, and the<br>       saved set-user-ID of the calling process.<br><br>       Unprivileged user processes may change the real UID, effective UID,<br>       and saved set-user-ID, each to one of: the current real UID, the<br>       current effective UID or the current saved set-user-ID.<br><br>       Privileged processes (on Linux, those having the <b>CAP_SETUID</b><br>       capability) may set the real UID, effective UID, and saved set-user-<br>       ID to arbitrary values.<br><br>       If one of the arguments equals -1, the corresponding value is not<br>       changed.<br><br>       Regardless of what changes are made to the real UID, effective UID,<br>       and saved set-user-ID, the filesystem UID is always set to the same<br>       value as the (possibly new) effective UID.<br><br>       Completely analogously, <b>setresgid</b>() sets the real GID, effective GID,<br>       and saved set-group-ID of the calling process (and always modifies<br>       the filesystem GID to be the same as the effective GID), with the<br>       same restrictions for unprivileged processes.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, zero is returned.  On error, -1 is returned, and <i>errno</i> is<br>       set appropriately.<br><br>       <i>Note</i>: there are cases where <b>setresuid</b>() can fail even when the caller<br>       is UID 0; it is a grave security error to omit checking for a failure<br>       return from <b>setresuid</b>().<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EAGAIN </b>The call would change the caller's real UID (i.e., <i>ruid</i> does<br>              not match the caller's real UID), but there was a temporary<br>              failure allocating the necessary kernel data structures.<br><br>       <b>EAGAIN </b><i>ruid</i> does not match the caller's real UID and this call would<br>              bring the number of processes belonging to the real user ID<br>              <i>ruid</i> over the caller's <b>RLIMIT_NPROC </b>resource limit.  Since<br>              Linux 3.1, this error case no longer occurs (but robust<br>              applications should check for this error); see the description<br>              of <b>EAGAIN </b>in execve(2).<br><br>       <b>EINVAL </b>One or more of the target user or group IDs is not valid in<br>              this user namespace.<br><br>       <b>EPERM  </b>The calling process is not privileged (did not have the<br>              <b>CAP_SETUID </b>capability) and tried to change the IDs to values<br>              that are not permitted.<br></pre><br><h2>VERSIONS  </h2><pre><br>       These calls are available under Linux since Linux 2.1.44.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       These calls are nonstandard; they also appear on HP-UX and some of<br>       the BSDs.<br></pre><br><h2>NOTES  </h2><pre><br>       Under HP-UX and FreeBSD, the prototype is found in <i>&lt;unistd.h&gt;</i>.  Under<br>       Linux, the prototype is provided by glibc since version 2.3.2.<br><br>       The original Linux <b>setresuid</b>() and <b>setresgid</b>() system calls supported<br>       only 16-bit user and group IDs.  Subsequently, Linux 2.4 added<br>       <b>setresuid32</b>() and <b>setresgid32</b>(), supporting 32-bit IDs.  The glibc<br>       <b>setresuid</b>() and <b>setresgid</b>() wrapper functions transparently deal with<br>       the variations across kernel versions.<br><br>   <b>C library/kernel differences</b><br>       At the kernel level, user IDs and group IDs are a per-thread<br>       attribute.  However, POSIX requires that all threads in a process<br>       share the same credentials.  The NPTL threading implementation<br>       handles the POSIX requirements by providing wrapper functions for the<br>       various system calls that change process UIDs and GIDs.  These<br>       wrapper functions (including those for <b>setresuid</b>() and <b>setresgid</b>())<br>       employ a signal-based technique to ensure that when one thread<br>       changes credentials, all of the other threads in the process also<br>       change their credentials.  For details, see nptl(7).<br></pre><br><h2>SEE ALSO  </h2><pre><br>       getresuid(2), getuid(2), setfsgid(2), setfsuid(2), setreuid(2),<br>       setuid(2), capabilities(7), credentials(7), user_namespaces(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                     SETRESUID(2)</span><br></pre><br>"}