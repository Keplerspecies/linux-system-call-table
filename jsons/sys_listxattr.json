{"Man page": "<pre><br><span class=\"headline\">LISTXATTR(2)              Linux Programmer's Manual             LISTXATTR(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       listxattr, llistxattr, flistxattr - list extended attribute names<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/types.h&gt;</b><br>       <b>#include &lt;sys/xattr.h&gt;</b><br><br>       <b>ssize_t listxattr(const char *</b><i>path</i><b>, char *</b><i>list</i><b>, size_t </b><i>size</i><b>);</b><br>       <b>ssize_t llistxattr(const char *</b><i>path</i><b>, char *</b><i>list</i><b>, size_t </b><i>size</i><b>);</b><br>       <b>ssize_t flistxattr(int </b><i>fd</i><b>, char *</b><i>list</i><b>, size_t </b><i>size</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       Extended attributes are <i>name</i>:<i>value</i> pairs associated with inodes<br>       (files, directories, symbolic links, etc.).  They are extensions to<br>       the normal attributes which are associated with all inodes in the<br>       system (i.e., the stat(2) data).  A complete overview of extended<br>       attributes concepts can be found in xattr(7).<br><br>       <b>listxattr</b>() retrieves the list of extended attribute names associated<br>       with the given <i>path</i> in the filesystem.  The retrieved list is placed<br>       in <i>list</i>, a caller-allocated buffer whose size (in bytes) is specified<br>       in the argument <i>size</i>.  The list is the set of (null-terminated)<br>       names, one after the other.  Names of extended attributes to which<br>       the calling process does not have access may be omitted from the<br>       list.  The length of the attribute name <i>list</i> is returned.<br><br>       <b>llistxattr</b>() is identical to <b>listxattr</b>(), except in the case of a<br>       symbolic link, where the list of names of extended attributes<br>       associated with the link itself is retrieved, not the file that it<br>       refers to.<br><br>       <b>flistxattr</b>() is identical to <b>listxattr</b>(), only the open file referred<br>       to by <i>fd</i> (as returned by open(2)) is interrogated in place of <i>path</i>.<br><br>       A single extended attribute <i>name</i> is a null-terminated string.  The<br>       name includes a namespace prefix; there may be several, disjoint<br>       namespaces associated with an individual inode.<br><br>       If <i>size</i> is specified as zero, these calls return the current size of<br>       the list of extended attribute names (and leave <i>list</i> unchanged).<br>       This can be used to determine the size of the buffer that should be<br>       supplied in a subsequent call.  (But, bear in mind that there is a<br>       possibility that the set of extended attributes may change between<br>       the two calls, so that it is still necessary to check the return<br>       status from the second call.)<br><br>   <b>Example</b><br>       The <i>list</i> of names is returned as an unordered array of null-<br>       terminated character strings (attribute names are separated by null<br>       bytes ('\\0')), like this:<br><br>              user.name1\\0system.name1\\0user.name2\\0<br><br>       Filesystems that implement POSIX ACLs using extended attributes might<br>       return a <i>list</i> like this:<br><br>              system.posix_acl_access\\0system.posix_acl_default\\0<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, a nonnegative number is returned indicating the size of<br>       the extended attribute name list.  On failure, -1 is returned and<br>       <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>E2BIG  </b>The size of the list of attribute names for this file exceeds<br>              the system-imposed limit.  See BUGS.<br><br>       <b>ENOTSUP</b><br>              Extended attributes are not supported by the filesystem, or<br>              are disabled.<br><br>       <b>ERANGE </b>The <i>size</i> of the <i>list</i> buffer is too small to hold the result.<br><br>       In addition, the errors documented in stat(2) can also occur.<br></pre><br><h2>VERSIONS  </h2><pre><br>       These system calls have been available on Linux since kernel 2.4;<br>       glibc support is provided since version 2.3.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       These system calls are Linux-specific.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The following program demonstrates the usage of <b>listxattr</b>() and<br>       getxattr(2).  For the file whose pathname is provided as a command-<br>       line argument, it lists all extended file attributes and their<br>       values.<br><br>       To keep the code simple, the program assumes that attribute keys and<br>       values are constant during the execution of the program.  A<br>       production program should expect and handle changes during execution<br>       of the program.  For example, the number of bytes required for<br>       attribute keys might increase between the two calls to <b>listxattr</b>().<br>       An application could handle this possibility using a loop that<br>       retries the call (perhaps up to a predetermined maximum number of<br>       attempts) with a larger buffer each time it fails with the error<br>       <b>ERANGE</b>.  Calls to getxattr(2) could be handled similarly.<br><br>       The following output was recorded by first creating a file, setting<br>       some extended file attributes, and then listing the attributes with<br>       the example program.<br><br>   <b>Example output</b><br>           $ <b>touch /tmp/foo</b><br>           $ <b>setfattr -n user.fred -v chocolate /tmp/foo</b><br>           $ <b>setfattr -n user.frieda -v bar /tmp/foo</b><br>           $ <b>setfattr -n user.empty /tmp/foo</b><br>           $ <b>./listxattr /tmp/foo</b><br>           user.fred: chocolate<br>           user.frieda: bar<br>           user.empty: &lt;no value&gt;<br><br>   <b>Program source (listxattr.c)</b><br>       #include &lt;malloc.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;string.h&gt;<br>       #include &lt;sys/types.h&gt;<br>       #include &lt;sys/xattr.h&gt;<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           ssize_t buflen, keylen, vallen;<br>           char *buf, *key, *val;<br><br>           if (argc != 2) {<br>               fprintf(stderr, \"Usage: %s path\\n\", argv[0]);<br>               exit(EXIT_FAILURE);<br>           }<br><br>           /*<br>            * Determine the length of the buffer needed.<br>            */<br>           buflen = listxattr(argv[1], NULL, 0);<br>           if (buflen == -1) {<br>               perror(\"listxattr\");<br>               exit(EXIT_FAILURE);<br>           }<br>           if (buflen == 0) {<br>               printf(\"%s has no attributes.\\n\", argv[1]);<br>               exit(EXIT_SUCCESS);<br>           }<br><br>           /*<br>            * Allocate the buffer.<br>            */<br>           buf = malloc(buflen);<br>           if (buf == NULL) {<br>               perror(\"malloc\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           /*<br>            * Copy the list of attribute keys to the buffer.<br>            */<br>           buflen = listxattr(argv[1], buf, buflen);<br>           if (buflen == -1) {<br>               perror(\"listxattr\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           /*<br>            * Loop over the list of zero terminated strings with the<br>            * attribute keys. Use the remaining buffer length to determine<br>            * the end of the list.<br>            */<br>           key = buf;<br>           while (buflen &gt; 0) {<br><br>               /*<br>                * Output attribute key.<br>                */<br>               printf(\"%s: \", key);<br><br>               /*<br>                * Determine length of the value.<br>                */<br>               vallen = getxattr(argv[1], key, NULL, 0);<br>               if (vallen == -1)<br>                   perror(\"getxattr\");<br><br>               if (vallen &gt; 0) {<br><br>                   /*<br>                    * Allocate value buffer.<br>                    * One extra byte is needed to append 0x00.<br>                    */<br>                   val = malloc(vallen + 1);<br>                   if (val == NULL) {<br>                       perror(\"malloc\");<br>                       exit(EXIT_FAILURE);<br>                   }<br><br>                   /*<br>                    * Copy value to buffer.<br>                    */<br>                   vallen = getxattr(argv[1], key, val, vallen);<br>                   if (vallen == -1)<br>                       perror(\"getxattr\");<br>                   else {<br>                       /*<br>                        * Output attribute value.<br>                        */<br>                       val[vallen] = 0;<br>                       printf(\"%s\", val);<br>                   }<br><br>                   free(val);<br>               } else if (vallen == 0)<br>                   printf(\"&lt;no value&gt;\");<br><br>               printf(\"\\n\");<br><br>               /*<br>                * Forward to next attribute key.<br>                */<br>               keylen = strlen(key) + 1;<br>               buflen -= keylen;<br>               key += keylen;<br>           }<br><br>           free(buf);<br>           exit(EXIT_SUCCESS);<br>       }<br></pre><br><h2>BUGS  </h2><pre><br>       As noted in xattr(7), the VFS imposes a limit of 64 kB on the size of<br>       the extended attribute name list returned by <b>listxattr</b>(7).  If the<br>       total size of attribute names attached to a file exceeds this limit,<br>       it is no longer possible to retrieve the list of attribute names.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       getfattr(1), setfattr(1), getxattr(2), open(2), removexattr(2),<br>       setxattr(2), stat(2), symlink(7), xattr(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-05-07                     LISTXATTR(2)</span><br></pre><br>"}