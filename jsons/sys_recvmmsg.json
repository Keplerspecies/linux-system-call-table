{"Man page": "<pre><br><span class=\"headline\">RECVMMSG(2)               Linux Programmer's Manual              RECVMMSG(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       recvmmsg - receive multiple messages on a socket<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#define _GNU_SOURCE         </b>/* See feature_test_macros(7) */<br>       <b>#include &lt;sys/socket.h&gt;</b><br><br>       <b>int recvmmsg(int </b><i>sockfd</i><b>, struct mmsghdr *</b><i>msgvec</i><b>, unsigned int </b><i>vlen</i><b>,</b><br>                    <b>unsigned int </b><i>flags</i><b>, struct timespec *</b><i>timeout</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>recvmmsg</b>() system call is an extension of recvmsg(2) that allows<br>       the caller to receive multiple messages from a socket using a single<br>       system call.  (This has performance benefits for some applications.)<br>       A further extension over recvmsg(2) is support for a timeout on the<br>       receive operation.<br><br>       The <i>sockfd</i> argument is the file descriptor of the socket to receive<br>       data from.<br><br>       The <i>msgvec</i> argument is a pointer to an array of <i>mmsghdr</i> structures.<br>       The size of this array is specified in <i>vlen</i>.<br><br>       The <i>mmsghdr</i> structure is defined in <i>&lt;sys/socket.h&gt;</i> as:<br><br>           struct mmsghdr {<br>               struct msghdr msg_hdr;  /* Message header */<br>               unsigned int  msg_len;  /* Number of received bytes for header */<br>           };<br><br>       The <i>msg_hdr</i> field is a <i>msghdr</i> structure, as described in recvmsg(2).<br>       The <i>msg_len</i> field is the number of bytes returned for the message in<br>       the entry.  This field has the same value as the return value of a<br>       single recvmsg(2) on the header.<br><br>       The <i>flags</i> argument contains flags ORed together.  The flags are the<br>       same as documented for recvmsg(2), with the following addition:<br><br>       <b>MSG_WAITFORONE </b>(since Linux 2.6.34)<br>              Turns on <b>MSG_DONTWAIT </b>after the first message has been<br>              received.<br><br>       The <i>timeout</i> argument points to a <i>struct timespec</i> (see<br>       clock_gettime(2)) defining a timeout (seconds plus nanoseconds) for<br>       the receive operation (<i>but see BUGS!</i>).  (This interval will be<br>       rounded up to the system clock granularity, and kernel scheduling<br>       delays mean that the blocking interval may overrun by a small<br>       amount.)  If <i>timeout</i> is NULL, then the operation blocks indefinitely.<br><br>       A blocking <b>recvmmsg</b>() call blocks until <i>vlen</i> messages have been<br>       received or until the timeout expires.  A nonblocking call reads as<br>       many messages as are available (up to the limit specified by <i>vlen</i>)<br>       and returns immediately.<br><br>       On return from <b>recvmmsg</b>(), successive elements of <i>msgvec</i> are updated<br>       to contain information about each received message: <i>msg_len</i> contains<br>       the size of the received message; the subfields of <i>msg_hdr</i> are<br>       updated as described in recvmsg(2).  The return value of the call<br>       indicates the number of elements of <i>msgvec</i> that have been updated.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>recvmmsg</b>() returns the number of messages received in<br>       <i>msgvec</i>; on error, -1 is returned, and <i>errno</i> is set to indicate the<br>       error.<br></pre><br><h2>ERRORS  </h2><pre><br>       Errors are as for recvmsg(2).  In addition, the following error can<br>       occur:<br><br>       <b>EINVAL </b><i>timeout</i> is invalid.<br></pre><br><h2>VERSIONS  </h2><pre><br>       The <b>recvmmsg</b>() system call was added in Linux 2.6.33.  Support in<br>       glibc was added in version 2.12.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>recvmmsg</b>() is Linux-specific.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The following program uses <b>recvmmsg</b>() to receive multiple messages on<br>       a socket and stores them in multiple buffers.  The call returns if<br>       all buffers are filled or if the timeout specified has expired.<br><br>       The following snippet periodically generates UDP datagrams containing<br>       a random number:<br><br>           $ <b>while true; do echo $RANDOM &gt; /dev/udp/127.0.0.1/1234;</b><br>                 <b>sleep 0.25; done</b><br><br>       These datagrams are read by the example application, which can give<br>       the following output:<br><br>           $ <b>./a.out</b><br>           5 messages received<br>           1 11782<br>           2 11345<br>           3 304<br>           4 13514<br>           5 28421<br><br>   <b>Program source</b><br><br>       #define _GNU_SOURCE<br>       #include &lt;netinet/ip.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;string.h&gt;<br>       #include &lt;sys/socket.h&gt;<br><br>       int<br>       main(void)<br>       {<br>       #define VLEN 10<br>       #define BUFSIZE 200<br>       #define TIMEOUT 1<br>           int sockfd, retval, i;<br>           struct sockaddr_in sa;<br>           struct mmsghdr msgs[VLEN];<br>           struct iovec iovecs[VLEN];<br>           char bufs[VLEN][BUFSIZE+1];<br>           struct timespec timeout;<br><br>           sockfd = socket(AF_INET, SOCK_DGRAM, 0);<br>           if (sockfd == -1) {<br>               perror(\"socket()\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           sa.sin_family = AF_INET;<br>           sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);<br>           sa.sin_port = htons(1234);<br>           if (bind(sockfd, (struct sockaddr *) &amp;sa, sizeof(sa)) == -1) {<br>               perror(\"bind()\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           memset(msgs, 0, sizeof(msgs));<br>           for (i = 0; i &lt; VLEN; i++) {<br>               iovecs[i].iov_base         = bufs[i];<br>               iovecs[i].iov_len          = BUFSIZE;<br>               msgs[i].msg_hdr.msg_iov    = &amp;iovecs[i];<br>               msgs[i].msg_hdr.msg_iovlen = 1;<br>           }<br><br>           timeout.tv_sec = TIMEOUT;<br>           timeout.tv_nsec = 0;<br><br>           retval = recvmmsg(sockfd, msgs, VLEN, 0, &amp;timeout);<br>           if (retval == -1) {<br>               perror(\"recvmmsg()\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           printf(\"%d messages received\\n\", retval);<br>           for (i = 0; i &lt; retval; i++) {<br>               bufs[i][msgs[i].msg_len] = 0;<br>               printf(\"%d %s\", i+1, bufs[i]);<br>           }<br>           exit(EXIT_SUCCESS);<br>       }<br></pre><br><h2>BUGS  </h2><pre><br>       The <i>timeout</i> argument does not work as intended.  The timeout is<br>       checked only after the receipt of each datagram, so that if up to<br>       <i>vlen-1</i> datagrams are received before the timeout expires, but then no<br>       further datagrams are received, the call will block forever.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       clock_gettime(2), recvmsg(2), sendmmsg(2), sendmsg(2), socket(2),<br>       socket(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2014-06-13                      RECVMMSG(2)</span><br></pre><br>"}