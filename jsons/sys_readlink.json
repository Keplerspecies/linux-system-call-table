{"Man page": "<pre><br><span class=\"headline\">READLINK(2)               Linux Programmer's Manual              READLINK(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       readlink, readlinkat - read value of a symbolic link<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>ssize_t readlink(const char *</b><i>pathname</i><b>, char *</b><i>buf</i><b>, size_t </b><i>bufsiz</i><b>);</b><br><br>       <b>#include &lt;fcntl.h&gt;           </b>/* Definition of AT_* constants */<br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>ssize_t readlinkat(int </b><i>dirfd</i><b>, const char *</b><i>pathname</i><b>,</b><br>                          <b>char *</b><i>buf</i><b>, size_t </b><i>bufsiz</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>readlink</b>():<br>           _BSD_SOURCE || _XOPEN_SOURCE &gt;= 500 ||<br>           _XOPEN_SOURCE &amp;&amp; _XOPEN_SOURCE_EXTENDED ||<br>           _POSIX_C_SOURCE &gt;= 200112L<br><br>       <b>readlinkat</b>():<br>           Since glibc 2.10:<br>               _XOPEN_SOURCE &gt;= 700 || _POSIX_C_SOURCE &gt;= 200809L<br>           Before glibc 2.10:<br>               _ATFILE_SOURCE<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>readlink</b>() places the contents of the symbolic link <i>pathname</i> in the<br>       buffer <i>buf</i>, which has size <i>bufsiz</i>.  <b>readlink</b>() does not append a null<br>       byte to <i>buf</i>.  It will truncate the contents (to a length of <i>bufsiz</i><br>       characters), in case the buffer is too small to hold all of the<br>       contents.<br><br>   <b>readlinkat()</b><br>       The <b>readlinkat</b>() system call operates in exactly the same way as<br>       <b>readlink</b>(), except for the differences described here.<br><br>       If the pathname given in <i>pathname</i> is relative, then it is interpreted<br>       relative to the directory referred to by the file descriptor <i>dirfd</i><br>       (rather than relative to the current working directory of the calling<br>       process, as is done by <b>readlink</b>() for a relative pathname).<br><br>       If <i>pathname</i> is relative and <i>dirfd</i> is the special value <b>AT_FDCWD</b>, then<br>       <i>pathname</i> is interpreted relative to the current working directory of<br>       the calling process (like <b>readlink</b>()).<br><br>       If <i>pathname</i> is absolute, then <i>dirfd</i> is ignored.<br><br>       Since Linux 2.6.39, <i>pathname</i> can be an empty string, in which case<br>       the call operates on the symbolic link referred to by <i>dirfd</i> (which<br>       should have been obtained using open(2) with the <b>O_PATH </b>and<br>       <b>O_NOFOLLOW </b>flags).<br><br>       See openat(2) for an explanation of the need for <b>readlinkat</b>().<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, these calls return the number of bytes placed in <i>buf</i>.  On<br>       error, -1 is returned and <i>errno</i> is set to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EACCES </b>Search permission is denied for a component of the path<br>              prefix.  (See also path_resolution(7).)<br><br>       <b>EFAULT </b><i>buf</i> extends outside the process's allocated address space.<br><br>       <b>EINVAL </b><i>bufsiz</i> is not positive.<br><br>       <b>EINVAL </b>The named file is not a symbolic link.<br><br>       <b>EIO    </b>An I/O error occurred while reading from the filesystem.<br><br>       <b>ELOOP  </b>Too many symbolic links were encountered in translating the<br>              pathname.<br><br>       <b>ENAMETOOLONG</b><br>              A pathname, or a component of a pathname, was too long.<br><br>       <b>ENOENT </b>The named file does not exist.<br><br>       <b>ENOMEM </b>Insufficient kernel memory was available.<br><br>       <b>ENOTDIR</b><br>              A component of the path prefix is not a directory.<br><br>       The following additional errors can occur for <b>readlinkat</b>():<br><br>       <b>EBADF  </b><i>dirfd</i> is not a valid file descriptor.<br><br>       <b>ENOTDIR</b><br>              <i>pathname</i> is relative and <i>dirfd</i> is a file descriptor referring<br>              to a file other than a directory.<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>readlinkat</b>() was added to Linux in kernel 2.6.16; library support was<br>       added to glibc in version 2.4.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>readlink</b>(): 4.4BSD (<b>readlink</b>() first appeared in 4.2BSD),<br>       POSIX.1-2001, POSIX.1-2008.<br><br>       <b>readlinkat</b>(): POSIX.1-2008.<br></pre><br><h2>NOTES  </h2><pre><br>       In versions of glibc up to and including glibc 2.4, the return type<br>       of <b>readlink</b>() was declared as <i>int</i>.  Nowadays, the return type is<br>       declared as <i>ssize_t</i>, as (newly) required in POSIX.1-2001.<br><br>       Using a statically sized buffer might not provide enough room for the<br>       symbolic link contents.  The required size for the buffer can be<br>       obtained from the <i>stat.st_size</i> value returned by a call to lstat(2)<br>       on the link.  However, the number of bytes written by <b>readlink</b>() and<br>       <b>readlinkat</b>() should be checked to make sure that the size of the<br>       symbolic link did not increase between the calls.  Dynamically<br>       allocating the buffer for <b>readlink</b>() and <b>readlinkat</b>() also addresses<br>       a common portability problem when using <i>PATH_MAX</i> for the buffer size,<br>       as this constant is not guaranteed to be defined per POSIX if the<br>       system does not have such limit.<br><br>   <b>Glibc notes</b><br>       On older kernels where <b>readlinkat</b>() is unavailable, the glibc wrapper<br>       function falls back to the use of <b>readlink</b>().  When <i>pathname</i> is a<br>       relative pathname, glibc constructs a pathname based on the symbolic<br>       link in <i>/proc/self/fd</i> that corresponds to the <i>dirfd</i> argument.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The following program allocates the buffer needed by <b>readlink</b>()<br>       dynamically from the information provided by <b>lstat</b>(), making sure<br>       there's no race condition between the calls.<br><br>       #include &lt;sys/types.h&gt;<br>       #include &lt;sys/stat.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;unistd.h&gt;<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           struct stat sb;<br>           char *linkname;<br>           ssize_t r;<br><br>           if (argc != 2) {<br>               fprintf(stderr, \"Usage: %s &lt;pathname&gt;\\n\", argv[0]);<br>               exit(EXIT_FAILURE);<br>           }<br><br>           if (lstat(argv[1], &amp;sb) == -1) {<br>               perror(\"lstat\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           linkname = malloc(sb.st_size + 1);<br>           if (linkname == NULL) {<br>               fprintf(stderr, \"insufficient memory\\n\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           r = readlink(argv[1], linkname, sb.st_size + 1);<br><br>           if (r == -1) {<br>               perror(\"readlink\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           if (r &gt; sb.st_size) {<br>               fprintf(stderr, \"symlink increased in size \"<br>                               \"between lstat() and readlink()\\n\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           linkname[r] = '\\0';<br><br>           printf(\"'%s' points to '%s'\\n\", argv[1], linkname);<br><br>           free(linkname);<br><br>           exit(EXIT_SUCCESS);<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       readlink(1), lstat(2), stat(2), symlink(2), realpath(3),<br>       path_resolution(7), symlink(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2014-10-15                      READLINK(2)</span><br></pre><br>"}