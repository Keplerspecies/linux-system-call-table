{"Man page": "<pre><br><span class=\"headline\">SECCOMP(2)                Linux Programmer's Manual               SECCOMP(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       seccomp - operate on Secure Computing state of the process<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;linux/seccomp.h&gt;</b><br>       <b>#include &lt;linux/filter.h&gt;</b><br>       <b>#include &lt;linux/audit.h&gt;</b><br>       <b>#include &lt;linux/signal.h&gt;</b><br>       <b>#include &lt;sys/ptrace.h&gt;</b><br><br>       <b>int seccomp(unsigned int </b><i>operation</i><b>, unsigned int </b><i>flags</i><b>, void *</b><i>args</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>seccomp</b>() system call operates on the Secure Computing (seccomp)<br>       state of the calling process.<br><br>       Currently, Linux supports the following <i>operation</i> values:<br><br>       <b>SECCOMP_SET_MODE_STRICT</b><br>              The only system calls that the calling thread is permitted to<br>              make are read(2), write(2), _exit(2) (but not exit_group(2)),<br>              and sigreturn(2).  Other system calls result in the delivery<br>              of a <b>SIGKILL </b>signal.  Strict secure computing mode is useful<br>              for number-crunching applications that may need to execute<br>              untrusted byte code, perhaps obtained by reading from a pipe<br>              or socket.<br><br>              Note that although the calling thread can no longer call<br>              sigprocmask(2), it can use sigreturn(2) to block all signals<br>              apart from <b>SIGKILL </b>and <b>SIGSTOP</b>.  This means that alarm(2) (for<br>              example) is not sufficient for restricting the process's<br>              execution time.  Instead, to reliably terminate the process,<br>              <b>SIGKILL </b>must be used.  This can be done by using<br>              timer_create(2) with <b>SIGEV_SIGNAL </b>and <i>sigev_signo</i> set to<br>              <b>SIGKILL</b>, or by using setrlimit(2) to set the hard limit for<br>              <b>RLIMIT_CPU</b>.<br><br>              This operation is available only if the kernel is configured<br>              with <b>CONFIG_SECCOMP </b>enabled.<br><br>              The value of <i>flags</i> must be 0, and <i>args</i> must be NULL.<br><br>              This operation is functionally identical to the call:<br><br>                  prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);<br><br>       <b>SECCOMP_SET_MODE_FILTER</b><br>              The system calls allowed are defined by a pointer to a<br>              Berkeley Packet Filter (BPF) passed via <i>args</i>.  This argument<br>              is a pointer to a <i>struct sock_fprog</i>; it can be designed to<br>              filter arbitrary system calls and system call arguments.  If<br>              the filter is invalid, <b>seccomp</b>() fails, returning <b>EINVAL </b>in<br>              <i>errno</i>.<br><br>              If fork(2) or clone(2) is allowed by the filter, any child<br>              processes will be constrained to the same system call filters<br>              as the parent.  If execve(2) is allowed, the existing filters<br>              will be preserved across a call to execve(2).<br><br>              In order to use the <b>SECCOMP_SET_MODE_FILTER </b>operation, either<br>              the caller must have the <b>CAP_SYS_ADMIN </b>capability, or the<br>              thread must already have the <i>no_new_privs</i> bit set.  If that<br>              bit was not already set by an ancestor of this thread, the<br>              thread must make the following call:<br><br>                  prctl(PR_SET_NO_NEW_PRIVS, 1);<br><br>              Otherwise, the <b>SECCOMP_SET_MODE_FILTER </b>operation will fail and<br>              return <b>EACCES </b>in <i>errno</i>.  This requirement ensures that an<br>              unprivileged process cannot apply a malicious filter and then<br>              invoke a set-user-ID or other privileged program using<br>              execve(2), thus potentially compromising that program.  (Such<br>              a malicious filter might, for example, cause an attempt to use<br>              setuid(2) to set the caller's user IDs to non-zero values to<br>              instead return 0 without actually making the system call.<br>              Thus, the program might be tricked into retaining superuser<br>              privileges in circumstances where it is possible to influence<br>              it to do dangerous things because it did not actually drop<br>              privileges.)<br><br>              If prctl(2) or seccomp(2) is allowed by the attached filter,<br>              further filters may be added.  This will increase evaluation<br>              time, but allows for further reduction of the attack surface<br>              during execution of a thread.<br><br>              The <b>SECCOMP_SET_MODE_FILTER </b>operation is available only if the<br>              kernel is configured with <b>CONFIG_SECCOMP_FILTER </b>enabled.<br><br>              When <i>flags</i> is 0, this operation is functionally identical to<br>              the call:<br><br>                  prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, args);<br><br>              The recognized <i>flags</i> are:<br><br>              <b>SECCOMP_FILTER_FLAG_TSYNC</b><br>                     When adding a new filter, synchronize all other threads<br>                     of the calling process to the same seccomp filter tree.<br>                     A \"filter tree\" is the ordered list of filters attached<br>                     to a thread.  (Attaching identical filters in separate<br>                     <b>seccomp</b>() calls results in different filters from this<br>                     perspective.)<br><br>                     If any thread cannot synchronize to the same filter<br>                     tree, the call will not attach the new seccomp filter,<br>                     and will fail, returning the first thread ID found that<br>                     cannot synchronize.  Synchronization will fail if<br>                     another thread in the same process is in<br>                     <b>SECCOMP_MODE_STRICT </b>or if it has attached new seccomp<br>                     filters to itself, diverging from the calling thread's<br>                     filter tree.<br><br>   <b>Filters</b><br>       When adding filters via <b>SECCOMP_SET_MODE_FILTER</b>, <i>args</i> points to a<br>       filter program:<br><br>           struct sock_fprog {<br>               unsigned short      len;    /* Number of BPF instructions */<br>               struct sock_filter *filter; /* Pointer to array of<br>                                              BPF instructions */<br>           };<br><br>       Each program must contain one or more BPF instructions:<br><br>           struct sock_filter {            /* Filter block */<br>               __u16 code;                 /* Actual filter code */<br>               __u8  jt;                   /* Jump true */<br>               __u8  jf;                   /* Jump false */<br>               __u32 k;                    /* Generic multiuse field */<br>           };<br><br>       When executing the instructions, the BPF program operates on the<br>       system call information made available (i.e., use the <b>BPF_ABS</b><br>       addressing mode) as a (read-only) buffer of the following form:<br><br>           struct seccomp_data {<br>               int   nr;                   /* System call number */<br>               __u32 arch;                 /* AUDIT_ARCH_* value<br>                                              (see &lt;linux/audit.h&gt;) */<br>               __u64 instruction_pointer;  /* CPU instruction pointer */<br>               __u64 args[6];              /* Up to 6 system call arguments */<br>           };<br><br>       Because the numbers of system calls vary between architectures and<br>       some architectures (e.g., x86-64) allow user-space code to use the<br>       calling conventions of multiple architectures, it is usually<br>       necessary to verify the value of the <i>arch</i> field.<br><br>       It is strongly recommended to use a whitelisting approach whenever<br>       possible because such an approach is more robust and simple.  A<br>       blacklist will have to be updated whenever a potentially dangerous<br>       system call is added (or a dangerous flag or option if those are<br>       blacklisted), and it is often possible to alter the representation of<br>       a value without altering its meaning, leading to a blacklist bypass.<br><br>       The <i>arch</i> field is not unique for all calling conventions.  The x86-64<br>       ABI and the x32 ABI both use <b>AUDIT_ARCH_X86_64 </b>as <i>arch</i>, and they run<br>       on the same processors.  Instead, the mask <b>__X32_SYSCALL_BIT </b>is used<br>       on the system call number to tell the two ABIs apart.<br><br>       This means that in order to create a seccomp-based blacklist for<br>       system calls performed through the x86-64 ABI, it is necessary to not<br>       only check that <i>arch</i> equals <b>AUDIT_ARCH_X86_64</b>, but also to explicitly<br>       reject all system calls that contain <b>__X32_SYSCALL_BIT </b>in <i>nr</i>.<br><br>       When checking values from <i>args</i> against a blacklist, keep in mind that<br>       arguments are often silently truncated before being processed, but<br>       after the seccomp check.  For example, this happens if the i386 ABI<br>       is used on an x86-64 kernel: although the kernel will normally not<br>       look beyond the 32 lowest bits of the arguments, the values of the<br>       full 64-bit registers will be present in the seccomp data.  A less<br>       surprising example is that if the x86-64 ABI is used to perform a<br>       system call that takes an argument of type <i>int</i>, the more-significant<br>       half of the argument register is ignored by the system call, but<br>       visible in the seccomp data.<br><br>       A seccomp filter returns a 32-bit value consisting of two parts: the<br>       most significant 16 bits (corresponding to the mask defined by the<br>       constant <b>SECCOMP_RET_ACTION</b>) contain one of the \"action\" values<br>       listed below; the least significant 16-bits (defined by the constant<br>       <b>SECCOMP_RET_DATA</b>) are \"data\" to be associated with this return value.<br><br>       If multiple filters exist, they are all executed, in reverse order of<br>       their addition to the filter tree (i.e., the most recently installed<br>       filter is executed first).  The return value for the evaluation of a<br>       given system call is the first-seen <b>SECCOMP_RET_ACTION </b>value of<br>       highest precedence (along with its accompanying data) returned by<br>       execution of all of the filters.<br><br>       In decreasing order of precedence, the values that may be returned by<br>       a seccomp filter are:<br><br>       <b>SECCOMP_RET_KILL</b><br>              This value results in the process exiting immediately without<br>              executing the system call.  The process terminates as though<br>              killed by a <b>SIGSYS </b>signal (<i>not</i> <b>SIGKILL</b>).<br><br>       <b>SECCOMP_RET_TRAP</b><br>              This value results in the kernel sending a <b>SIGSYS </b>signal to<br>              the triggering process without executing the system call.<br>              Various fields will be set in the <i>siginfo_t</i> structure (see<br>              sigaction(2)) associated with signal:<br><br>              *  <i>si_signo</i> will contain <b>SIGSYS</b>.<br><br>              *  <i>si_call_addr</i> will show the address of the system call<br>                 instruction.<br><br>              *  <i>si_syscall</i> and <i>si_arch</i> will indicate which system call was<br>                 attempted.<br><br>              *  <i>si_code</i> will contain <b>SYS_SECCOMP</b>.<br><br>              *  <i>si_errno</i> will contain the <b>SECCOMP_RET_DATA </b>portion of the<br>                 filter return value.<br><br>              The program counter will be as though the system call happened<br>              (i.e., it will not point to the system call instruction).  The<br>              return value register will contain an architecture-dependent<br>              value; if resuming execution, set it to something appropriate<br>              for the system call.  (The architecture dependency is because<br>              replacing it with <b>ENOSYS </b>could overwrite some useful<br>              information.)<br><br>       <b>SECCOMP_RET_ERRNO</b><br>              This value results in the <b>SECCOMP_RET_DATA </b>portion of the<br>              filter's return value being passed to user space as the <i>errno</i><br>              value without executing the system call.<br><br>       <b>SECCOMP_RET_TRACE</b><br>              When returned, this value will cause the kernel to attempt to<br>              notify a ptrace(2)-based tracer prior to executing the system<br>              call.  If there is no tracer present, the system call is not<br>              executed and returns a failure status with <i>errno</i> set to<br>              <b>ENOSYS</b>.<br><br>              A tracer will be notified if it requests <b>PTRACE_O_TRACESECCOMP</b><br>              using <i>ptrace(PTRACE_SETOPTIONS)</i>.  The tracer will be notified<br>              of a <b>PTRACE_EVENT_SECCOMP </b>and the <b>SECCOMP_RET_DATA </b>portion of<br>              the filter's return value will be available to the tracer via<br>              <b>PTRACE_GETEVENTMSG</b>.<br><br>              The tracer can skip the system call by changing the system<br>              call number to -1.  Alternatively, the tracer can change the<br>              system call requested by changing the system call to a valid<br>              system call number.  If the tracer asks to skip the system<br>              call, then the system call will appear to return the value<br>              that the tracer puts in the return value register.<br><br>              The seccomp check will not be run again after the tracer is<br>              notified.  (This means that seccomp-based sandboxes <b>must not</b><br>              allow use of ptrace(2)&#8212;even of other sandboxed processes&#8212;<br>              without extreme care; ptracers can use this mechanism to<br>              escape from the seccomp sandbox.)<br><br>       <b>SECCOMP_RET_ALLOW</b><br>              This value results in the system call being executed.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>seccomp</b>() returns 0.  On error, if<br>       <b>SECCOMP_FILTER_FLAG_TSYNC </b>was used, the return value is the ID of the<br>       thread that caused the synchronization failure.  (This ID is a kernel<br>       thread ID of the type returned by clone(2) and gettid(2).)  On other<br>       errors, -1 is returned, and <i>errno</i> is set to indicate the cause of the<br>       error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>seccomp</b>() can fail for the following reasons:<br><br>       <b>EACCESS</b><br>              The caller did not have the <b>CAP_SYS_ADMIN </b>capability, or had<br>              not set <i>no_new_privs</i> before using <b>SECCOMP_SET_MODE_FILTER</b>.<br><br>       <b>EFAULT </b><i>args</i> was not a valid address.<br><br>       <b>EINVAL </b><i>operation</i> is unknown; or <i>flags</i> are invalid for the given<br>              <i>operation</i>.<br><br>       <b>EINVAL </b><i>operation</i> included <b>BPF_ABS</b>, but the specified offset was not<br>              aligned to a 32-bit boundary or exceeded<br>              <i>sizeof(struct seccomp_data)</i>.<br><br>       <b>EINVAL </b>A secure computing mode has already been set, and <i>operation</i><br>              differs from the existing setting.<br><br>       <b>EINVAL </b><i>operation</i> specified <b>SECCOMP_SET_MODE_FILTER</b>, but the kernel<br>              was not built with <b>CONFIG_SECCOMP_FILTER </b>enabled.<br><br>       <b>EINVAL </b><i>operation</i> specified <b>SECCOMP_SET_MODE_FILTER</b>, but the filter<br>              program pointed to by <i>args</i> was not valid or the length of the<br>              filter program was zero or exceeded <b>BPF_MAXINSNS </b>(4096)<br>              instructions.<br><br>       <b>ENOMEM </b>Out of memory.<br><br>       <b>ENOMEM </b>The total length of all filter programs attached to the<br>              calling thread would exceed <b>MAX_INSNS_PER_PATH </b>(32768)<br>              instructions.  Note that for the purposes of calculating this<br>              limit, each already existing filter program incurs an overhead<br>              penalty of 4 instructions.<br><br>       <b>ESRCH  </b>Another thread caused a failure during thread sync, but its ID<br>              could not be determined.<br></pre><br><h2>VERSIONS  </h2><pre><br>       The <b>seccomp</b>() system call first appeared in Linux 3.17.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       The <b>seccomp</b>() system call is a nonstandard Linux extension.<br></pre><br><h2>NOTES  </h2><pre><br>       Rather than hand-coding seccomp filters as shown in the example<br>       below, you may prefer to employ the <i>libseccomp</i> library, which<br>       provides a front-end for generating seccomp filters.<br><br>       The <i>Seccomp</i> field of the <i>/proc/[pid]/status</i> file provides a method of<br>       viewing the seccomp mode of a process; see proc(5).<br><br>       <b>seccomp</b>() provides a superset of the functionality provided by the<br>       prctl(2) <b>PR_SET_SECCOMP </b>operation (which does not support <i>flags</i>).<br><br>   <b>Seccomp-specific BPF details</b><br>       Note the following BPF details specific to seccomp filters:<br><br>       *  The <b>BPF_H </b>and <b>BPF_B </b>size modifiers are not supported: all<br>          operations must load and store (4-byte) words (<b>BPF_W</b>).<br><br>       *  To access the contents of the <i>seccomp_data</i> buffer, use the <b>BPF_ABS</b><br>          addressing mode modifier.<br><br>       *  The <b>BPF_LEN </b>addressing mode modifier yields an immediate mode<br>          operand whose value is the size of the <i>seccomp_data</i> buffer.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The program below accepts four or more arguments.  The first three<br>       arguments are a system call number, a numeric architecture<br>       identifier, and an error number.  The program uses these values to<br>       construct a BPF filter that is used at run time to perform the<br>       following checks:<br><br>       [1] If the program is not running on the specified architecture, the<br>           BPF filter causes system calls to fail with the error <b>ENOSYS</b>.<br><br>       [2] If the program attempts to execute the system call with the<br>           specified number, the BPF filter causes the system call to fail,<br>           with <i>errno</i> being set to the specified error number.<br><br>       The remaining command-line arguments specify the pathname and<br>       additional arguments of a program that the example program should<br>       attempt to execute using execv(3) (a library function that employs<br>       the execve(2) system call).  Some example runs of the program are<br>       shown below.<br><br>       First, we display the architecture that we are running on (x86-64)<br>       and then construct a shell function that looks up system call numbers<br>       on this architecture:<br><br>           $ <b>uname -m</b><br>           x86_64<br>           $ <b>syscall_nr() {</b><br>               <b>cat /usr/src/linux/arch/x86/syscalls/syscall_64.tbl | \\</b><br>               <b>awk '$2 != \"x32\" &amp;&amp; $3 == \"'$1'\" { print $1 }'</b><br>           <b>}</b><br><br>       When the BPF filter rejects a system call (case [2] above), it causes<br>       the system call to fail with the error number specified on the<br>       command line.  In the experiments shown here, we'll use error number<br>       99:<br><br>           $ <b>errno 99</b><br>           EADDRNOTAVAIL 99 Cannot assign requested address<br><br>       In the following example, we attempt to run the command whoami(1),<br>       but the BPF filter rejects the execve(2) system call, so that the<br>       command is not even executed:<br><br>           $ <b>syscall_nr execve</b><br>           59<br>           $ <b>./a.out</b><br>           Usage: ./a.out &lt;syscall_nr&gt; &lt;arch&gt; &lt;errno&gt; &lt;prog&gt; [&lt;args&gt;]<br>           Hint for &lt;arch&gt;: AUDIT_ARCH_I386: 0x40000003<br>                            AUDIT_ARCH_X86_64: 0xC000003E<br>           $ <b>./a.out 59 0xC000003E 99 /bin/whoami</b><br>           execv: Cannot assign requested address<br><br>       In the next example, the BPF filter rejects the write(2) system call,<br>       so that, although it is successfully started, the whoami(1) command<br>       is not able to write output:<br><br>           $ <b>syscall_nr write</b><br>           1<br>           $ <b>./a.out 1 0xC000003E 99 /bin/whoami</b><br><br>       In the final example, the BPF filter rejects a system call that is<br>       not used by the whoami(1) command, so it is able to successfully<br>       execute and produce output:<br><br>           $ <b>syscall_nr preadv</b><br>           295<br>           $ <b>./a.out 295 0xC000003E 99 /bin/whoami</b><br>           cecilia<br><br>   <b>Program source</b><br>       #include &lt;errno.h&gt;<br>       #include &lt;stddef.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;unistd.h&gt;<br>       #include &lt;linux/audit.h&gt;<br>       #include &lt;linux/filter.h&gt;<br>       #include &lt;linux/seccomp.h&gt;<br>       #include &lt;sys/prctl.h&gt;<br><br>       #define X32_SYSCALL_BIT 0x40000000<br><br>       static int<br>       install_filter(int syscall_nr, int t_arch, int f_errno)<br>       {<br>           unsigned int upper_nr_limit = 0xffffffff;<br><br>           /* Assume that AUDIT_ARCH_X86_64 means the normal x86-64 ABI */<br>           if (t_arch == AUDIT_ARCH_X86_64)<br>               upper_nr_limit = X32_SYSCALL_BIT - 1;<br><br>           struct sock_filter filter[] = {<br>               /* [0] Load architecture from 'seccomp_data' buffer into<br>                      accumulator */<br>               BPF_STMT(BPF_LD | BPF_W | BPF_ABS,<br>                        (offsetof(struct seccomp_data, arch))),<br><br>               /* [1] Jump forward 5 instructions if architecture does not<br>                      match 't_arch' */<br>               BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, t_arch, 0, 5),<br><br>               /* [2] Load system call number from 'seccomp_data' buffer into<br>                      accumulator */<br>               BPF_STMT(BPF_LD | BPF_W | BPF_ABS,<br>                        (offsetof(struct seccomp_data, nr))),<br><br>               /* [3] Check ABI - only needed for x86-64 in blacklist use<br>                      cases.  Use JGT instead of checking against the bit<br>                      mask to avoid having to reload the syscall number. */<br>               BPF_JUMP(BPF_JMP | BPF_JGT | BPF_K, upper_nr_limit, 3, 0),<br><br>               /* [4] Jump forward 1 instruction if system call number<br>                      does not match 'syscall_nr' */<br>               BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, syscall_nr, 0, 1),<br><br>               /* [5] Matching architecture and system call: don't execute<br>                   the system call, and return 'f_errno' in 'errno' */<br>               BPF_STMT(BPF_RET | BPF_K,<br>                        SECCOMP_RET_ERRNO | (f_errno &amp; SECCOMP_RET_DATA)),<br><br>               /* [6] Destination of system call number mismatch: allow other<br>                      system calls */<br>               BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),<br><br>               /* [7] Destination of architecture mismatch: kill process */<br>               BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL),<br>           };<br><br>           struct sock_fprog prog = {<br>               .len = (unsigned short) (sizeof(filter) / sizeof(filter[0])),<br>               .filter = filter,<br>           };<br><br>           if (seccomp(SECCOMP_SET_MODE_FILTER, 0, &amp;prog)) {<br>               perror(\"seccomp\");<br>               return 1;<br>           }<br><br>           return 0;<br>       }<br><br>       int<br>       main(int argc, char **argv)<br>       {<br>           if (argc &lt; 5) {<br>               fprintf(stderr, \"Usage: \"<br>                       \"%s &lt;syscall_nr&gt; &lt;arch&gt; &lt;errno&gt; &lt;prog&gt; [&lt;args&gt;]\\n\"<br>                       \"Hint for &lt;arch&gt;: AUDIT_ARCH_I386: 0x%X\\n\"<br>                       \"                 AUDIT_ARCH_X86_64: 0x%X\\n\"<br>                       \"\\n\", argv[0], AUDIT_ARCH_I386, AUDIT_ARCH_X86_64);<br>               exit(EXIT_FAILURE);<br>           }<br><br>           if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {<br>               perror(\"prctl\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           if (install_filter(strtol(argv[1], NULL, 0),<br>                              strtol(argv[2], NULL, 0),<br>                              strtol(argv[3], NULL, 0)))<br>               exit(EXIT_FAILURE);<br><br>           execv(argv[4], &amp;argv[4]);<br>           perror(\"execv\");<br>           exit(EXIT_FAILURE);<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       bpf(2), prctl(2), ptrace(2), sigaction(2), signal(7), socket(7)<br><br>       Various pages from the <i>libseccomp</i> library, including:<br>       scmp_sys_resolver(1), seccomp_init(3), seccomp_load(3),<br>       seccomp_rule_add(3), and seccomp_export_bpf(3).<br><br>       The kernel source files <i>Documentation/networking/filter.txt</i> and<br>       <i>Documentation/prctl/seccomp_filter.txt</i>.<br><br>       McCanne, S. and Jacobson, V. (1992) <i>The BSD Packet Filter: A New</i><br>       <i>Architecture for User-level Packet Capture</i>, Proceedings of the USENIX<br>       Winter 1993 Conference <br>       &#10216;http://www.tcpdump.org/papers/bpf-usenix93.pdf&#10217;<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                       SECCOMP(2)</span><br></pre><br>"}