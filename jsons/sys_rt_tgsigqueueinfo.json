{"Man page": "<pre><br><span class=\"headline\">RT_SIGQUEUEINFO(2)        Linux Programmer's Manual       RT_SIGQUEUEINFO(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       rt_sigqueueinfo, rt_tgsigqueueinfo - queue a signal and data<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>int rt_sigqueueinfo(pid_t </b><i>tgid</i><b>, int </b><i>sig</i><b>, siginfo_t *</b><i>uinfo</i><b>);</b><br><br>       <b>int rt_tgsigqueueinfo(pid_t </b><i>tgid</i><b>, pid_t </b><i>tid</i><b>, int </b><i>sig</i><b>,</b><br>                             <b>siginfo_t *</b><i>uinfo</i><b>);</b><br><br>       <i>Note</i>: There are no glibc wrappers for these system calls; see NOTES.<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>rt_sigqueueinfo</b>() and <b>rt_tgsigqueueinfo</b>() system calls are the<br>       low-level interfaces used to send a signal plus data to a process or<br>       thread.  The receiver of the signal can obtain the accompanying data<br>       by establishing a signal handler with the sigaction(2) <b>SA_SIGINFO</b><br>       flag.<br><br>       These system calls are not intended for direct application use; they<br>       are provided to allow the implementation of sigqueue(3) and<br>       pthread_sigqueue(3).<br><br>       The <b>rt_sigqueueinfo</b>() system call sends the signal <i>sig</i> to the thread<br>       group with the ID <i>tgid</i>.  (The term \"thread group\" is synonymous with<br>       \"process\", and <i>tid</i> corresponds to the traditional UNIX process ID.)<br>       The signal will be delivered to an arbitrary member of the thread<br>       group (i.e., one of the threads that is not currently blocking the<br>       signal).<br><br>       The <i>uinfo</i> argument specifies the data to accompany the signal.  This<br>       argument is a pointer to a structure of type <i>siginfo_t</i>, described in<br>       sigaction(2) (and defined by including <i>&lt;sigaction.h&gt;</i>).  The caller<br>       should set the following fields in this structure:<br><br>       <i>si_code</i><br>              This must be one of the <b>SI_* </b>codes in the Linux kernel source<br>              file <i>include/asm-generic/siginfo.h</i>, with the restriction that<br>              the code must be negative (i.e., cannot be <b>SI_USER</b>, which is<br>              used by the kernel to indicate a signal sent by kill(2)) and<br>              cannot (since Linux 2.6.39) be <b>SI_TKILL </b>(which is used by the<br>              kernel to indicate a signal sent using tgkill(2)).<br><br>       <i>si_pid</i> This should be set to a process ID, typically the process ID<br>              of the sender.<br><br>       <i>si_uid</i> This should be set to a user ID, typically the real user ID of<br>              the sender.<br><br>       <i>si_value</i><br>              This field contains the user data to accompany the signal.<br>              For more information, see the description of the last (<i>union</i><br>              <i>sigval</i>) argument of sigqueue(3).<br><br>       Internally, the kernel sets the <i>si_signo</i> field to the value specified<br>       in <i>sig</i>, so that the receiver of the signal can also obtain the signal<br>       number via that field.<br><br>       The <b>rt_tgsigqueueinfo</b>() system call is like <b>rt_sigqueueinfo</b>(), but<br>       sends the signal and data to the single thread specified by the<br>       combination of <i>tgid</i>, a thread group ID, and <i>tid</i>, a thread in that<br>       thread group.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, these system calls return 0.  On error, they return -1<br>       and <i>errno</i> is set to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EAGAIN </b>The limit of signals which may be queued has been reached.<br>              (See signal(7) for further information.)<br><br>       <b>EINVAL </b><i>sig</i>, <i>tgid</i>, or <i>tid</i> was invalid.<br><br>       <b>EPERM  </b>The caller does not have permission to send the signal to the<br>              target.  For the required permissions, see kill(2).  Or:<br>              <i>uinfo-&gt;si_code</i> is invalid.<br><br>       <b>ESRCH  rt_sigqueueinfo</b>(): No thread group matching <i>tgid</i> was found.<br>              <b>rt_tgsigqueinfo</b>(): No thread matching <i>tgid</i> and <i>tid</i> was found.<br></pre><br><h2>VERSIONS  </h2><pre><br>       The <b>rt_sigqueueinfo</b>() system call was added to Linux in version 2.2.<br>       The <b>rt_tgsigqueueinfo</b>() system call was added to Linux in version<br>       2.6.31.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       These system calls are Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       Since these system calls are not intended for application use, there<br>       are no glibc wrapper functions; use syscall(2) in the unlikely case<br>       that you want to call them directly.<br><br>       As with kill(2), the null signal (0) can be used to check if the<br>       specified process or thread exists.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       kill(2), sigaction(2), sigprocmask(2), tgkill(2),<br>       pthread_sigqueue(3), sigqueue(3), signal(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2012-07-13               RT_SIGQUEUEINFO(2)</span><br></pre><br>"}