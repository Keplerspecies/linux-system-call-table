{"Man page": "<pre><br><span class=\"headline\">MEMFD_CREATE(2)           Linux Programmer's Manual          MEMFD_CREATE(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       memfd_create - create an anonymous file<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/memfd.h&gt;</b><br><br>       <b>int memfd_create(const char *</b><i>name</i><b>, unsigned int </b><i>flags</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>memfd_create</b>() creates an anonymous file and returns a file<br>       descriptor that refers to it.  The file behaves like a regular file,<br>       and so can be modified, truncated, memory-mapped, and so on.<br>       However, unlike a regular file, it lives in RAM and has a volatile<br>       backing storage.  Once all references to the file are dropped, it is<br>       automatically released.  Anonymous memory is used for all backing<br>       pages of the file.  Therefore, files created by <b>memfd_create</b>() have<br>       the same semantics as other anonymous memory allocations such as<br>       those allocated using mmap(2) with the <b>MAP_ANONYMOUS </b>flag.<br><br>       The initial size of the file is set to 0.  Following the call, the<br>       file size should be set using ftruncate(2).  (Alternatively, the file<br>       may be populated by calls to write(2) or similar.)<br><br>       The name supplied in <i>name</i> is used as a filename and will be displayed<br>       as the target of the corresponding symbolic link in the directory<br>       <i>/proc/self/fd/</i>.  The displayed name is always prefixed with <i>memfd:</i><br>       and serves only for debugging purposes.  Names do not affect the<br>       behavior of the file descriptor, and as such multiple files can have<br>       the same name without any side effects.<br><br>       The following values may be bitwise ORed in <i>flags</i> to change the<br>       behavior of <b>memfd_create</b>():<br><br>       <b>MFD_CLOEXEC</b><br>              Set the close-on-exec (<b>FD_CLOEXEC</b>) flag on the new file<br>              descriptor.  See the description of the <b>O_CLOEXEC </b>flag in<br>              open(2) for reasons why this may be useful.<br><br>       <b>MFD_ALLOW_SEALING</b><br>              Allow sealing operations on this file.  See the discussion of<br>              the <b>F_ADD_SEALS </b>and <b>F_GET_SEALS </b>operations in fcntl(2), and<br>              also NOTES, below.  The initial set of seals is empty.  If<br>              this flag is not set, the initial set of seals will be<br>              <b>F_SEAL_SEAL</b>, meaning that no other seals can be set on the<br>              file.<br><br>       Unused bits in <i>flags</i> must be 0.<br><br>       As its return value, <b>memfd_create</b>() returns a new file descriptor<br>       that can be used to refer to the file.  This file descriptor is<br>       opened for both reading and writing (<b>O_RDWR</b>) and <b>O_LARGEFILE </b>is set<br>       for the descriptor.<br><br>       With respect to fork(2) and execve(2), the usual semantics apply for<br>       the file descriptor created by <b>memfd_create</b>().  A copy of the file<br>       descriptor is inherited by the child produced by fork(2) and refers<br>       to the same file.  The file descriptor is preserved across execve(2),<br>       unless the close-on-exec flag has been set.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>memfd_create</b>() returns a new file descriptor.  On error,<br>       -1 is returned and <i>errno</i> is set to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EFAULT </b>The address in <i>name</i> points to invalid memory.<br><br>       <b>EINVAL </b>An unsupported value was specified in one of the arguments:<br>              <i>flags</i> included unknown bits, or <i>name</i> was too long.<br><br>       <b>EMFILE </b>The per-process limit on open file descriptors has been<br>              reached.<br><br>       <b>ENFILE </b>The system-wide limit on the total number of open files has<br>              been reached.<br><br>       <b>ENOMEM </b>There was insufficient memory to create a new anonymous file.<br></pre><br><h2>VERSIONS  </h2><pre><br>       The <b>memfd_create</b>() system call first appeared in Linux 3.17.  Support<br>       in the GNU C library is pending.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       The <b>memfd_create</b>() system call is Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       The <b>memfd_create</b>() system call provides a simple alternative to<br>       manually mounting a <i>tmpfs</i> filesystem and creating and opening a file<br>       in that filesystem.  The primary purpose of <b>memfd_create</b>() is to<br>       create files and associated file descriptors that are used with the<br>       file-sealing APIs provided by fcntl(2).<br><br>       The <b>memfd_create</b>() system call also has uses without file sealing<br>       (which is why file-sealing is disabled, unless explicitly requested<br>       with the <b>MFD_ALLOW_SEALING </b>flag).  In particular, it can be used as<br>       an alternative to creating files in <i>tmp</i> or as an alternative to using<br>       the open(2) <b>O_TMPFILE </b>in cases where there is no intention to<br>       actually link the resulting file into the filesystem.<br><br>   <b>File sealing</b><br>       In the absence of file sealing, processes that communicate via shared<br>       memory must either trust each other, or take measures to deal with<br>       the possibility that an untrusted peer may manipulate the shared<br>       memory region in problematic ways.  For example, an untrusted peer<br>       might modify the contents of the shared memory at any time, or shrink<br>       the shared memory region.  The former possibility leaves the local<br>       process vulnerable to time-of-check-to-time-of-use race conditions<br>       (typically dealt with by copying data from the shared memory region<br>       before checking and using it).  The latter possibility leaves the<br>       local process vulnerable to <b>SIGBUS </b>signals when an attempt is made to<br>       access a now-nonexistent location in the shared memory region.<br>       (Dealing with this possibility necessitates the use of a handler for<br>       the <b>SIGBUS </b>signal.)<br><br>       Dealing with untrusted peers imposes extra complexity on code that<br>       employs shared memory.  Memory sealing enables that extra complexity<br>       to be eliminated, by allowing a process to operate secure in the<br>       knowledge that its peer can't modify the shared memory in an<br>       undesired fashion.<br><br>       An example of the usage of the sealing mechanism is as follows:<br><br>       1. The first process creates a <i>tmpfs</i> file using <b>memfd_create</b>().  The<br>          call yields a file descriptor used in subsequent steps.<br><br>       2. The first process sizes the file created in the previous step<br>          using ftruncate(2), maps it using mmap(2), and populates the<br>          shared memory with the desired data.<br><br>       3. The first process uses the fcntl(2) <b>F_ADD_SEALS </b>operation to place<br>          one or more seals on the file, in order to restrict further<br>          modifications on the file.  (If placing the seal <b>F_SEAL_WRITE</b>,<br>          then it will be necessary to first unmap the shared writable<br>          mapping created in the previous step.)<br><br>       4. A second process obtains a file descriptor for the <i>tmpfs</i> file and<br>          maps it.  Among the possible ways in which this could happen are<br>          the following:<br><br>          *  The process that called <b>memfd_create</b>() could transfer the<br>             resulting file descriptor to the second process via a UNIX<br>             domain socket (see unix(7) and cmsg(3)).  The second process<br>             then maps the file using mmap(2).<br><br>          *  The second process is created via fork(2) and thus<br>             automatically inherits the file descriptor and mapping.  (Note<br>             that in this case and the next, there is a natural trust<br>             relationship between the two processes, since they are running<br>             under the same user ID.  Therefore, file sealing would not<br>             normally be necessary.)<br><br>          *  The second process opens the file <i>/proc/&lt;pd&gt;/fd/&lt;fd&gt;</i>, where<br>             <i>&lt;pid&gt;</i> is the PID of the first process (the one that called<br>             <b>memfd_create</b>()), and <i>&lt;fd&gt;</i> is the number of the file descriptor<br>             returned by the call to <b>memfd_create</b>() in that process.  The<br>             second process then maps the file using mmap(2).<br><br>       5. The second process uses the fcntl(2) <b>F_GET_SEALS </b>operation to<br>          retrieve the bit mask of seals that has been applied to the file.<br>          This bit mask can be inspected in order to determine what kinds of<br>          restrictions have been placed on file modifications.  If desired,<br>          the second process can apply further seals to impose additional<br>          restrictions (so long as the <b>F_SEAL_SEAL </b>seal has not yet been<br>          applied).<br></pre><br><h2>EXAMPLE  </h2><pre><br>       Below are shown two example programs that demonstrate the use of<br>       <b>memfd_create</b>() and the file sealing API.<br><br>       The first program, <i>t_memfd_create.c</i>, creates a <i>tmpfs</i> file using<br>       <b>memfd_create</b>(), sets a size for the file, maps it into memory, and<br>       optionally places some seals on the file.  The program accepts up to<br>       three command-line arguments, of which the first two are required.<br>       The first argument is the name to associate with the file, the second<br>       argument is the size to be set for the file, and the optional third<br>       is a string of characters that specify seals to be set on file.<br><br>       The second program, <i>t_get_seals.c</i>, can be used to open an existing<br>       file that was created via <b>memfd_create</b>() and inspect the set of seals<br>       that have been applied to that file.<br><br>       The following shell session demonstrates the use of these programs.<br>       First we create a <i>tmpfs</i> file and set some seals on it:<br><br>           $ <b>./t_memfd_create my_memfd_file 4096 sw &amp;</b><br>           [1] 11775<br>           PID: 11775; fd: 3; /proc/11775/fd/3<br><br>       At this point, the <i>t_memfd_create</i> program continues to run in the<br>       background.  From another program, we can obtain a file descriptor<br>       for the file created by <b>memfd_create</b>() by opening the <i>/proc/PID/fd</i><br>       file that corresponds to the descriptor opened by <b>memfd_create</b>().<br>       Using that pathname, we inspect the content of the <i>/proc/PID/fd</i><br>       symbolic link, and use our <i>t_get_seals</i> program to view the seals that<br>       have been placed on the file:<br><br>           $ <b>readlink /proc/11775/fd/3</b><br>           /memfd:my_memfd_file (deleted)<br>           $ <b>./t_get_seals /proc/11775/fd/3</b><br>           Existing seals: WRITE SHRINK<br><br>   <b>Program source: t_memfd_create.c</b><br><br>       #include &lt;sys/memfd.h&gt;<br>       #include &lt;fcntl.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;unistd.h&gt;<br>       #include &lt;string.h&gt;<br>       #include &lt;stdio.h&gt;<br><br>       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\<br>                               } while (0)<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           int fd;<br>           unsigned int seals;<br>           char *addr;<br>           char *name, *seals_arg;<br>           ssize_t len;<br><br>           if (argc &lt; 3) {<br>               fprintf(stderr, \"%s name size [seals]\\n\", argv[0]);<br>               fprintf(stderr, \"\\t'seals' can contain any of the \"<br>                       \"following characters:\\n\");<br>               fprintf(stderr, \"\\t\\tg - F_SEAL_GROW\\n\");<br>               fprintf(stderr, \"\\t\\ts - F_SEAL_SHRINK\\n\");<br>               fprintf(stderr, \"\\t\\tw - F_SEAL_WRITE\\n\");<br>               fprintf(stderr, \"\\t\\tS - F_SEAL_SEAL\\n\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           name = argv[1];<br>           len = atoi(argv[2]);<br>           seals_arg = argv[3];<br><br>           /* Create an anonymous file in tmpfs; allow seals to be<br>              placed on the file */<br><br>           fd = memfd_create(name, MFD_ALLOW_SEALING);<br>           if (fd == -1)<br>               errExit(\"memfd_create\");<br><br>           /* Size the file as specified on the command line */<br><br>           if (ftruncate(fd, len) == -1)<br>               errExit(\"truncate\");<br><br>           printf(\"PID: %ld; fd: %d; /proc/%ld/fd/%d\\n\",<br>                   (long) getpid(), fd, (long) getpid(), fd);<br><br>           /* Code to map the file and populate the mapping with data<br>              omitted */<br><br>           /* If a 'seals' command-line argument was supplied, set some<br>              seals on the file */<br><br>           if (seals_arg != NULL) {<br>               seals = 0;<br><br>               if (strchr(seals_arg, 'g') != NULL)<br>                   seals |= F_SEAL_GROW;<br>               if (strchr(seals_arg, 's') != NULL)<br>                   seals |= F_SEAL_SHRINK;<br>               if (strchr(seals_arg, 'w') != NULL)<br>                   seals |= F_SEAL_WRITE;<br>               if (strchr(seals_arg, 'S') != NULL)<br>                   seals |= F_SEAL_SEAL;<br><br>               if (fcntl(fd, F_ADD_SEALS, seals) == -1)<br>                   errExit(\"fcntl\");<br>           }<br><br>           /* Keep running, so that the file created by memfd_create()<br>              continues to exist */<br><br>           pause();<br><br>           exit(EXIT_SUCCESS);<br>       }<br><br>   <b>Program source: t_get_seals.c</b><br><br>       #include &lt;sys/memfd.h&gt;<br>       #include &lt;fcntl.h&gt;<br>       #include &lt;unistd.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;string.h&gt;<br>       #include &lt;stdio.h&gt;<br><br>       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\<br>                               } while (0)<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           int fd;<br>           unsigned int seals;<br><br>           if (argc != 2) {<br>               fprintf(stderr, \"%s /proc/PID/fd/FD\\n\", argv[0]);<br>               exit(EXIT_FAILURE);<br>           }<br><br>           fd = open(argv[1], O_RDWR);<br>           if (fd == -1)<br>               errExit(\"open\");<br><br>           seals = fcntl(fd, F_GET_SEALS);<br>           if (seals == -1)<br>               errExit(\"fcntl\");<br><br>           printf(\"Existing seals:\");<br>           if (seals &amp; F_SEAL_SEAL)<br>               printf(\" SEAL\");<br>           if (seals &amp; F_SEAL_GROW)<br>               printf(\" GROW\");<br>           if (seals &amp; F_SEAL_WRITE)<br>               printf(\" WRITE\");<br>           if (seals &amp; F_SEAL_SHRINK)<br>               printf(\" SHRINK\");<br>           printf(\"\\n\");<br><br>           /* Code to map the file and access the contents of the<br>              resulting mapping omitted */<br><br>           exit(EXIT_SUCCESS);<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       fcntl(2), ftruncate(2), mmap(2), shmget(2), shm_open(3)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-01-22                  MEMFD_CREATE(2)</span><br></pre><br>"}