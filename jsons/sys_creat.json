{"Man page": "<pre><br><span class=\"headline\">OPEN(2)                   Linux Programmer's Manual                  OPEN(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       open, openat, creat - open and possibly create a file<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/types.h&gt;</b><br>       <b>#include &lt;sys/stat.h&gt;</b><br>       <b>#include &lt;fcntl.h&gt;</b><br><br>       <b>int open(const char *</b><i>pathname</i><b>, int </b><i>flags</i><b>);</b><br>       <b>int open(const char *</b><i>pathname</i><b>, int </b><i>flags</i><b>, mode_t </b><i>mode</i><b>);</b><br><br>       <b>int creat(const char *</b><i>pathname</i><b>, mode_t </b><i>mode</i><b>);</b><br><br>       <b>int openat(int </b><i>dirfd</i><b>, const char *</b><i>pathname</i><b>, int </b><i>flags</i><b>);</b><br>       <b>int openat(int </b><i>dirfd</i><b>, const char *</b><i>pathname</i><b>, int </b><i>flags</i><b>, mode_t </b><i>mode</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>openat</b>():<br>           Since glibc 2.10:<br>               _XOPEN_SOURCE &gt;= 700 || _POSIX_C_SOURCE &gt;= 200809L<br>           Before glibc 2.10:<br>               _ATFILE_SOURCE<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       Given a <i>pathname</i> for a file, <b>open</b>() returns a file descriptor, a<br>       small, nonnegative integer for use in subsequent system calls<br>       (read(2), write(2), lseek(2), fcntl(2), etc.).  The file descriptor<br>       returned by a successful call will be the lowest-numbered file<br>       descriptor not currently open for the process.<br><br>       By default, the new file descriptor is set to remain open across an<br>       execve(2) (i.e., the <b>FD_CLOEXEC </b>file descriptor flag described in<br>       fcntl(2) is initially disabled); the <b>O_CLOEXEC </b>flag, described below,<br>       can be used to change this default.  The file offset is set to the<br>       beginning of the file (see lseek(2)).<br><br>       A call to <b>open</b>() creates a new <i>open file description</i>, an entry in the<br>       system-wide table of open files.  The open file description records<br>       the file offset and the file status flags (see below).  A file<br>       descriptor is a reference to an open file description; this reference<br>       is unaffected if <i>pathname</i> is subsequently removed or modified to<br>       refer to a different file.  For further details on open file<br>       descriptions, see NOTES.<br><br>       The argument <i>flags</i> must include one of the following <i>access modes</i>:<br>       <b>O_RDONLY</b>, <b>O_WRONLY</b>, or <b>O_RDWR</b>.  These request opening the file read-<br>       only, write-only, or read/write, respectively.<br><br>       In addition, zero or more file creation flags and file status flags<br>       can be bitwise-<i>or</i>'d in <i>flags</i>.  The <i>file creation flags</i> are <b>O_CLOEXEC</b>,<br>       <b>O_CREAT</b>, <b>O_DIRECTORY</b>, <b>O_EXCL</b>, <b>O_NOCTTY</b>, <b>O_NOFOLLOW</b>, <b>O_TMPFILE</b>,<br>       <b>O_TRUNC</b>, and <b>O_TTY_INIT</b>.  The <i>file status flags</i> are all of the<br>       remaining flags listed below.  The distinction between these two<br>       groups of flags is that the file status flags can be retrieved and<br>       (in some cases) modified; see fcntl(2) for details.<br><br>       The full list of file creation flags and file status flags is as<br>       follows:<br><br>       <b>O_APPEND</b><br>              The file is opened in append mode.  Before each write(2), the<br>              file offset is positioned at the end of the file, as if with<br>              lseek(2).  <b>O_APPEND </b>may lead to corrupted files on NFS<br>              filesystems if more than one process appends data to a file at<br>              once.  This is because NFS does not support appending to a<br>              file, so the client kernel has to simulate it, which can't be<br>              done without a race condition.<br><br>       <b>O_ASYNC</b><br>              Enable signal-driven I/O: generate a signal (<b>SIGIO </b>by default,<br>              but this can be changed via fcntl(2)) when input or output<br>              becomes possible on this file descriptor.  This feature is<br>              available only for terminals, pseudoterminals, sockets, and<br>              (since Linux 2.6) pipes and FIFOs.  See fcntl(2) for further<br>              details.  See also BUGS, below.<br><br>       <b>O_CLOEXEC </b>(since Linux 2.6.23)<br>              Enable the close-on-exec flag for the new file descriptor.<br>              Specifying this flag permits a program to avoid additional<br>              fcntl(2) <b>F_SETFD </b>operations to set the <b>FD_CLOEXEC </b>flag.<br><br>              Note that the use of this flag is essential in some<br>              multithreaded programs, because using a separate fcntl(2)<br>              <b>F_SETFD </b>operation to set the <b>FD_CLOEXEC </b>flag does not suffice<br>              to avoid race conditions where one thread opens a file<br>              descriptor and attempts to set its close-on-exec flag using<br>              fcntl(2) at the same time as another thread does a fork(2)<br>              plus execve(2).  Depending on the order of execution, the race<br>              may lead to the file descriptor returned by <b>open</b>() being<br>              unintentionally leaked to the program executed by the child<br>              process created by fork(2).  (This kind of race is in<br>              principle possible for any system call that creates a file<br>              descriptor whose close-on-exec flag should be set, and various<br>              other Linux system calls provide an equivalent of the<br>              <b>O_CLOEXEC </b>flag to deal with this problem.)<br><br>       <b>O_CREAT</b><br>              If the file does not exist, it will be created.  The owner<br>              (user ID) of the file is set to the effective user ID of the<br>              process.  The group ownership (group ID) is set either to the<br>              effective group ID of the process or to the group ID of the<br>              parent directory (depending on filesystem type and mount<br>              options, and the mode of the parent directory; see the mount<br>              options <i>bsdgroups</i> and <i>sysvgroups</i> described in mount(8)).<br><br>              <i>mode</i> specifies the mode to use in case a new file is created.<br>              This argument must be supplied when <b>O_CREAT </b>or <b>O_TMPFILE </b>is<br>              specified in <i>flags</i>; if neither <b>O_CREAT </b>nor <b>O_TMPFILE </b>is<br>              specified, then <i>mode</i> is ignored.  The effective mode is<br>              modified by the process's <i>umask</i> in the usual way: in the<br>              absence of a default ACL, the mode of the created file is<br>              <i>(mode &amp; ~umask)</i>.  Note that this mode applies only to future<br>              accesses of the newly created file; the <b>open</b>() call that<br>              creates a read-only file may well return a read/write file<br>              descriptor.<br><br>              The following symbolic constants are provided for <i>mode</i>:<br><br>              <b>S_IRWXU  </b>00700 user (file owner) has read, write, and execute<br>                       permission<br><br>              <b>S_IRUSR  </b>00400 user has read permission<br><br>              <b>S_IWUSR  </b>00200 user has write permission<br><br>              <b>S_IXUSR  </b>00100 user has execute permission<br><br>              <b>S_IRWXG  </b>00070 group has read, write, and execute permission<br><br>              <b>S_IRGRP  </b>00040 group has read permission<br><br>              <b>S_IWGRP  </b>00020 group has write permission<br><br>              <b>S_IXGRP  </b>00010 group has execute permission<br><br>              <b>S_IRWXO  </b>00007 others have read, write, and execute permission<br><br>              <b>S_IROTH  </b>00004 others have read permission<br><br>              <b>S_IWOTH  </b>00002 others have write permission<br><br>              <b>S_IXOTH  </b>00001 others have execute permission<br><br>              According to POSIX, the effect when other bits are set in <i>mode</i><br>              is unspecified.  On Linux, the following bits are also honored<br>              in <i>mode</i>:<br><br>              <b>S_ISUID  </b>0004000 set-user-ID bit<br><br>              <b>S_ISGID  </b>0002000 set-group-ID bit (see stat(2))<br><br>              <b>S_ISVTX  </b>0001000 sticky bit (see stat(2))<br><br>       <b>O_DIRECT </b>(since Linux 2.4.10)<br>              Try to minimize cache effects of the I/O to and from this<br>              file.  In general this will degrade performance, but it is<br>              useful in special situations, such as when applications do<br>              their own caching.  File I/O is done directly to/from user-<br>              space buffers.  The <b>O_DIRECT </b>flag on its own makes an effort<br>              to transfer data synchronously, but does not give the<br>              guarantees of the <b>O_SYNC </b>flag that data and necessary metadata<br>              are transferred.  To guarantee synchronous I/O, <b>O_SYNC </b>must be<br>              used in addition to <b>O_DIRECT</b>.  See NOTES below for further<br>              discussion.<br><br>              A semantically similar (but deprecated) interface for block<br>              devices is described in raw(8).<br><br>       <b>O_DIRECTORY</b><br>              If <i>pathname</i> is not a directory, cause the open to fail.  This<br>              flag was added in kernel version 2.1.126, to avoid denial-of-<br>              service problems if opendir(3) is called on a FIFO or tape<br>              device.<br><br>       <b>O_DSYNC</b><br>              Write operations on the file will complete according to the<br>              requirements of synchronized I/O <i>data</i> integrity completion.<br><br>              By the time write(2) (and similar) return, the output data has<br>              been transferred to the underlying hardware, along with any<br>              file metadata that would be required to retrieve that data<br>              (i.e., as though each write(2) was followed by a call to<br>              fdatasync(2)).  <i>See NOTES below</i>.<br><br>       <b>O_EXCL </b>Ensure that this call creates the file: if this flag is<br>              specified in conjunction with <b>O_CREAT</b>, and <i>pathname</i> already<br>              exists, then <b>open</b>() will fail.<br><br>              When these two flags are specified, symbolic links are not<br>              followed: if <i>pathname</i> is a symbolic link, then <b>open</b>() fails<br>              regardless of where the symbolic link points to.<br><br>              In general, the behavior of <b>O_EXCL </b>is undefined if it is used<br>              without <b>O_CREAT</b>.  There is one exception: on Linux 2.6 and<br>              later, <b>O_EXCL </b>can be used without <b>O_CREAT </b>if <i>pathname</i> refers<br>              to a block device.  If the block device is in use by the<br>              system (e.g., mounted), <b>open</b>() fails with the error <b>EBUSY</b>.<br><br>              On NFS, <b>O_EXCL </b>is supported only when using NFSv3 or later on<br>              kernel 2.6 or later.  In NFS environments where <b>O_EXCL </b>support<br>              is not provided, programs that rely on it for performing<br>              locking tasks will contain a race condition.  Portable<br>              programs that want to perform atomic file locking using a<br>              lockfile, and need to avoid reliance on NFS support for<br>              <b>O_EXCL</b>, can create a unique file on the same filesystem (e.g.,<br>              incorporating hostname and PID), and use link(2) to make a<br>              link to the lockfile.  If link(2) returns 0, the lock is<br>              successful.  Otherwise, use stat(2) on the unique file to<br>              check if its link count has increased to 2, in which case the<br>              lock is also successful.<br><br>       <b>O_LARGEFILE</b><br>              (LFS) Allow files whose sizes cannot be represented in an<br>              <i>off_t</i> (but can be represented in an <i>off64_t</i>) to be opened.<br>              The <b>_LARGEFILE64_SOURCE </b>macro must be defined (before<br>              including <i>any</i> header files) in order to obtain this<br>              definition.  Setting the <b>_FILE_OFFSET_BITS </b>feature test macro<br>              to 64 (rather than using <b>O_LARGEFILE</b>) is the preferred method<br>              of accessing large files on 32-bit systems (see<br>              feature_test_macros(7)).<br><br>       <b>O_NOATIME </b>(since Linux 2.6.8)<br>              Do not update the file last access time (<i>st_atime</i> in the<br>              inode) when the file is read(2).  This flag is intended for<br>              use by indexing or backup programs, where its use can<br>              significantly reduce the amount of disk activity.  This flag<br>              may not be effective on all filesystems.  One example is NFS,<br>              where the server maintains the access time.<br><br>       <b>O_NOCTTY</b><br>              If <i>pathname</i> refers to a terminal device&#8212;see tty(4)&#8212;it will not<br>              become the process's controlling terminal even if the process<br>              does not have one.<br><br>       <b>O_NOFOLLOW</b><br>              If <i>pathname</i> is a symbolic link, then the open fails.  This is<br>              a FreeBSD extension, which was added to Linux in version<br>              2.1.126.  Symbolic links in earlier components of the pathname<br>              will still be followed.  See also <b>O_PATH </b>below.<br><br>       <b>O_NONBLOCK </b>or <b>O_NDELAY</b><br>              When possible, the file is opened in nonblocking mode.<br>              Neither the <b>open</b>() nor any subsequent operations on the file<br>              descriptor which is returned will cause the calling process to<br>              wait.<br><br>              Note that this flag has no effect for regular files and block<br>              devices; that is, I/O operations will (briefly) block when<br>              device activity is required, regardless of whether <b>O_NONBLOCK</b><br>              is set.  Since <b>O_NONBLOCK </b>semantics might eventually be<br>              implemented, applications should not depend upon blocking<br>              behavior when specifying this flag for regular files and block<br>              devices.<br><br>              For the handling of FIFOs (named pipes), see also fifo(7).<br>              For a discussion of the effect of <b>O_NONBLOCK </b>in conjunction<br>              with mandatory file locks and with file leases, see fcntl(2).<br><br>       <b>O_PATH </b>(since Linux 2.6.39)<br>              Obtain a file descriptor that can be used for two purposes: to<br>              indicate a location in the filesystem tree and to perform<br>              operations that act purely at the file descriptor level.  The<br>              file itself is not opened, and other file operations (e.g.,<br>              read(2), write(2), fchmod(2), fchown(2), fgetxattr(2),<br>              mmap(2)) fail with the error <b>EBADF</b>.<br><br>              The following operations <i>can</i> be performed on the resulting<br>              file descriptor:<br><br>              *  close(2); fchdir(2) (since Linux 3.5); fstat(2) (since<br>                 Linux 3.6).<br><br>              *  Duplicating the file descriptor (dup(2), fcntl(2) <b>F_DUPFD</b>,<br>                 etc.).<br><br>              *  Getting and setting file descriptor flags (fcntl(2) <b>F_GETFD</b><br>                 and <b>F_SETFD</b>).<br><br>              *  Retrieving open file status flags using the fcntl(2)<br>                 <b>F_GETFL </b>operation: the returned flags will include the bit<br>                 <b>O_PATH</b>.<br><br>              *  Passing the file descriptor as the <i>dirfd</i> argument of<br>                 openat(2) and the other \"*at()\" system calls.  This<br>                 includes linkat(2) with <b>AT_EMPTY_PATH </b>(or via procfs using<br>                 <b>AT_SYMLINK_FOLLOW</b>) even if the file is not a directory.<br><br>              *  Passing the file descriptor to another process via a UNIX<br>                 domain socket (see <b>SCM_RIGHTS </b>in unix(7)).<br><br>              When <b>O_PATH </b>is specified in <i>flags</i>, flag bits other than<br>              <b>O_CLOEXEC</b>, <b>O_DIRECTORY</b>, and <b>O_NOFOLLOW </b>are ignored.<br><br>              If <i>pathname</i> is a symbolic link and the <b>O_NOFOLLOW </b>flag is also<br>              specified, then the call returns a file descriptor referring<br>              to the symbolic link.  This file descriptor can be used as the<br>              <i>dirfd</i> argument in calls to fchownat(2), fstatat(2), linkat(2),<br>              and readlinkat(2) with an empty pathname to have the calls<br>              operate on the symbolic link.<br><br>       <b>O_SYNC </b>Write operations on the file will complete according to the<br>              requirements of synchronized I/O <i>file</i> integrity completion (by<br>              contrast with the synchronized I/O <i>data</i> integrity completion<br>              provided by <b>O_DSYNC</b>.)<br><br>              By the time write(2) (and similar) return, the output data and<br>              associated file metadata have been transferred to the<br>              underlying hardware (i.e., as though each write(2) was<br>              followed by a call to fsync(2)).  <i>See NOTES below</i>.<br><br>       <b>O_TMPFILE </b>(since Linux 3.11)<br>              Create an unnamed temporary file.  The <i>pathname</i> argument<br>              specifies a directory; an unnamed inode will be created in<br>              that directory's filesystem.  Anything written to the<br>              resulting file will be lost when the last file descriptor is<br>              closed, unless the file is given a name.<br><br>              <b>O_TMPFILE </b>must be specified with one of <b>O_RDWR </b>or <b>O_WRONLY</b><br>              and, optionally, <b>O_EXCL</b>.  If <b>O_EXCL </b>is not specified, then<br>              linkat(2) can be used to link the temporary file into the<br>              filesystem, making it permanent, using code like the<br>              following:<br><br>                  char path[PATH_MAX];<br>                  fd = open(\"/path/to/dir\", O_TMPFILE | O_RDWR,<br>                                          S_IRUSR | S_IWUSR);<br><br>                  /* File I/O on 'fd'... */<br><br>                  snprintf(path, PATH_MAX,  \"/proc/self/fd/%d\", fd);<br>                  linkat(AT_FDCWD, path, AT_FDCWD, \"/path/for/file\",<br>                                          AT_SYMLINK_FOLLOW);<br><br>              In this case, the <b>open</b>() <i>mode</i> argument determines the file<br>              permission mode, as with <b>O_CREAT</b>.<br><br>              Specifying <b>O_EXCL </b>in conjunction with <b>O_TMPFILE </b>prevents a<br>              temporary file from being linked into the filesystem in the<br>              above manner.  (Note that the meaning of <b>O_EXCL </b>in this case<br>              is different from the meaning of <b>O_EXCL </b>otherwise.)<br><br>              There are two main use cases for <b>O_TMPFILE</b>:<br><br>              *  Improved tmpfile(3) functionality: race-free creation of<br>                 temporary files that (1) are automatically deleted when<br>                 closed; (2) can never be reached via any pathname; (3) are<br>                 not subject to symlink attacks; and (4) do not require the<br>                 caller to devise unique names.<br><br>              *  Creating a file that is initially invisible, which is then<br>                 populated with data and adjusted to have appropriate<br>                 filesystem attributes (chown(2), chmod(2), fsetxattr(2),<br>                 etc.)  before being atomically linked into the filesystem<br>                 in a fully formed state (using linkat(2) as described<br>                 above).<br><br>              <b>O_TMPFILE </b>requires support by the underlying filesystem; only<br>              a subset of Linux filesystems provide that support.  In the<br>              initial implementation, support was provided in the ext2,<br>              ext3, ext4, UDF, Minix, and shmem filesystems.  XFS support<br>              was added in Linux 3.15.<br><br>       <b>O_TRUNC</b><br>              If the file already exists and is a regular file and the<br>              access mode allows writing (i.e., is <b>O_RDWR </b>or <b>O_WRONLY</b>) it<br>              will be truncated to length 0.  If the file is a FIFO or<br>              terminal device file, the <b>O_TRUNC </b>flag is ignored.  Otherwise,<br>              the effect of <b>O_TRUNC </b>is unspecified.<br><br>   <b>creat()</b><br>       <b>creat</b>() is equivalent to <b>open</b>() with <i>flags</i> equal to<br>       <b>O_CREAT|O_WRONLY|O_TRUNC</b>.<br><br>   <b>openat()</b><br>       The <b>openat</b>() system call operates in exactly the same way as <b>open</b>(),<br>       except for the differences described here.<br><br>       If the pathname given in <i>pathname</i> is relative, then it is interpreted<br>       relative to the directory referred to by the file descriptor <i>dirfd</i><br>       (rather than relative to the current working directory of the calling<br>       process, as is done by <b>open</b>() for a relative pathname).<br><br>       If <i>pathname</i> is relative and <i>dirfd</i> is the special value <b>AT_FDCWD</b>, then<br>       <i>pathname</i> is interpreted relative to the current working directory of<br>       the calling process (like <b>open</b>()).<br><br>       If <i>pathname</i> is absolute, then <i>dirfd</i> is ignored.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       <b>open</b>(), <b>openat</b>(), and <b>creat</b>() return the new file descriptor, or -1<br>       if an error occurred (in which case, <i>errno</i> is set appropriately).<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>open</b>(), <b>openat</b>(), and <b>creat</b>() can fail with the following errors:<br><br>       <b>EACCES </b>The requested access to the file is not allowed, or search<br>              permission is denied for one of the directories in the path<br>              prefix of <i>pathname</i>, or the file did not exist yet and write<br>              access to the parent directory is not allowed.  (See also<br>              path_resolution(7).)<br><br>       <b>EDQUOT </b>Where <b>O_CREAT </b>is specified, the file does not exist, and the<br>              user's quota of disk blocks or inodes on the filesystem has<br>              been exhausted.<br><br>       <b>EEXIST </b><i>pathname</i> already exists and <b>O_CREAT </b>and <b>O_EXCL </b>were used.<br><br>       <b>EFAULT </b><i>pathname</i> points outside your accessible address space.<br><br>       <b>EFBIG  </b>See <b>EOVERFLOW</b>.<br><br>       <b>EINTR  </b>While blocked waiting to complete an open of a slow device<br>              (e.g., a FIFO; see fifo(7)), the call was interrupted by a<br>              signal handler; see signal(7).<br><br>       <b>EINVAL </b>The filesystem does not support the <b>O_DIRECT </b>flag.  See <b>NOTES</b><br>              for more information.<br><br>       <b>EINVAL </b>Invalid value in <i>flags</i>.<br><br>       <b>EINVAL O_TMPFILE </b>was specified in <i>flags</i>, but neither <b>O_WRONLY </b>nor<br>              <b>O_RDWR </b>was specified.<br><br>       <b>EISDIR </b><i>pathname</i> refers to a directory and the access requested<br>              involved writing (that is, <b>O_WRONLY </b>or <b>O_RDWR </b>is set).<br><br>       <b>EISDIR </b><i>pathname</i> refers to an existing directory, <b>O_TMPFILE </b>and one of<br>              <b>O_WRONLY </b>or <b>O_RDWR </b>were specified in <i>flags</i>, but this kernel<br>              version does not provide the <b>O_TMPFILE </b>functionality.<br><br>       <b>ELOOP  </b>Too many symbolic links were encountered in resolving<br>              <i>pathname</i>.<br><br>       <b>ELOOP  </b><i>pathname</i> was a symbolic link, and <i>flags</i> specified <b>O_NOFOLLOW</b><br>              but not <b>O_PATH</b>.<br><br>       <b>EMFILE </b>The process already has the maximum number of files open (see<br>              the description of <b>RLIMIT_NOFILE </b>in getrlimit(2)).<br><br>       <b>ENAMETOOLONG</b><br>              <i>pathname</i> was too long.<br><br>       <b>ENFILE </b>The system limit on the total number of open files has been<br>              reached.<br><br>       <b>ENODEV </b><i>pathname</i> refers to a device special file and no corresponding<br>              device exists.  (This is a Linux kernel bug; in this situation<br>              <b>ENXIO </b>must be returned.)<br><br>       <b>ENOENT O_CREAT </b>is not set and the named file does not exist.  Or, a<br>              directory component in <i>pathname</i> does not exist or is a<br>              dangling symbolic link.<br><br>       <b>ENOENT </b><i>pathname</i> refers to a nonexistent directory, <b>O_TMPFILE </b>and one<br>              of <b>O_WRONLY </b>or <b>O_RDWR </b>were specified in <i>flags</i>, but this kernel<br>              version does not provide the <b>O_TMPFILE </b>functionality.<br><br>       <b>ENOMEM </b>Insufficient kernel memory was available.<br><br>       <b>ENOSPC </b><i>pathname</i> was to be created but the device containing <i>pathname</i><br>              has no room for the new file.<br><br>       <b>ENOTDIR</b><br>              A component used as a directory in <i>pathname</i> is not, in fact, a<br>              directory, or <b>O_DIRECTORY </b>was specified and <i>pathname</i> was not a<br>              directory.<br><br>       <b>ENXIO  O_NONBLOCK </b>| <b>O_WRONLY </b>is set, the named file is a FIFO, and no<br>              process has the FIFO open for reading.  Or, the file is a<br>              device special file and no corresponding device exists.<br><br>       <b>EOPNOTSUPP</b><br>              The filesystem containing <i>pathname</i> does not support <b>O_TMPFILE</b>.<br><br>       <b>EOVERFLOW</b><br>              <i>pathname</i> refers to a regular file that is too large to be<br>              opened.  The usual scenario here is that an application<br>              compiled on a 32-bit platform without <i>-D_FILE_OFFSET_BITS=64</i><br>              tried to open a file whose size exceeds <i>(1&lt;&lt;31)-1</i> bytes; see<br>              also <b>O_LARGEFILE </b>above.  This is the error specified by<br>              POSIX.1; in kernels before 2.6.24, Linux gave the error <b>EFBIG</b><br>              for this case.<br><br>       <b>EPERM  </b>The <b>O_NOATIME </b>flag was specified, but the effective user ID of<br>              the caller did not match the owner of the file and the caller<br>              was not privileged (<b>CAP_FOWNER</b>).<br><br>       <b>EPERM  </b>The operation was prevented by a file seal; see fcntl(2).<br><br>       <b>EROFS  </b><i>pathname</i> refers to a file on a read-only filesystem and write<br>              access was requested.<br><br>       <b>ETXTBSY</b><br>              <i>pathname</i> refers to an executable image which is currently<br>              being executed and write access was requested.<br><br>       <b>EWOULDBLOCK</b><br>              The <b>O_NONBLOCK </b>flag was specified, and an incompatible lease<br>              was held on the file (see fcntl(2)).<br><br>       The following additional errors can occur for <b>openat</b>():<br><br>       <b>EBADF  </b><i>dirfd</i> is not a valid file descriptor.<br><br>       <b>ENOTDIR</b><br>              <i>pathname</i> is a relative pathname and <i>dirfd</i> is a file descriptor<br>              referring to a file other than a directory.<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>openat</b>() was added to Linux in kernel 2.6.16; library support was<br>       added to glibc in version 2.4.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>open</b>(), <b>creat</b>() SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008.<br><br>       <b>openat</b>(): POSIX.1-2008.<br><br>       The <b>O_DIRECT</b>, <b>O_NOATIME</b>, <b>O_PATH</b>, and <b>O_TMPFILE </b>flags are Linux-<br>       specific.  One must define <b>_GNU_SOURCE </b>to obtain their definitions.<br><br>       The <b>O_CLOEXEC</b>, <b>O_DIRECTORY</b>, and <b>O_NOFOLLOW </b>flags are not specified in<br>       POSIX.1-2001, but are specified in POSIX.1-2008.  Since glibc 2.12,<br>       one can obtain their definitions by defining either <b>_POSIX_C_SOURCE</b><br>       with a value greater than or equal to 200809L or <b>_XOPEN_SOURCE </b>with a<br>       value greater than or equal to 700.  In glibc 2.11 and earlier, one<br>       obtains the definitions by defining <b>_GNU_SOURCE</b>.<br><br>       As noted in feature_test_macros(7), feature test macros such as<br>       <b>_POSIX_C_SOURCE</b>, <b>_XOPEN_SOURCE</b>, and <b>_GNU_SOURCE </b>must be defined<br>       before including <i>any</i> header files.<br></pre><br><h2>NOTES  </h2><pre><br>       Under Linux, the <b>O_NONBLOCK </b>flag indicates that one wants to open but<br>       does not necessarily have the intention to read or write.  This is<br>       typically used to open devices in order to get a file descriptor for<br>       use with ioctl(2).<br><br>       The (undefined) effect of <b>O_RDONLY | O_TRUNC </b>varies among<br>       implementations.  On many systems the file is actually truncated.<br><br>       Note that <b>open</b>() can open device special files, but <b>creat</b>() cannot<br>       create them; use mknod(2) instead.<br><br>       If the file is newly created, its <i>st_atime</i>, <i>st_ctime</i>, <i>st_mtime</i> fields<br>       (respectively, time of last access, time of last status change, and<br>       time of last modification; see stat(2)) are set to the current time,<br>       and so are the <i>st_ctime</i> and <i>st_mtime</i> fields of the parent directory.<br>       Otherwise, if the file is modified because of the <b>O_TRUNC </b>flag, its<br>       <i>st_ctime</i> and <i>st_mtime</i> fields are set to the current time.<br><br>   <b>Open file descriptions</b><br>       The term open file description is the one used by POSIX to refer to<br>       the entries in the system-wide table of open files.  In other<br>       contexts, this object is variously also called an \"open file object\",<br>       a \"file handle\", an \"open file table entry\", or&#8212;in kernel-developer<br>       parlance&#8212;a <i>struct file</i>.<br><br>       When a file descriptor is duplicated (using dup(2) or similar), the<br>       duplicate refers to the same open file description as the original<br>       file descriptor, and the two file descriptors consequently share the<br>       file offset and file status flags.  Such sharing can also occur<br>       between processes: a child process created via fork(2) inherits<br>       duplicates of its parent's file descriptors, and those duplicates<br>       refer to the same open file descriptions.<br><br>       Each open(2) of a file creates a new open file description; thus,<br>       there may be multiple open file descriptions corresponding to a file<br>       inode.<br><br>   <b>Synchronized I/O</b><br>       The POSIX.1-2008 \"synchronized I/O\" option specifies different<br>       variants of synchronized I/O, and specifies the <b>open</b>() flags <b>O_SYNC</b>,<br>       <b>O_DSYNC</b>, and <b>O_RSYNC </b>for controlling the behavior.  Regardless of<br>       whether an implementation supports this option, it must at least<br>       support the use of <b>O_SYNC </b>for regular files.<br><br>       Linux implements <b>O_SYNC </b>and <b>O_DSYNC</b>, but not <b>O_RSYNC</b>.  (Somewhat<br>       incorrectly, glibc defines <b>O_RSYNC </b>to have the same value as <b>O_SYNC</b>.)<br><br>       <b>O_SYNC </b>provides synchronized I/O <i>file</i> integrity completion, meaning<br>       write operations will flush data and all associated metadata to the<br>       underlying hardware.  <b>O_DSYNC </b>provides synchronized I/O <i>data</i><br>       integrity completion, meaning write operations will flush data to the<br>       underlying hardware, but will only flush metadata updates that are<br>       required to allow a subsequent read operation to complete<br>       successfully.  Data integrity completion can reduce the number of<br>       disk operations that are required for applications that don't need<br>       the guarantees of file integrity completion.<br><br>       To understand the difference between the two types of completion,<br>       consider two pieces of file metadata: the file last modification<br>       timestamp (<i>st_mtime</i>) and the file length.  All write operations will<br>       update the last file modification timestamp, but only writes that add<br>       data to the end of the file will change the file length.  The last<br>       modification timestamp is not needed to ensure that a read completes<br>       successfully, but the file length is.  Thus, <b>O_DSYNC </b>would only<br>       guarantee to flush updates to the file length metadata (whereas<br>       <b>O_SYNC </b>would also always flush the last modification timestamp<br>       metadata).<br><br>       Before Linux 2.6.33, Linux implemented only the <b>O_SYNC </b>flag for<br>       <b>open</b>().  However, when that flag was specified, most filesystems<br>       actually provided the equivalent of synchronized I/O <i>data</i> integrity<br>       completion (i.e., <b>O_SYNC </b>was actually implemented as the equivalent<br>       of <b>O_DSYNC</b>).<br><br>       Since Linux 2.6.33, proper <b>O_SYNC </b>support is provided.  However, to<br>       ensure backward binary compatibility, <b>O_DSYNC </b>was defined with the<br>       same value as the historical <b>O_SYNC</b>, and <b>O_SYNC </b>was defined as a new<br>       (two-bit) flag value that includes the <b>O_DSYNC </b>flag value.  This<br>       ensures that applications compiled against new headers get at least<br>       <b>O_DSYNC </b>semantics on pre-2.6.33 kernels.<br><br>   <b>NFS</b><br>       There are many infelicities in the protocol underlying NFS, affecting<br>       amongst others <b>O_SYNC </b>and <b>O_NDELAY</b>.<br><br>       On NFS filesystems with UID mapping enabled, <b>open</b>() may return a file<br>       descriptor but, for example, read(2) requests are denied with <b>EACCES</b>.<br>       This is because the client performs <b>open</b>() by checking the<br>       permissions, but UID mapping is performed by the server upon read and<br>       write requests.<br><br>   <b>FIFOs</b><br>       Opening the read or write end of a FIFO blocks until the other end is<br>       also opened (by another process or thread).  See fifo(7) for further<br>       details.<br><br>   <b>File access mode</b><br>       Unlike the other values that can be specified in <i>flags</i>, the <i>access</i><br>       <i>mode</i> values <b>O_RDONLY</b>, <b>O_WRONLY</b>, and <b>O_RDWR </b>do not specify individual<br>       bits.  Rather, they define the low order two bits of <i>flags</i>, and are<br>       defined respectively as 0, 1, and 2.  In other words, the combination<br>       <b>O_RDONLY | O_WRONLY </b>is a logical error, and certainly does not have<br>       the same meaning as <b>O_RDWR</b>.<br><br>       Linux reserves the special, nonstandard access mode 3 (binary 11) in<br>       <i>flags</i> to mean: check for read and write permission on the file and<br>       return a descriptor that can't be used for reading or writing.  This<br>       nonstandard access mode is used by some Linux drivers to return a<br>       descriptor that is to be used only for device-specific ioctl(2)<br>       operations.<br><br>   <b>Rationale for openat() and other directory file descriptor APIs</b><br>       <b>openat</b>() and the other system calls and library functions that take a<br>       directory file descriptor argument (i.e., execveat(2), faccessat(2),<br>       fanotify_mark(2), fchmodat(2), fchownat(2), fstatat(2), futimesat(2),<br>       linkat(2), mkdirat(2), mknodat(2), name_to_handle_at(2),<br>       readlinkat(2), renameat(2), symlinkat(2), unlinkat(2), utimensat(2),<br>       mkfifoat(3), and scandirat(3)) are supported for two reasons.  Here,<br>       the explanation is in terms of the <b>openat</b>() call, but the rationale<br>       is analogous for the other interfaces.<br><br>       First, <b>openat</b>() allows an application to avoid race conditions that<br>       could occur when using <b>open</b>() to open files in directories other than<br>       the current working directory.  These race conditions result from the<br>       fact that some component of the directory prefix given to <b>open</b>()<br>       could be changed in parallel with the call to <b>open</b>().  Suppose, for<br>       example, that we wish to create the file <i>path/to/xxx.dep</i> if the file<br>       <i>path/to/xxx</i> exists.  The problem is that between the existence check<br>       and the file creation step, <i>path</i> or <i>to</i> (which might be symbolic<br>       links) could be modified to point to a different location.  Such<br>       races can be avoided by opening a file descriptor for the target<br>       directory, and then specifying that file descriptor as the <i>dirfd</i><br>       argument of (say) fstatat(2) and <b>openat</b>().<br><br>       Second, <b>openat</b>() allows the implementation of a per-thread \"current<br>       working directory\", via file descriptor(s) maintained by the<br>       application.  (This functionality can also be obtained by tricks<br>       based on the use of <i>/proc/self/fd/</i>dirfd, but less efficiently.)<br><br>   <b>O_DIRECT</b><br>       The <b>O_DIRECT </b>flag may impose alignment restrictions on the length and<br>       address of user-space buffers and the file offset of I/Os.  In Linux<br>       alignment restrictions vary by filesystem and kernel version and<br>       might be absent entirely.  However there is currently no<br>       filesystem-independent interface for an application to discover these<br>       restrictions for a given file or filesystem.  Some filesystems<br>       provide their own interfaces for doing so, for example the<br>       <b>XFS_IOC_DIOINFO </b>operation in xfsctl(3).<br><br>       Under Linux 2.4, transfer sizes, and the alignment of the user buffer<br>       and the file offset must all be multiples of the logical block size<br>       of the filesystem.  Since Linux 2.6.0, alignment to the logical block<br>       size of the underlying storage (typically 512 bytes) suffices.  The<br>       logical block size can be determined using the ioctl(2) <b>BLKSSZGET</b><br>       operation or from the shell using the command:<br><br>           blockdev --getss<br><br>       <b>O_DIRECT </b>I/Os should never be run concurrently with the fork(2)<br>       system call, if the memory buffer is a private mapping (i.e., any<br>       mapping created with the mmap(2) <b>MAP_PRIVATE </b>flag; this includes<br>       memory allocated on the heap and statically allocated buffers).  Any<br>       such I/Os, whether submitted via an asynchronous I/O interface or<br>       from another thread in the process, should be completed before<br>       fork(2) is called.  Failure to do so can result in data corruption<br>       and undefined behavior in parent and child processes.  This<br>       restriction does not apply when the memory buffer for the <b>O_DIRECT</b><br>       I/Os was created using shmat(2) or mmap(2) with the <b>MAP_SHARED </b>flag.<br>       Nor does this restriction apply when the memory buffer has been<br>       advised as <b>MADV_DONTFORK </b>with madvise(2), ensuring that it will not<br>       be available to the child after fork(2).<br><br>       The <b>O_DIRECT </b>flag was introduced in SGI IRIX, where it has alignment<br>       restrictions similar to those of Linux 2.4.  IRIX has also a fcntl(2)<br>       call to query appropriate alignments, and sizes.  FreeBSD 4.x<br>       introduced a flag of the same name, but without alignment<br>       restrictions.<br><br>       <b>O_DIRECT </b>support was added under Linux in kernel version 2.4.10.<br>       Older Linux kernels simply ignore this flag.  Some filesystems may<br>       not implement the flag and <b>open</b>() will fail with <b>EINVAL </b>if it is<br>       used.<br><br>       Applications should avoid mixing <b>O_DIRECT </b>and normal I/O to the same<br>       file, and especially to overlapping byte regions in the same file.<br>       Even when the filesystem correctly handles the coherency issues in<br>       this situation, overall I/O throughput is likely to be slower than<br>       using either mode alone.  Likewise, applications should avoid mixing<br>       mmap(2) of files with direct I/O to the same files.<br><br>       The behavior of <b>O_DIRECT </b>with NFS will differ from local filesystems.<br>       Older kernels, or kernels configured in certain ways, may not support<br>       this combination.  The NFS protocol does not support passing the flag<br>       to the server, so <b>O_DIRECT </b>I/O will bypass the page cache only on the<br>       client; the server may still cache the I/O.  The client asks the<br>       server to make the I/O synchronous to preserve the synchronous<br>       semantics of <b>O_DIRECT</b>.  Some servers will perform poorly under these<br>       circumstances, especially if the I/O size is small.  Some servers may<br>       also be configured to lie to clients about the I/O having reached<br>       stable storage; this will avoid the performance penalty at some risk<br>       to data integrity in the event of server power failure.  The Linux<br>       NFS client places no alignment restrictions on <b>O_DIRECT </b>I/O.<br><br>       In summary, <b>O_DIRECT </b>is a potentially powerful tool that should be<br>       used with caution.  It is recommended that applications treat use of<br>       <b>O_DIRECT </b>as a performance option which is disabled by default.<br><br>              \"The thing that has always disturbed me about O_DIRECT is that<br>              the whole interface is just stupid, and was probably designed<br>              by a deranged monkey on some serious mind-controlling<br>              substances.\"&#8212;Linus<br></pre><br><h2>BUGS  </h2><pre><br>       Currently, it is not possible to enable signal-driven I/O by<br>       specifying <b>O_ASYNC </b>when calling <b>open</b>(); use fcntl(2) to enable this<br>       flag.<br><br>       One must check for two different error codes, <b>EISDIR </b>and <b>ENOENT</b>, when<br>       trying to determine whether the kernel supports <b>O_TMPFILE</b><br>       functionality.<br><br>       When both <b>O_CREAT </b>and <b>O_DIRECTORY </b>are specified in <i>flags</i> and the file<br>       specified by <i>pathname</i> does not exist, <b>open</b>() will create a regular<br>       file (i.e., <b>O_DIRECTORY </b>is ignored).<br></pre><br><h2>SEE ALSO  </h2><pre><br>       chmod(2), chown(2), close(2), dup(2), fcntl(2), link(2), lseek(2),<br>       mknod(2), mmap(2), mount(2), open_by_handle_at(2), read(2),<br>       socket(2), stat(2), umask(2), unlink(2), write(2), fopen(3), acl(5)<br>       fifo(7), path_resolution(7), symlink(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-05-07                          OPEN(2)</span><br></pre><br>"}