{"Man page": "<pre><br><span class=\"headline\">ACCESS(2)                 Linux Programmer's Manual                ACCESS(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       access, faccessat - check user's permissions for a file<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>int access(const char *</b><i>pathname</i><b>, int </b><i>mode</i><b>);</b><br><br>       <b>#include &lt;fcntl.h&gt;           </b>/* Definition of AT_* constants */<br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>int faccessat(int </b><i>dirfd</i><b>, const char *</b><i>pathname</i><b>, int </b><i>mode</i><b>, int </b><i>flags</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>faccessat</b>():<br>           Since glibc 2.10:<br>               _XOPEN_SOURCE &gt;= 700 || _POSIX_C_SOURCE &gt;= 200809L<br>           Before glibc 2.10:<br>               _ATFILE_SOURCE<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>access</b>() checks whether the calling process can access the file<br>       <i>pathname</i>.  If <i>pathname</i> is a symbolic link, it is dereferenced.<br><br>       The <i>mode</i> specifies the accessibility check(s) to be performed, and is<br>       either the value <b>F_OK</b>, or a mask consisting of the bitwise OR of one<br>       or more of <b>R_OK</b>, <b>W_OK</b>, and <b>X_OK</b>.  <b>F_OK </b>tests for the existence of the<br>       file.  <b>R_OK</b>, <b>W_OK</b>, and <b>X_OK </b>test whether the file exists and grants<br>       read, write, and execute permissions, respectively.<br><br>       The check is done using the calling process's <i>real</i> UID and GID,<br>       rather than the effective IDs as is done when actually attempting an<br>       operation (e.g., open(2)) on the file.  Similarly, for the root user,<br>       the check uses the set of permitted capabilities rather than the set<br>       of effective capabilities; and for non-root users, the check uses an<br>       empty set of capabilities.<br><br>       This allows set-user-ID programs and capability-endowed programs to<br>       easily determine the invoking user's authority.  In other words,<br>       <b>access</b>() does not answer the \"can I read/write/execute this file?\"<br>       question.  It answers a slightly different question: \"(assuming I'm a<br>       setuid binary) can <i>the user who invoked me</i> read/write/execute this<br>       file?\", which gives set-user-ID programs the possibility to prevent<br>       malicious users from causing them to read files which users shouldn't<br>       be able to read.<br><br>       If the calling process is privileged (i.e., its real UID is zero),<br>       then an <b>X_OK </b>check is successful for a regular file if execute<br>       permission is enabled for any of the file owner, group, or other.<br><br>   <b>faccessat()</b><br>       The <b>faccessat</b>() system call operates in exactly the same way as<br>       <b>access</b>(), except for the differences described here.<br><br>       If the pathname given in <i>pathname</i> is relative, then it is interpreted<br>       relative to the directory referred to by the file descriptor <i>dirfd</i><br>       (rather than relative to the current working directory of the calling<br>       process, as is done by <b>access</b>() for a relative pathname).<br><br>       If <i>pathname</i> is relative and <i>dirfd</i> is the special value <b>AT_FDCWD</b>, then<br>       <i>pathname</i> is interpreted relative to the current working directory of<br>       the calling process (like <b>access</b>()).<br><br>       If <i>pathname</i> is absolute, then <i>dirfd</i> is ignored.<br><br>       <i>flags</i> is constructed by ORing together zero or more of the following<br>       values:<br><br>       <b>AT_EACCESS</b><br>              Perform access checks using the effective user and group IDs.<br>              By default, <b>faccessat</b>() uses the real IDs (like <b>access</b>()).<br><br>       <b>AT_SYMLINK_NOFOLLOW</b><br>              If <i>pathname</i> is a symbolic link, do not dereference it: instead<br>              return information about the link itself.<br><br>       See openat(2) for an explanation of the need for <b>faccessat</b>().<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success (all requested permissions granted, or <i>mode</i> is <b>F_OK </b>and<br>       the file exists), zero is returned.  On error (at least one bit in<br>       <i>mode</i> asked for a permission that is denied, or <i>mode</i> is <b>F_OK </b>and the<br>       file does not exist, or some other error occurred), -1 is returned,<br>       and <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>access</b>() and <b>faccessat</b>() shall fail if:<br><br>       <b>EACCES </b>The requested access would be denied to the file, or search<br>              permission is denied for one of the directories in the path<br>              prefix of <i>pathname</i>.  (See also path_resolution(7).)<br><br>       <b>ELOOP  </b>Too many symbolic links were encountered in resolving<br>              <i>pathname</i>.<br><br>       <b>ENAMETOOLONG</b><br>              <i>pathname</i> is too long.<br><br>       <b>ENOENT </b>A component of <i>pathname</i> does not exist or is a dangling<br>              symbolic link.<br><br>       <b>ENOTDIR</b><br>              A component used as a directory in <i>pathname</i> is not, in fact, a<br>              directory.<br><br>       <b>EROFS  </b>Write permission was requested for a file on a read-only<br>              filesystem.<br><br>       <b>access</b>() and <b>faccessat</b>() may fail if:<br><br>       <b>EFAULT </b><i>pathname</i> points outside your accessible address space.<br><br>       <b>EINVAL </b><i>mode</i> was incorrectly specified.<br><br>       <b>EIO    </b>An I/O error occurred.<br><br>       <b>ENOMEM </b>Insufficient kernel memory was available.<br><br>       <b>ETXTBSY</b><br>              Write access was requested to an executable which is being<br>              executed.<br><br>       The following additional errors can occur for <b>faccessat</b>():<br><br>       <b>EBADF  </b><i>dirfd</i> is not a valid file descriptor.<br><br>       <b>EINVAL </b>Invalid flag specified in <i>flags</i>.<br><br>       <b>ENOTDIR</b><br>              <i>pathname</i> is relative and <i>dirfd</i> is a file descriptor referring<br>              to a file other than a directory.<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>faccessat</b>() was added to Linux in kernel 2.6.16; library support was<br>       added to glibc in version 2.4.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>access</b>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008.<br><br>       <b>faccessat</b>(): POSIX.1-2008.<br></pre><br><h2>NOTES  </h2><pre><br>       <b>Warning</b>: Using these calls to check if a user is authorized to, for<br>       example, open a file before actually doing so using open(2) creates a<br>       security hole, because the user might exploit the short time interval<br>       between checking and opening the file to manipulate it.  <b>For this</b><br>       <b>reason, the use of this system call should be avoided</b>.  (In the<br>       example just described, a safer alternative would be to temporarily<br>       switch the process's effective user ID to the real ID and then call<br>       open(2).)<br><br>       <b>access</b>() always dereferences symbolic links.  If you need to check<br>       the permissions on a symbolic link, use faccessat(2) with the flag<br>       <b>AT_SYMLINK_NOFOLLOW</b>.<br><br>       These calls return an error if any of the access types in <i>mode</i> is<br>       denied, even if some of the other access types in <i>mode</i> are permitted.<br><br>       If the calling process has appropriate privileges (i.e., is<br>       superuser), POSIX.1-2001 permits an implementation to indicate<br>       success for an <b>X_OK </b>check even if none of the execute file permission<br>       bits are set.  Linux does not do this.<br><br>       A file is accessible only if the permissions on each of the<br>       directories in the path prefix of <i>pathname</i> grant search (i.e.,<br>       execute) access.  If any directory is inaccessible, then the <b>access</b>()<br>       call will fail, regardless of the permissions on the file itself.<br><br>       Only access bits are checked, not the file type or contents.<br>       Therefore, if a directory is found to be writable, it probably means<br>       that files can be created in the directory, and not that the<br>       directory can be written as a file.  Similarly, a DOS file may be<br>       found to be \"executable,\" but the execve(2) call will still fail.<br><br>       These calls may not work correctly on NFSv2 filesystems with UID<br>       mapping enabled, because UID mapping is done on the server and hidden<br>       from the client, which checks permissions.  (NFS versions 3 and<br>       higher perform the check on the server.)  Similar problems can occur<br>       to FUSE mounts.<br><br>   <b>C library/kernel differences</b><br>       The raw <b>faccessat</b>() system call takes only the first three arguments.<br>       The <b>AT_EACCESS </b>and <b>AT_SYMLINK_NOFOLLOW </b>flags are actually implemented<br>       within the glibc wrapper function for <b>faccessat</b>().  If either of<br>       these flags is specified, then the wrapper function employs<br>       fstatat(2) to determine access permissions.<br><br>   <b>Glibc notes</b><br>       On older kernels where <b>faccessat</b>() is unavailable (and when the<br>       <b>AT_EACCESS </b>and <b>AT_SYMLINK_NOFOLLOW </b>flags are not specified), the<br>       glibc wrapper function falls back to the use of <b>access</b>().  When<br>       <i>pathname</i> is a relative pathname, glibc constructs a pathname based on<br>       the symbolic link in <i>/proc/self/fd</i> that corresponds to the <i>dirfd</i><br>       argument.<br></pre><br><h2>BUGS  </h2><pre><br>       In kernel 2.4 (and earlier) there is some strangeness in the handling<br>       of <b>X_OK </b>tests for superuser.  If all categories of execute permission<br>       are disabled for a nondirectory file, then the only <b>access</b>() test<br>       that returns -1 is when <i>mode</i> is specified as just <b>X_OK</b>; if <b>R_OK </b>or<br>       <b>W_OK </b>is also specified in <i>mode</i>, then <b>access</b>() returns 0 for such<br>       files.  Early 2.6 kernels (up to and including 2.6.3) also behaved in<br>       the same way as kernel 2.4.<br><br>       In kernels before 2.6.20, these calls ignored the effect of the<br>       <b>MS_NOEXEC </b>flag if it was used to mount(2) the underlying filesystem.<br>       Since kernel 2.6.20, the <b>MS_NOEXEC </b>flag is honored.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       chmod(2), chown(2), open(2), setgid(2), setuid(2), stat(2),<br>       euidaccess(3), credentials(7), path_resolution(7), symlink(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                        ACCESS(2)</span><br></pre><br>"}