{"Man page": "<pre><br><span class=\"headline\">WRITE(2)                  Linux Programmer's Manual                 WRITE(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       write - write to a file descriptor<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>ssize_t write(int </b><i>fd</i><b>, const void *</b><i>buf</i><b>, size_t </b><i>count</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>write</b>() writes up to <i>count</i> bytes from the buffer pointed <i>buf</i> to the<br>       file referred to by the file descriptor <i>fd</i>.<br><br>       The number of bytes written may be less than <i>count</i> if, for example,<br>       there is insufficient space on the underlying physical medium, or the<br>       <b>RLIMIT_FSIZE </b>resource limit is encountered (see setrlimit(2)), or the<br>       call was interrupted by a signal handler after having written less<br>       than <i>count</i> bytes.  (See also pipe(7).)<br><br>       For a seekable file (i.e., one to which lseek(2) may be applied, for<br>       example, a regular file) writing takes place at the current file<br>       offset, and the file offset is incremented by the number of bytes<br>       actually written.  If the file was open(2)ed with <b>O_APPEND</b>, the file<br>       offset is first set to the end of the file before writing.  The<br>       adjustment of the file offset and the write operation are performed<br>       as an atomic step.<br><br>       POSIX requires that a read(2) which can be proved to occur after a<br>       <b>write</b>() has returned returns the new data.  Note that not all<br>       filesystems are POSIX conforming.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, the number of bytes written is returned (zero indicates<br>       nothing was written).  It is not an error if this number is smaller<br>       than the number of bytes requested; this may happen for example<br>       because the disk device was filled.  See also NOTES.<br><br>       On error, -1 is returned, and <i>errno</i> is set appropriately.<br><br>       If <i>count</i> is zero and <i>fd</i> refers to a regular file, then <b>write</b>() may<br>       return a failure status if one of the errors below is detected.  If<br>       no errors are detected, 0 will be returned without causing any other<br>       effect.  If <i>count</i> is zero and <i>fd</i> refers to a file other than a<br>       regular file, the results are not specified.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EAGAIN </b>The file descriptor <i>fd</i> refers to a file other than a socket<br>              and has been marked nonblocking (<b>O_NONBLOCK</b>), and the write<br>              would block.  See open(2) for further details on the<br>              <b>O_NONBLOCK </b>flag.<br><br>       <b>EAGAIN </b>or <b>EWOULDBLOCK</b><br>              The file descriptor <i>fd</i> refers to a socket and has been marked<br>              nonblocking (<b>O_NONBLOCK</b>), and the write would block.<br>              POSIX.1-2001 allows either error to be returned for this case,<br>              and does not require these constants to have the same value,<br>              so a portable application should check for both possibilities.<br><br>       <b>EBADF  </b><i>fd</i> is not a valid file descriptor or is not open for writing.<br><br>       <b>EDESTADDRREQ</b><br>              <i>fd</i> refers to a datagram socket for which a peer address has<br>              not been set using connect(2).<br><br>       <b>EDQUOT </b>The user's quota of disk blocks on the filesystem containing<br>              the file referred to by <i>fd</i> has been exhausted.<br><br>       <b>EFAULT </b><i>buf</i> is outside your accessible address space.<br><br>       <b>EFBIG  </b>An attempt was made to write a file that exceeds the<br>              implementation-defined maximum file size or the process's file<br>              size limit, or to write at a position past the maximum allowed<br>              offset.<br><br>       <b>EINTR  </b>The call was interrupted by a signal before any data was<br>              written; see signal(7).<br><br>       <b>EINVAL </b><i>fd</i> is attached to an object which is unsuitable for writing;<br>              or the file was opened with the <b>O_DIRECT </b>flag, and either the<br>              address specified in <i>buf</i>, the value specified in <i>count</i>, or the<br>              current file offset is not suitably aligned.<br><br>       <b>EIO    </b>A low-level I/O error occurred while modifying the inode.<br><br>       <b>ENOSPC </b>The device containing the file referred to by <i>fd</i> has no room<br>              for the data.<br><br>       <b>EPERM  </b>The operation was prevented by a file seal; see fcntl(2).<br><br>       <b>EPIPE  </b><i>fd</i> is connected to a pipe or socket whose reading end is<br>              closed.  When this happens the writing process will also<br>              receive a <b>SIGPIPE </b>signal.  (Thus, the write return value is<br>              seen only if the program catches, blocks or ignores this<br>              signal.)<br><br>       Other errors may occur, depending on the object connected to <i>fd</i>.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       SVr4, 4.3BSD, POSIX.1-2001.<br><br>       Under SVr4 a write may be interrupted and return <b>EINTR </b>at any point,<br>       not just before any data is written.<br></pre><br><h2>NOTES  </h2><pre><br>       A successful return from <b>write</b>() does not make any guarantee that<br>       data has been committed to disk.  In fact, on some buggy<br>       implementations, it does not even guarantee that space has<br>       successfully been reserved for the data.  The only way to be sure is<br>       to call fsync(2) after you are done writing all your data.<br><br>       If a <b>write</b>() is interrupted by a signal handler before any bytes are<br>       written, then the call fails with the error <b>EINTR</b>; if it is<br>       interrupted after at least one byte has been written, the call<br>       succeeds, and returns the number of bytes written.<br><br>       On Linux, <b>write</b>() (and similar system calls) will transfer at most<br>       0x7ffff000 (2,147,479,552) bytes, returning the number of bytes<br>       actually transferred.  (This is true on both 32-bit and 64-bit<br>       systems.)<br></pre><br><h2>BUGS  </h2><pre><br>       According to POSIX.1-2008/SUSv4 Section XSI 2.9.7 (\"Thread<br>       Interactions with Regular File Operations\"):<br><br>           All of the following functions shall be atomic with respect to<br>           each other in the effects specified in POSIX.1-2008 when they<br>           operate on regular files or symbolic links: ...<br><br>       Among the APIs subsequently listed are <b>write</b>() and writev(2).  And<br>       among the effects that should be atomic across threads (and<br>       processes) are updates of the file offset.  However, on Linux before<br>       version 3.14, this was not the case: if two processes that share an<br>       open file description (see open(2)) perform a <b>write</b>() (or writev(2))<br>       at the same time, then the I/O operations were not atomic with<br>       respect updating the file offset, with the result that the blocks of<br>       data output by the two processes might (incorrectly) overlap.  This<br>       problem was fixed in Linux 3.14.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       close(2), fcntl(2), fsync(2), ioctl(2), lseek(2), open(2), pwrite(2),<br>       read(2), select(2), writev(2), fwrite(3)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                         WRITE(2)</span><br></pre><br>"}