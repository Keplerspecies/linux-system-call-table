{"Man page": "<pre><br><span class=\"headline\">PROCESS_VM_READV(2)       Linux Programmer's Manual      PROCESS_VM_READV(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       process_vm_readv,  process_vm_writev  - transfer data between process<br>       address spaces<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/uio.h&gt;</b><br><br>       <b>ssize_t process_vm_readv(pid_t </b><i>pid</i><b>,</b><br>                                <b>const struct iovec *</b><i>local_iov</i><b>,</b><br>                                <b>unsigned long </b><i>liovcnt</i><b>,</b><br>                                <b>const struct iovec *</b><i>remote_iov</i><b>,</b><br>                                <b>unsigned long </b><i>riovcnt</i><b>,</b><br>                                <b>unsigned long </b><i>flags</i><b>);</b><br><br>       <b>ssize_t process_vm_writev(pid_t </b><i>pid</i><b>,</b><br>                                 <b>const struct iovec *</b><i>local_iov</i><b>,</b><br>                                 <b>unsigned long </b><i>liovcnt</i><b>,</b><br>                                 <b>const struct iovec *</b><i>remote_iov</i><b>,</b><br>                                 <b>unsigned long </b><i>riovcnt</i><b>,</b><br>                                 <b>unsigned long </b><i>flags</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>process_vm_readv</b>(), <b>process_vm_writev</b>():<br>           <b>_GNU_SOURCE</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       These system calls transfer data between the address space of the<br>       calling process (\"the local process\") and the process identified by<br>       <i>pid</i> (\"the remote process\").  The data moves directly between the<br>       address spaces of the two processes, without passing through kernel<br>       space.<br><br>       The <b>process_vm_readv</b>() system call transfers data from the remote<br>       process to the local process.  The data to be transferred is<br>       identified by <i>remote_iov</i> and <i>riovcnt</i>: <i>remote_iov</i> is a pointer to an<br>       array describing address ranges in the process <i>pid</i>, and <i>riovcnt</i><br>       specifies the number of elements in <i>remote_iov</i>.  The data is<br>       transferred to the locations specified by <i>local_iov</i> and <i>liovcnt</i>:<br>       <i>local_iov</i> is a pointer to an array describing address ranges in the<br>       calling process, and <i>liovcnt</i> specifies the number of elements in<br>       <i>local_iov</i>.<br><br>       The <b>process_vm_writev</b>() system call is the converse of<br>       <b>process_vm_readv</b>()&#8212;it transfers data from the local process to the<br>       remote process.  Other than the direction of the transfer, the<br>       arguments <i>liovcnt</i>, <i>local_iov</i>, <i>riovcnt</i>, and <i>remote_iov</i> have the same<br>       meaning as for <b>process_vm_readv</b>().<br><br>       The <i>local_iov</i> and <i>remote_iov</i> arguments point to an array of <i>iovec</i><br>       structures, defined in <i>&lt;sys/uio.h&gt;</i> as:<br><br>           struct iovec {<br>               void  *iov_base;    /* Starting address */<br>               size_t iov_len;     /* Number of bytes to transfer */<br>           };<br><br>       Buffers are processed in array order.  This means that<br>       <b>process_vm_readv</b>() completely fills <i>local_iov[0]</i> before proceeding to<br>       <i>local_iov[1]</i>, and so on.  Likewise, <i>remote_iov[0]</i> is completely read<br>       before proceeding to <i>remote_iov[1]</i>, and so on.<br><br>       Similarly, <b>process_vm_writev</b>() writes out the entire contents of<br>       <i>local_iov[0]</i> before proceeding to <i>local_iov[1]</i>, and it completely<br>       fills <i>remote_iov[0]</i> before proceeding to <i>remote_iov[1]</i>.<br><br>       The lengths of <i>remote_iov[i].iov_len</i> and <i>local_iov[i].iov_len</i> do not<br>       have to be the same.  Thus, it is possible to split a single local<br>       buffer into multiple remote buffers, or vice versa.<br><br>       The <i>flags</i> argument is currently unused and must be set to 0.<br><br>       The values specified in the <i>liovcnt</i> and <i>riovcnt</i> arguments must be<br>       less than or equal to <b>IOV_MAX </b>(defined in <i>&lt;limits.h&gt;</i> or accessible<br>       via the call <i>sysconf(_SC_IOV_MAX)</i>).<br><br>       The count arguments and <i>local_iov</i> are checked before doing any<br>       transfers.  If the counts are too big, or <i>local_iov</i> is invalid, or<br>       the addresses refer to regions that are inaccessible to the local<br>       process, none of the vectors will be processed and an error will be<br>       returned immediately.<br><br>       Note, however, that these system calls do not check the memory<br>       regions in the remote process until just before doing the read/write.<br>       Consequently, a partial read/write (see RETURN VALUE) may result if<br>       one of the <i>remote_iov</i> elements points to an invalid memory region in<br>       the remote process.  No further reads/writes will be attempted beyond<br>       that point.  Keep this in mind when attempting to read data of<br>       unknown length (such as C strings that are null-terminated) from a<br>       remote process, by avoiding spanning memory pages (typically 4KiB) in<br>       a single remote <i>iovec</i> element.  (Instead, split the remote read into<br>       two <i>remote_iov</i> elements and have them merge back into a single write<br>       <i>local_iov</i> entry.  The first read entry goes up to the page boundary,<br>       while the second starts on the next page boundary.)<br><br>       In order to read from or write to another process, either the caller<br>       must have the capability <b>CAP_SYS_PTRACE</b>, or the real user ID,<br>       effective user ID, and saved set-user-ID of the remote process must<br>       match the real user ID of the caller <i>and</i> the real group ID, effective<br>       group ID, and saved set-group-ID of the remote process must match the<br>       real group ID of the caller.  (The permission required is exactly the<br>       same as that required to perform a ptrace(2) <b>PTRACE_ATTACH </b>on the<br>       remote process.)<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>process_vm_readv</b>() returns the number of bytes read and<br>       <b>process_vm_writev</b>() returns the number of bytes written.  This return<br>       value may be less than the total number of requested bytes, if a<br>       partial read/write occurred.  (Partial transfers apply at the<br>       granularity of <i>iovec</i> elements.  These system calls won't perform a<br>       partial transfer that splits a single <i>iovec</i> element.)  The caller<br>       should check the return value to determine whether a partial<br>       read/write occurred.<br><br>       On error, -1 is returned and <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EINVAL </b>The sum of the <i>iov_len</i> values of either <i>local_iov</i> or<br>              <i>remote_iov</i> overflows a <i>ssize_t</i> value.<br><br>       <b>EINVAL </b><i>flags</i> is not 0.<br><br>       <b>EINVAL </b><i>liovcnt</i> or <i>riovcnt</i> is too large.<br><br>       <b>EFAULT </b>The memory described by <i>local_iov</i> is outside the caller's<br>              accessible address space.<br><br>       <b>EFAULT </b>The memory described by <i>remote_iov</i> is outside the accessible<br>              address space of the process <i>pid</i>.<br><br>       <b>ENOMEM </b>Could not allocate memory for internal copies of the <i>iovec</i><br>              structures.<br><br>       <b>EPERM  </b>The caller does not have permission to access the address<br>              space of the process <i>pid</i>.<br><br>       <b>ESRCH  </b>No process with ID <i>pid</i> exists.<br></pre><br><h2>VERSIONS  </h2><pre><br>       These system calls were added in Linux 3.2.  Support is provided in<br>       glibc since version 2.15.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       These system calls are nonstandard Linux extensions.<br></pre><br><h2>NOTES  </h2><pre><br>       The data transfers performed by <b>process_vm_readv</b>() and<br>       <b>process_vm_writev</b>() are not guaranteed to be atomic in any way.<br><br>       These system calls were designed to permit fast message passing by<br>       allowing messages to be exchanged with a single copy operation<br>       (rather than the double copy that would be required when using, for<br>       example, shared memory or pipes).<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The following code sample demonstrates the use of <b>process_vm_readv</b>().<br>       It reads 20 bytes at the address 0x10000 from the process with PID 10<br>       and writes the first 10 bytes into <i>buf1</i> and the second 10 bytes into<br>       <i>buf2</i>.<br><br>       #include &lt;sys/uio.h&gt;<br><br>       int<br>       main(void)<br>       {<br>           struct iovec local[2];<br>           struct iovec remote[1];<br>           char buf1[10];<br>           char buf2[10];<br>           ssize_t nread;<br>           pid_t pid = 10;             /* PID of remote process */<br><br>           local[0].iov_base = buf1;<br>           local[0].iov_len = 10;<br>           local[1].iov_base = buf2;<br>           local[1].iov_len = 10;<br>           remote[0].iov_base = (void *) 0x10000;<br>           remote[0].iov_len = 20;<br><br>           nread = process_vm_readv(pid, local, 2, remote, 1, 0);<br>           if (nread != 20)<br>               return 1;<br>           else<br>               return 0;<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       readv(2), writev(2)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2014-08-19              PROCESS_VM_READV(2)</span><br></pre><br>"}