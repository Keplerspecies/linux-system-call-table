{"Man page": "<pre><br><span class=\"headline\">PERF_EVENT_OPEN(2)        Linux Programmer's Manual       PERF_EVENT_OPEN(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       perf_event_open - set up performance monitoring<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;linux/perf_event.h&gt;</b><br>       <b>#include &lt;linux/hw_breakpoint.h&gt;</b><br><br>       <b>int perf_event_open(struct perf_event_attr *</b><i>attr</i><b>,</b><br>                           <b>pid_t </b><i>pid</i><b>, int </b><i>cpu</i><b>, int </b><i>group_fd</i><b>,</b><br>                           <b>unsigned long </b><i>flags</i><b>);</b><br><br>       <i>Note</i>: There is no glibc wrapper for this system call; see NOTES.<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       Given a list of parameters, <b>perf_event_open</b>() returns a file<br>       descriptor, for use in subsequent system calls (read(2), mmap(2),<br>       prctl(2), fcntl(2), etc.).<br><br>       A call to <b>perf_event_open</b>() creates a file descriptor that allows<br>       measuring performance information.  Each file descriptor corresponds<br>       to one event that is measured; these can be grouped together to<br>       measure multiple events simultaneously.<br><br>       Events can be enabled and disabled in two ways: via ioctl(2) and via<br>       prctl(2).  When an event is disabled it does not count or generate<br>       overflows but does continue to exist and maintain its count value.<br><br>       Events come in two flavors: counting and sampled.  A <i>counting</i> event<br>       is one that is used for counting the aggregate number of events that<br>       occur.  In general, counting event results are gathered with a<br>       read(2) call.  A <i>sampling</i> event periodically writes measurements to a<br>       buffer that can then be accessed via mmap(2).<br><br>   <b>Arguments</b><br>       The <i>pid</i> and <i>cpu</i> arguments allow specifying which process and CPU to<br>       monitor:<br><br>       <b>pid == 0 </b>and <b>cpu == -1</b><br>              This measures the calling process/thread on any CPU.<br><br>       <b>pid == 0 </b>and <b>cpu &gt;= 0</b><br>              This measures the calling process/thread only when running on<br>              the specified CPU.<br><br>       <b>pid &gt; 0 </b>and <b>cpu == -1</b><br>              This measures the specified process/thread on any CPU.<br><br>       <b>pid &gt; 0 </b>and <b>cpu &gt;= 0</b><br>              This measures the specified process/thread only when running<br>              on the specified CPU.<br><br>       <b>pid == -1 </b>and <b>cpu &gt;= 0</b><br>              This measures all processes/threads on the specified CPU.<br>              This requires <b>CAP_SYS_ADMIN </b>capability or a<br>              <i>/proc/sys/kernel/perf_event_paranoid</i> value of less than 1.<br><br>       <b>pid == -1 </b>and <b>cpu == -1</b><br>              This setting is invalid and will return an error.<br><br>       The <i>group_fd</i> argument allows event groups to be created.  An event<br>       group has one event which is the group leader.  The leader is created<br>       first, with <i>group_fd</i> = -1.  The rest of the group members are created<br>       with subsequent <b>perf_event_open</b>() calls with <i>group_fd</i> being set to<br>       the file descriptor of the group leader.  (A single event on its own<br>       is created with <i>group_fd</i> = -1 and is considered to be a group with<br>       only 1 member.)  An event group is scheduled onto the CPU as a unit:<br>       it will be put onto the CPU only if all of the events in the group<br>       can be put onto the CPU.  This means that the values of the member<br>       events can be meaningfully compared&#8212;added, divided (to get ratios),<br>       and so on&#8212;with each other, since they have counted events for the<br>       same set of executed instructions.<br><br>       The <i>flags</i> argument is formed by ORing together zero or more of the<br>       following values:<br><br>       <b>PERF_FLAG_FD_CLOEXEC </b>(since Linux 3.14)<br>              This flag enables the close-on-exec flag for the created event<br>              file descriptor, so that the file descriptor is automatically<br>              closed on execve(2).  Setting the close-on-exec flags at<br>              creation time, rather than later with fcntl(2), avoids<br>              potential race conditions where the calling thread invokes<br>              <b>perf_event_open</b>() and fcntl(2) at the same time as another<br>              thread calls fork(2) then execve(2).<br><br>       <b>PERF_FLAG_FD_NO_GROUP</b><br>              This flag tells the event to ignore the <i>group_fd</i> parameter<br>              except for the purpose of setting up output redirection using<br>              the <b>PERF_FLAG_FD_OUTPUT </b>flag.<br><br>       <b>PERF_FLAG_FD_OUTPUT </b>(broken since Linux 2.6.35)<br>              This flag re-routes the event's sampled output to instead be<br>              included in the mmap buffer of the event specified by<br>              <i>group_fd</i>.<br><br>       <b>PERF_FLAG_PID_CGROUP </b>(since Linux 2.6.39)<br>              This flag activates per-container system-wide monitoring.  A<br>              container is an abstraction that isolates a set of resources<br>              for finer-grained control (CPUs, memory, etc.).  In this mode,<br>              the event is measured only if the thread running on the<br>              monitored CPU belongs to the designated container (cgroup).<br>              The cgroup is identified by passing a file descriptor opened<br>              on its directory in the cgroupfs filesystem.  For instance, if<br>              the cgroup to monitor is called <i>test</i>, then a file descriptor<br>              opened on <i>/dev/cgroup/test</i> (assuming cgroupfs is mounted on<br>              <i>/dev/cgroup</i>) must be passed as the <i>pid</i> parameter.  cgroup<br>              monitoring is available only for system-wide events and may<br>              therefore require extra permissions.<br><br>       The <i>perf_event_attr</i> structure provides detailed configuration<br>       information for the event being created.<br><br>           struct perf_event_attr {<br>               __u32 type;         /* Type of event */<br>               __u32 size;         /* Size of attribute structure */<br>               __u64 config;       /* Type-specific configuration */<br><br>               union {<br>                   __u64 sample_period;    /* Period of sampling */<br>                   __u64 sample_freq;      /* Frequency of sampling */<br>               };<br><br>               __u64 sample_type;  /* Specifies values included in sample */<br>               __u64 read_format;  /* Specifies values returned in read */<br><br>               __u64 disabled       : 1,   /* off by default */<br>                     inherit        : 1,   /* children inherit it */<br>                     pinned         : 1,   /* must always be on PMU */<br>                     exclusive      : 1,   /* only group on PMU */<br>                     exclude_user   : 1,   /* don't count user */<br>                     exclude_kernel : 1,   /* don't count kernel */<br>                     exclude_hv     : 1,   /* don't count hypervisor */<br>                     exclude_idle   : 1,   /* don't count when idle */<br>                     mmap           : 1,   /* include mmap data */<br>                     comm           : 1,   /* include comm data */<br>                     freq           : 1,   /* use freq, not period */<br>                     inherit_stat   : 1,   /* per task counts */<br>                     enable_on_exec : 1,   /* next exec enables */<br>                     task           : 1,   /* trace fork/exit */<br>                     watermark      : 1,   /* wakeup_watermark */<br>                     precise_ip     : 2,   /* skid constraint */<br>                     mmap_data      : 1,   /* non-exec mmap data */<br>                     sample_id_all  : 1,   /* sample_type all events */<br>                     exclude_host   : 1,   /* don't count in host */<br>                     exclude_guest  : 1,   /* don't count in guest */<br>                     exclude_callchain_kernel : 1,<br>                                           /* exclude kernel callchains */<br>                     exclude_callchain_user   : 1,<br>                                           /* exclude user callchains */<br>                     mmap2          :  1,  /* include mmap with inode data */<br>                     comm_exec      :  1,  /* flag comm events that are due to exec */<br>                     __reserved_1   : 39;<br><br>               union {<br>                   __u32 wakeup_events;    /* wakeup every n events */<br>                   __u32 wakeup_watermark; /* bytes before wakeup */<br>               };<br><br>               __u32     bp_type;          /* breakpoint type */<br><br>               union {<br>                   __u64 bp_addr;          /* breakpoint address */<br>                   __u64 config1;          /* extension of config */<br>               };<br><br>               union {<br>                   __u64 bp_len;           /* breakpoint length */<br>                   __u64 config2;          /* extension of config1 */<br>               };<br>               __u64 branch_sample_type;   /* enum perf_branch_sample_type */<br>               __u64 sample_regs_user;     /* user regs to dump on samples */<br>               __u32 sample_stack_user;    /* size of stack to dump on<br>                                              samples */<br>               __u32 __reserved_2;         /* Align to u64 */<br>               __u64 sample_regs_intr;     /* regs to dump on samples */<br>           };<br><br>       The fields of the <i>perf_event_attr</i> structure are described in more<br>       detail below:<br><br>       <i>type</i>   This field specifies the overall event type.  It has one of<br>              the following values:<br><br>              <b>PERF_TYPE_HARDWARE</b><br>                     This indicates one of the \"generalized\" hardware events<br>                     provided by the kernel.  See the <i>config</i> field<br>                     definition for more details.<br><br>              <b>PERF_TYPE_SOFTWARE</b><br>                     This indicates one of the software-defined events<br>                     provided by the kernel (even if no hardware support is<br>                     available).<br><br>              <b>PERF_TYPE_TRACEPOINT</b><br>                     This indicates a tracepoint provided by the kernel<br>                     tracepoint infrastructure.<br><br>              <b>PERF_TYPE_HW_CACHE</b><br>                     This indicates a hardware cache event.  This has a<br>                     special encoding, described in the <i>config</i> field<br>                     definition.<br><br>              <b>PERF_TYPE_RAW</b><br>                     This indicates a \"raw\" implementation-specific event in<br>                     the <i>config</i> field.<br><br>              <b>PERF_TYPE_BREAKPOINT </b>(since Linux 2.6.33)<br>                     This indicates a hardware breakpoint as provided by the<br>                     CPU.  Breakpoints can be read/write accesses to an<br>                     address as well as execution of an instruction address.<br><br>              dynamic PMU<br>                     Since Linux 2.6.38, <b>perf_event_open</b>() can support<br>                     multiple PMUs.  To enable this, a value exported by the<br>                     kernel can be used in the <i>type</i> field to indicate which<br>                     PMU to use.  The value to use can be found in the sysfs<br>                     filesystem: there is a subdirectory per PMU instance<br>                     under <i>/sys/bus/event_source/devices</i>.  In each<br>                     subdirectory there is a <i>type</i> file whose content is an<br>                     integer that can be used in the <i>type</i> field.  For<br>                     instance, <i>/sys/bus/event_source/devices/cpu/type</i><br>                     contains the value for the core CPU PMU, which is<br>                     usually 4.<br><br>       <i>size</i>   The size of the <i>perf_event_attr</i> structure for forward/backward<br>              compatibility.  Set this using <i>sizeof(struct perf_event_attr)</i><br>              to allow the kernel to see the struct size at the time of<br>              compilation.<br><br>              The related define <b>PERF_ATTR_SIZE_VER0 </b>is set to 64; this was<br>              the size of the first published struct.  <b>PERF_ATTR_SIZE_VER1</b><br>              is 72, corresponding to the addition of breakpoints in Linux<br>              2.6.33.  <b>PERF_ATTR_SIZE_VER2 </b>is 80 corresponding to the<br>              addition of branch sampling in Linux 3.4.  <b>PERF_ATTR_SIZE_VER3</b><br>              is 96 corresponding to the addition of <i>sample_regs_user</i> and<br>              <i>sample_stack_user</i> in Linux 3.7.  <b>PERF_ATTR_SIZE_VER4 </b>is 104<br>              corresponding to the addition of <i>sample_regs_intr</i> in Linux<br>              3.19.<br><br>       <i>config</i> This specifies which event you want, in conjunction with the<br>              <i>type</i> field.  The <i>config1</i> and <i>config2</i> fields are also taken<br>              into account in cases where 64 bits is not enough to fully<br>              specify the event.  The encoding of these fields are event<br>              dependent.<br><br>              There are various ways to set the <i>config</i> field that are<br>              dependent on the value of the previously described <i>type</i> field.<br>              What follows are various possible settings for <i>config</i><br>              separated out by <i>type</i>.<br><br>              If <i>type</i> is <b>PERF_TYPE_HARDWARE</b>, we are measuring one of the<br>              generalized hardware CPU events.  Not all of these are<br>              available on all platforms.  Set <i>config</i> to one of the<br>              following:<br><br>                   <b>PERF_COUNT_HW_CPU_CYCLES</b><br>                          Total cycles.  Be wary of what happens during CPU<br>                          frequency scaling.<br><br>                   <b>PERF_COUNT_HW_INSTRUCTIONS</b><br>                          Retired instructions.  Be careful, these can be<br>                          affected by various issues, most notably hardware<br>                          interrupt counts.<br><br>                   <b>PERF_COUNT_HW_CACHE_REFERENCES</b><br>                          Cache accesses.  Usually this indicates Last Level<br>                          Cache accesses but this may vary depending on your<br>                          CPU.  This may include prefetches and coherency<br>                          messages; again this depends on the design of your<br>                          CPU.<br><br>                   <b>PERF_COUNT_HW_CACHE_MISSES</b><br>                          Cache misses.  Usually this indicates Last Level<br>                          Cache misses; this is intended to be used in<br>                          conjunction with the<br>                          <b>PERF_COUNT_HW_CACHE_REFERENCES </b>event to calculate<br>                          cache miss rates.<br><br>                   <b>PERF_COUNT_HW_BRANCH_INSTRUCTIONS</b><br>                          Retired branch instructions.  Prior to Linux<br>                          2.6.35, this used the wrong event on AMD<br>                          processors.<br><br>                   <b>PERF_COUNT_HW_BRANCH_MISSES</b><br>                          Mispredicted branch instructions.<br><br>                   <b>PERF_COUNT_HW_BUS_CYCLES</b><br>                          Bus cycles, which can be different from total<br>                          cycles.<br><br>                   <b>PERF_COUNT_HW_STALLED_CYCLES_FRONTEND </b>(since Linux 3.0)<br>                          Stalled cycles during issue.<br><br>                   <b>PERF_COUNT_HW_STALLED_CYCLES_BACKEND </b>(since Linux 3.0)<br>                          Stalled cycles during retirement.<br><br>                   <b>PERF_COUNT_HW_REF_CPU_CYCLES </b>(since Linux 3.3)<br>                          Total cycles; not affected by CPU frequency<br>                          scaling.<br><br>              If <i>type</i> is <b>PERF_TYPE_SOFTWARE</b>, we are measuring software<br>              events provided by the kernel.  Set <i>config</i> to one of the<br>              following:<br><br>                   <b>PERF_COUNT_SW_CPU_CLOCK</b><br>                          This reports the CPU clock, a high-resolution per-<br>                          CPU timer.<br><br>                   <b>PERF_COUNT_SW_TASK_CLOCK</b><br>                          This reports a clock count specific to the task<br>                          that is running.<br><br>                   <b>PERF_COUNT_SW_PAGE_FAULTS</b><br>                          This reports the number of page faults.<br><br>                   <b>PERF_COUNT_SW_CONTEXT_SWITCHES</b><br>                          This counts context switches.  Until Linux 2.6.34,<br>                          these were all reported as user-space events,<br>                          after that they are reported as happening in the<br>                          kernel.<br><br>                   <b>PERF_COUNT_SW_CPU_MIGRATIONS</b><br>                          This reports the number of times the process has<br>                          migrated to a new CPU.<br><br>                   <b>PERF_COUNT_SW_PAGE_FAULTS_MIN</b><br>                          This counts the number of minor page faults.<br>                          These did not require disk I/O to handle.<br><br>                   <b>PERF_COUNT_SW_PAGE_FAULTS_MAJ</b><br>                          This counts the number of major page faults.<br>                          These required disk I/O to handle.<br><br>                   <b>PERF_COUNT_SW_ALIGNMENT_FAULTS </b>(since Linux 2.6.33)<br>                          This counts the number of alignment faults.  These<br>                          happen when unaligned memory accesses happen; the<br>                          kernel can handle these but it reduces<br>                          performance.  This happens only on some<br>                          architectures (never on x86).<br><br>                   <b>PERF_COUNT_SW_EMULATION_FAULTS </b>(since Linux 2.6.33)<br>                          This counts the number of emulation faults.  The<br>                          kernel sometimes traps on unimplemented<br>                          instructions and emulates them for user space.<br>                          This can negatively impact performance.<br><br>                   <b>PERF_COUNT_SW_DUMMY </b>(since Linux 3.12)<br>                          This is a placeholder event that counts nothing.<br>                          Informational sample record types such as mmap or<br>                          comm must be associated with an active event.<br>                          This dummy event allows gathering such records<br>                          without requiring a counting event.<br><br>              If <i>type</i> is <b>PERF_TYPE_TRACEPOINT</b>, then we are measuring kernel<br>              tracepoints.  The value to use in <i>config</i> can be obtained from<br>              under debugfs <i>tracing/events/*/*/id</i> if ftrace is enabled in<br>              the kernel.<br><br>              If <i>type</i> is <b>PERF_TYPE_HW_CACHE</b>, then we are measuring a<br>              hardware CPU cache event.  To calculate the appropriate <i>config</i><br>              value use the following equation:<br><br>                      (perf_hw_cache_id) | (perf_hw_cache_op_id &lt;&lt; 8) |<br>                      (perf_hw_cache_op_result_id &lt;&lt; 16)<br><br>                  where <i>perf_hw_cache_id</i> is one of:<br><br>                      <b>PERF_COUNT_HW_CACHE_L1D</b><br>                             for measuring Level 1 Data Cache<br><br>                      <b>PERF_COUNT_HW_CACHE_L1I</b><br>                             for measuring Level 1 Instruction Cache<br><br>                      <b>PERF_COUNT_HW_CACHE_LL</b><br>                             for measuring Last-Level Cache<br><br>                      <b>PERF_COUNT_HW_CACHE_DTLB</b><br>                             for measuring the Data TLB<br><br>                      <b>PERF_COUNT_HW_CACHE_ITLB</b><br>                             for measuring the Instruction TLB<br><br>                      <b>PERF_COUNT_HW_CACHE_BPU</b><br>                             for measuring the branch prediction unit<br><br>                      <b>PERF_COUNT_HW_CACHE_NODE </b>(since Linux 3.1)<br>                             for measuring local memory accesses<br><br>                  and <i>perf_hw_cache_op_id</i> is one of<br><br>                      <b>PERF_COUNT_HW_CACHE_OP_READ</b><br>                             for read accesses<br><br>                      <b>PERF_COUNT_HW_CACHE_OP_WRITE</b><br>                             for write accesses<br><br>                      <b>PERF_COUNT_HW_CACHE_OP_PREFETCH</b><br>                             for prefetch accesses<br><br>                  and <i>perf_hw_cache_op_result_id</i> is one of<br><br>                      <b>PERF_COUNT_HW_CACHE_RESULT_ACCESS</b><br>                             to measure accesses<br><br>                      <b>PERF_COUNT_HW_CACHE_RESULT_MISS</b><br>                             to measure misses<br><br>              If <i>type</i> is <b>PERF_TYPE_RAW</b>, then a custom \"raw\" <i>config</i> value is<br>              needed.  Most CPUs support events that are not covered by the<br>              \"generalized\" events.  These are implementation defined; see<br>              your CPU manual (for example the Intel Volume 3B documentation<br>              or the AMD BIOS and Kernel Developer Guide).  The libpfm4<br>              library can be used to translate from the name in the<br>              architectural manuals to the raw hex value <b>perf_event_open</b>()<br>              expects in this field.<br><br>              If <i>type</i> is <b>PERF_TYPE_BREAKPOINT</b>, then leave <i>config</i> set to<br>              zero.  Its parameters are set in other places.<br><br>       <i>sample_period</i>, <i>sample_freq</i><br>              A \"sampling\" event is one that generates an overflow<br>              notification every N events, where N is given by<br>              <i>sample_period</i>.  A sampling event has <i>sample_period</i> &gt; 0.  When<br>              an overflow occurs, requested data is recorded in the mmap<br>              buffer.  The <i>sample_type</i> field controls what data is recorded<br>              on each overflow.<br><br>              <i>sample_freq</i> can be used if you wish to use frequency rather<br>              than period.  In this case, you set the <i>freq</i> flag.  The kernel<br>              will adjust the sampling period to try and achieve the desired<br>              rate.  The rate of adjustment is a timer tick.<br><br>       <i>sample_type</i><br>              The various bits in this field specify which values to include<br>              in the sample.  They will be recorded in a ring-buffer, which<br>              is available to user space using mmap(2).  The order in which<br>              the values are saved in the sample are documented in the MMAP<br>              Layout subsection below; it is not the <i>enum</i><br>              <i>perf_event_sample_format</i> order.<br><br>              <b>PERF_SAMPLE_IP</b><br>                     Records instruction pointer.<br><br>              <b>PERF_SAMPLE_TID</b><br>                     Records the process and thread IDs.<br><br>              <b>PERF_SAMPLE_TIME</b><br>                     Records a timestamp.<br><br>              <b>PERF_SAMPLE_ADDR</b><br>                     Records an address, if applicable.<br><br>              <b>PERF_SAMPLE_READ</b><br>                     Record counter values for all events in a group, not<br>                     just the group leader.<br><br>              <b>PERF_SAMPLE_CALLCHAIN</b><br>                     Records the callchain (stack backtrace).<br><br>              <b>PERF_SAMPLE_ID</b><br>                     Records a unique ID for the opened event's group<br>                     leader.<br><br>              <b>PERF_SAMPLE_CPU</b><br>                     Records CPU number.<br><br>              <b>PERF_SAMPLE_PERIOD</b><br>                     Records the current sampling period.<br><br>              <b>PERF_SAMPLE_STREAM_ID</b><br>                     Records a unique ID for the opened event.  Unlike<br>                     <b>PERF_SAMPLE_ID </b>the actual ID is returned, not the group<br>                     leader.  This ID is the same as the one returned by<br>                     <b>PERF_FORMAT_ID</b>.<br><br>              <b>PERF_SAMPLE_RAW</b><br>                     Records additional data, if applicable.  Usually<br>                     returned by tracepoint events.<br><br>              <b>PERF_SAMPLE_BRANCH_STACK </b>(since Linux 3.4)<br>                     This provides a record of recent branches, as provided<br>                     by CPU branch sampling hardware (such as Intel Last<br>                     Branch Record).  Not all hardware supports this<br>                     feature.<br><br>                     See the <i>branch_sample_type</i> field for how to filter<br>                     which branches are reported.<br><br>              <b>PERF_SAMPLE_REGS_USER </b>(since Linux 3.7)<br>                     Records the current user-level CPU register state (the<br>                     values in the process before the kernel was called).<br><br>              <b>PERF_SAMPLE_STACK_USER </b>(since Linux 3.7)<br>                     Records the user level stack, allowing stack unwinding.<br><br>              <b>PERF_SAMPLE_WEIGHT </b>(since Linux 3.10)<br>                     Records a hardware provided weight value that expresses<br>                     how costly the sampled event was.  This allows the<br>                     hardware to highlight expensive events in a profile.<br><br>              <b>PERF_SAMPLE_DATA_SRC </b>(since Linux 3.10)<br>                     Records the data source: where in the memory hierarchy<br>                     the data associated with the sampled instruction came<br>                     from.  This is available only if the underlying<br>                     hardware supports this feature.<br><br>              <b>PERF_SAMPLE_IDENTIFIER </b>(since Linux 3.12)<br>                     Places the <b>SAMPLE_ID </b>value in a fixed position in the<br>                     record, either at the beginning (for sample events) or<br>                     at the end (if a non-sample event).<br><br>                     This was necessary because a sample stream may have<br>                     records from various different event sources with<br>                     different <i>sample_type</i> settings.  Parsing the event<br>                     stream properly was not possible because the format of<br>                     the record was needed to find <b>SAMPLE_ID</b>, but the format<br>                     could not be found without knowing what event the<br>                     sample belonged to (causing a circular dependency).<br><br>                     The <b>PERF_SAMPLE_IDENTIFIER </b>setting makes the event<br>                     stream always parsable by putting <b>SAMPLE_ID </b>in a fixed<br>                     location, even though it means having duplicate<br>                     <b>SAMPLE_ID </b>values in records.<br><br>              <b>PERF_SAMPLE_TRANSACTION </b>(since Linux 3.13)<br>                     Records reasons for transactional memory abort events<br>                     (for example, from Intel TSX transactional memory<br>                     support).<br><br>                     The <i>precise_ip</i> setting must be greater than 0 and a<br>                     transactional memory abort event must be measured or no<br>                     values will be recorded.  Also note that some<br>                     perf_event measurements, such as sampled cycle<br>                     counting, may cause extraneous aborts (by causing an<br>                     interrupt during a transaction).<br><br>              <b>PERF_SAMPLE_REGS_INTR </b>(since Linux 3.19)<br>                     Records a subset of the current CPU register state as<br>                     specified by <i>sample_regs_intr</i>.  Unlike<br>                     <b>PERF_SAMPLE_REGS_USER </b>the register values will return<br>                     kernel register state if the overflow happened while<br>                     kernel code is running.  If the CPU supports hardware<br>                     sampling of register state (i.e. PEBS on Intel x86) and<br>                     <i>precise_ip</i> is set higher than zero then the register<br>                     values returned are those captured by hardware at the<br>                     time of the sampled instruction's retirement.<br><br>       <i>read_format</i><br>              This field specifies the format of the data returned by<br>              read(2) on a <b>perf_event_open</b>() file descriptor.<br><br>              <b>PERF_FORMAT_TOTAL_TIME_ENABLED</b><br>                     Adds the 64-bit <i>time_enabled</i> field.  This can be used<br>                     to calculate estimated totals if the PMU is<br>                     overcommitted and multiplexing is happening.<br><br>              <b>PERF_FORMAT_TOTAL_TIME_RUNNING</b><br>                     Adds the 64-bit <i>time_running</i> field.  This can be used<br>                     to calculate estimated totals if the PMU is<br>                     overcommitted and multiplexing is happening.<br><br>              <b>PERF_FORMAT_ID</b><br>                     Adds a 64-bit unique value that corresponds to the<br>                     event group.<br><br>              <b>PERF_FORMAT_GROUP</b><br>                     Allows all counter values in an event group to be read<br>                     with one read.<br><br>       <i>disabled</i><br>              The <i>disabled</i> bit specifies whether the counter starts out<br>              disabled or enabled.  If disabled, the event can later be<br>              enabled by ioctl(2), prctl(2), or <i>enable_on_exec</i>.<br><br>              When creating an event group, typically the group leader is<br>              initialized with <i>disabled</i> set to 1 and any child events are<br>              initialized with <i>disabled</i> set to 0.  Despite <i>disabled</i> being 0,<br>              the child events will not start until the group leader is<br>              enabled.<br><br>       <i>inherit</i><br>              The <i>inherit</i> bit specifies that this counter should count<br>              events of child tasks as well as the task specified.  This<br>              applies only to new children, not to any existing children at<br>              the time the counter is created (nor to any new children of<br>              existing children).<br><br>              Inherit does not work for some combinations of <i>read_format</i>s,<br>              such as <b>PERF_FORMAT_GROUP</b>.<br><br>       <i>pinned</i> The <i>pinned</i> bit specifies that the counter should always be on<br>              the CPU if at all possible.  It applies only to hardware<br>              counters and only to group leaders.  If a pinned counter<br>              cannot be put onto the CPU (e.g., because there are not enough<br>              hardware counters or because of a conflict with some other<br>              event), then the counter goes into an 'error' state, where<br>              reads return end-of-file (i.e., read(2) returns 0) until the<br>              counter is subsequently enabled or disabled.<br><br>       <i>exclusive</i><br>              The <i>exclusive</i> bit specifies that when this counter's group is<br>              on the CPU, it should be the only group using the CPU's<br>              counters.  In the future this may allow monitoring programs to<br>              support PMU features that need to run alone so that they do<br>              not disrupt other hardware counters.<br><br>              Note that many unexpected situations may prevent events with<br>              the <i>exclusive</i> bit set from ever running.  This includes any<br>              users running a system-wide measurement as well as any kernel<br>              use of the performance counters (including the commonly<br>              enabled NMI Watchdog Timer interface).<br><br>       <i>exclude_user</i><br>              If this bit is set, the count excludes events that happen in<br>              user space.<br><br>       <i>exclude_kernel</i><br>              If this bit is set, the count excludes events that happen in<br>              kernel-space.<br><br>       <i>exclude_hv</i><br>              If this bit is set, the count excludes events that happen in<br>              the hypervisor.  This is mainly for PMUs that have built-in<br>              support for handling this (such as POWER).  Extra support is<br>              needed for handling hypervisor measurements on most machines.<br><br>       <i>exclude_idle</i><br>              If set, don't count when the CPU is idle.<br><br>       <i>mmap</i>   The <i>mmap</i> bit enables generation of <b>PERF_RECORD_MMAP </b>samples<br>              for every mmap(2) call that has <b>PROT_EXEC </b>set.  This allows<br>              tools to notice new executable code being mapped into a<br>              program (dynamic shared libraries for example) so that<br>              addresses can be mapped back to the original code.<br><br>       <i>comm</i>   The <i>comm</i> bit enables tracking of process command name as<br>              modified by the <b>exec</b>(2) and <b>prctl</b>(PR_SET_NAME) system calls as<br>              well as writing to <i>/proc/self/comm</i>.  If the <i>comm_exec</i> flag is<br>              also successfully set (possible since Linux 3.16), then the<br>              misc flag <b>PERF_RECORD_MISC_COMM_EXEC </b>can be used to<br>              differentiate the <b>exec</b>(2) case from the others.<br><br>       <i>freq</i>   If this bit is set, then <i>sample_frequency</i> not <i>sample_period</i> is<br>              used when setting up the sampling interval.<br><br>       <i>inherit_stat</i><br>              This bit enables saving of event counts on context switch for<br>              inherited tasks.  This is meaningful only if the <i>inherit</i> field<br>              is set.<br><br>       <i>enable_on_exec</i><br>              If this bit is set, a counter is automatically enabled after a<br>              call to <b>exec</b>(2).<br><br>       <i>task</i>   If this bit is set, then fork/exit notifications are included<br>              in the ring buffer.<br><br>       <i>watermark</i><br>              If set, have an overflow notification happen when we cross the<br>              <i>wakeup_watermark</i> boundary.  Otherwise, overflow notifications<br>              happen after <i>wakeup_events</i> samples.<br><br>       <i>precise_ip</i> (since Linux 2.6.35)<br>              This controls the amount of skid.  Skid is how many<br>              instructions execute between an event of interest happening<br>              and the kernel being able to stop and record the event.<br>              Smaller skid is better and allows more accurate reporting of<br>              which events correspond to which instructions, but hardware is<br>              often limited with how small this can be.<br><br>              The values of this are the following:<br><br>              0 -    <b>SAMPLE_IP </b>can have arbitrary skid.<br><br>              1 -    <b>SAMPLE_IP </b>must have constant skid.<br><br>              2 -    <b>SAMPLE_IP </b>requested to have 0 skid.<br><br>              3 -    <b>SAMPLE_IP </b>must have 0 skid.  See also<br>                     <b>PERF_RECORD_MISC_EXACT_IP</b>.<br><br>       <i>mmap_data</i> (since Linux 2.6.36)<br>              The counterpart of the <i>mmap</i> field.  This enables generation of<br>              <b>PERF_RECORD_MMAP </b>samples for mmap(2) calls that do not have<br>              <b>PROT_EXEC </b>set (for example data and SysV shared memory).<br><br>       <i>sample_id_all</i> (since Linux 2.6.38)<br>              If set, then TID, TIME, ID, STREAM_ID, and CPU can<br>              additionally be included in non-<b>PERF_RECORD_SAMPLE</b>s if the<br>              corresponding <i>sample_type</i> is selected.<br><br>              If <b>PERF_SAMPLE_IDENTIFIER </b>is specified, then an additional ID<br>              value is included as the last value to ease parsing the record<br>              stream.  This may lead to the <i>id</i> value appearing twice.<br><br>              The layout is described by this pseudo-structure:<br>                  struct sample_id {<br>                      { u32 pid, tid; } /* if PERF_SAMPLE_TID set        */<br>                      { u64 time;     } /* if PERF_SAMPLE_TIME set       */<br>                      { u64 id;       } /* if PERF_SAMPLE_ID set         */<br>                      { u64 stream_id;} /* if PERF_SAMPLE_STREAM_ID set  */<br>                      { u32 cpu, res; } /* if PERF_SAMPLE_CPU set        */<br>                      { u64 id;       } /* if PERF_SAMPLE_IDENTIFIER set */<br>                  };<br><br>       <i>exclude_host</i> (since Linux 3.2)<br>              When conducting measurements that include processes running VM<br>              instances (i.e. have executed a <i>KVM_RUN</i> ioctl(2) ) only<br>              measure events happening inside a guest instance.  This is<br>              only meaningful outside the guests; this setting does not<br>              change counts gathered inside of a guest.  Currently this<br>              functionality is x86 only.<br><br>       <i>exclude_guest</i> (since Linux 3.2)<br>              When conducting measurements that include processes running VM<br>              instances (i.e. have executed a <i>KVM_RUN</i> ioctl(2) ) do not<br>              measure events happening inside guest instances.  This is only<br>              meaningful outside the guests; this setting does not change<br>              counts gathered inside of a guest.  Currently this<br>              functionality is x86 only.<br><br>       <i>exclude_callchain_kernel</i> (since Linux 3.7)<br>              Do not include kernel callchains.<br><br>       <i>exclude_callchain_user</i> (since Linux 3.7)<br>              Do not include user callchains.<br><br>       <i>mmap2</i> (since Linux 3.16)<br>              Generate an extended executable mmap record that contains<br>              enough additional information to uniquely identify shared<br>              mappings.  The <i>mmap</i> flag must also be set for this to work.<br><br>       <i>comm_exec</i> (since Linux 3.16)<br>              This is purely a feature-detection flag, it does not change<br>              kernel behavior.  If this flag can successfully be set, then,<br>              when <i>comm</i> is enabled, the <b>PERF_RECORD_MISC_COMM_EXEC </b>flag will<br>              be set in the <i>misc</i> field of a comm record header if the rename<br>              event being reported was caused by a call to <b>exec</b>(2).  This<br>              allows tools to distinguish between the various types of<br>              process renaming.<br><br>       <i>wakeup_events</i>, <i>wakeup_watermark</i><br>              This union sets how many samples (<i>wakeup_events</i>) or bytes<br>              (<i>wakeup_watermark</i>) happen before an overflow notification<br>              happens.  Which one is used is selected by the <i>watermark</i> bit<br>              flag.<br><br>              <i>wakeup_events</i> counts only <b>PERF_RECORD_SAMPLE </b>record types.  To<br>              receive overflow notification for all <b>PERF_RECORD </b>types choose<br>              watermark and set <i>wakeup_watermark</i> to 1.<br><br>              Prior to Linux 3.0 setting <i>wakeup_events</i> to 0 resulted in no<br>              overflow notifications; more recent kernels treat 0 the same<br>              as 1.<br><br>       <i>bp_type</i> (since Linux 2.6.33)<br>              This chooses the breakpoint type.  It is one of:<br><br>              <b>HW_BREAKPOINT_EMPTY</b><br>                     No breakpoint.<br><br>              <b>HW_BREAKPOINT_R</b><br>                     Count when we read the memory location.<br><br>              <b>HW_BREAKPOINT_W</b><br>                     Count when we write the memory location.<br><br>              <b>HW_BREAKPOINT_RW</b><br>                     Count when we read or write the memory location.<br><br>              <b>HW_BREAKPOINT_X</b><br>                     Count when we execute code at the memory location.<br><br>              The values can be combined via a bitwise or, but the<br>              combination of <b>HW_BREAKPOINT_R </b>or <b>HW_BREAKPOINT_W </b>with<br>              <b>HW_BREAKPOINT_X </b>is not allowed.<br><br>       <i>bp_addr</i> (since Linux 2.6.33)<br>              <i>bp_addr</i> address of the breakpoint.  For execution breakpoints<br>              this is the memory address of the instruction of interest; for<br>              read and write breakpoints it is the memory address of the<br>              memory location of interest.<br><br>       <i>config1</i> (since Linux 2.6.39)<br>              <i>config1</i> is used for setting events that need an extra register<br>              or otherwise do not fit in the regular config field.  Raw<br>              OFFCORE_EVENTS on Nehalem/Westmere/SandyBridge use this field<br>              on 3.3 and later kernels.<br><br>       <i>bp_len</i> (since Linux 2.6.33)<br>              <i>bp_len</i> is the length of the breakpoint being measured if <i>type</i><br>              is <b>PERF_TYPE_BREAKPOINT</b>.  Options are <b>HW_BREAKPOINT_LEN_1</b>,<br>              <b>HW_BREAKPOINT_LEN_2</b>, <b>HW_BREAKPOINT_LEN_4</b>, <b>HW_BREAKPOINT_LEN_8</b>.<br>              For an execution breakpoint, set this to <i>sizeof(long)</i>.<br><br>       <i>config2</i> (since Linux 2.6.39)<br><br>              <i>config2</i> is a further extension of the <i>config1</i> field.<br><br>       <i>branch_sample_type</i> (since Linux 3.4)<br>              If <b>PERF_SAMPLE_BRANCH_STACK </b>is enabled, then this specifies<br>              what branches to include in the branch record.<br><br>              The first part of the value is the privilege level, which is a<br>              combination of one of the following values.  If the user does<br>              not set privilege level explicitly, the kernel will use the<br>              event's privilege level.  Event and branch privilege levels do<br>              not have to match.<br><br>              <b>PERF_SAMPLE_BRANCH_USER</b><br>                     Branch target is in user space.<br><br>              <b>PERF_SAMPLE_BRANCH_KERNEL</b><br>                     Branch target is in kernel space.<br><br>              <b>PERF_SAMPLE_BRANCH_HV</b><br>                     Branch target is in hypervisor.<br><br>              <b>PERF_SAMPLE_BRANCH_PLM_ALL</b><br>                     A convenience value that is the three preceding values<br>                     ORed together.<br><br>              In addition to the privilege value, at least one or more of<br>              the following bits must be set.<br><br>              <b>PERF_SAMPLE_BRANCH_ANY</b><br>                     Any branch type.<br><br>              <b>PERF_SAMPLE_BRANCH_ANY_CALL</b><br>                     Any call branch.<br><br>              <b>PERF_SAMPLE_BRANCH_ANY_RETURN</b><br>                     Any return branch.<br><br>              <b>PERF_SAMPLE_BRANCH_IND_CALL</b><br>                     Indirect calls.<br><br>              <b>PERF_SAMPLE_BRANCH_COND </b>(since Linux 3.16)<br>                     Conditional branches.<br><br>              <b>PERF_SAMPLE_BRANCH_ABORT_TX </b>(since Linux 3.11)<br>                     Transactional memory aborts.<br><br>              <b>PERF_SAMPLE_BRANCH_IN_TX </b>(since Linux 3.11)<br>                     Branch in transactional memory transaction.<br><br>              <b>PERF_SAMPLE_BRANCH_NO_TX </b>(since Linux 3.11)<br>                     Branch not in transactional memory transaction.<br><br>       <i>sample_regs_user</i> (since Linux 3.7)<br>              This bit mask defines the set of user CPU registers to dump on<br>              samples.  The layout of the register mask is architecture-<br>              specific and described in the kernel header<br>              <i>arch/ARCH/include/uapi/asm/perf_regs.h</i>.<br><br>       <i>sample_stack_user</i> (since Linux 3.7)<br>              This defines the size of the user stack to dump if<br>              <b>PERF_SAMPLE_STACK_USER </b>is specified.<br><br>   <b>Reading results</b><br>       Once a <b>perf_event_open</b>() file descriptor has been opened, the values<br>       of the events can be read from the file descriptor.  The values that<br>       are there are specified by the <i>read_format</i> field in the <i>attr</i><br>       structure at open time.<br><br>       If you attempt to read into a buffer that is not big enough to hold<br>       the data <b>ENOSPC </b>is returned<br><br>       Here is the layout of the data returned by a read:<br><br>       * If <b>PERF_FORMAT_GROUP </b>was specified to allow reading all events in a<br>         group at once:<br><br>             struct read_format {<br>                 u64 nr;            /* The number of events */<br>                 u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */<br>                 u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */<br>                 struct {<br>                     u64 value;     /* The value of the event */<br>                     u64 id;        /* if PERF_FORMAT_ID */<br>                 } values[nr];<br>             };<br><br>       * If <b>PERF_FORMAT_GROUP </b>was <i>not</i> specified:<br><br>             struct read_format {<br>                 u64 value;         /* The value of the event */<br>                 u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */<br>                 u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */<br>                 u64 id;            /* if PERF_FORMAT_ID */<br>             };<br><br>       The values read are as follows:<br><br>       <i>nr</i>     The number of events in this file descriptor.  Only available<br>              if <b>PERF_FORMAT_GROUP </b>was specified.<br><br>       <i>time_enabled</i>, <i>time_running</i><br>              Total time the event was enabled and running.  Normally these<br>              are the same.  If more events are started, then available<br>              counter slots on the PMU, then multiplexing happens and events<br>              run only part of the time.  In that case, the <i>time_enabled</i> and<br>              <i>time running</i> values can be used to scale an estimated value<br>              for the count.<br><br>       <i>value</i>  An unsigned 64-bit value containing the counter result.<br><br>       <i>id</i>     A globally unique value for this particular event, only<br>              present if <b>PERF_FORMAT_ID </b>was specified in <i>read_format</i>.<br><br>   <b>MMAP layout</b><br>       When using <b>perf_event_open</b>() in sampled mode, asynchronous events<br>       (like counter overflow or <b>PROT_EXEC </b>mmap tracking) are logged into a<br>       ring-buffer.  This ring-buffer is created and accessed through<br>       mmap(2).<br><br>       The mmap size should be 1+2^n pages, where the first page is a<br>       metadata page (<i>struct perf_event_mmap_page</i>) that contains various<br>       bits of information such as where the ring-buffer head is.<br><br>       Before kernel 2.6.39, there is a bug that means you must allocate a<br>       mmap ring buffer when sampling even if you do not plan to access it.<br><br>       The structure of the first metadata mmap page is as follows:<br><br>           struct perf_event_mmap_page {<br>               __u32 version;        /* version number of this structure */<br>               __u32 compat_version; /* lowest version this is compat with */<br>               __u32 lock;           /* seqlock for synchronization */<br>               __u32 index;          /* hardware counter identifier */<br>               __s64 offset;         /* add to hardware counter value */<br>               __u64 time_enabled;   /* time event active */<br>               __u64 time_running;   /* time event on CPU */<br>               union {<br>                   __u64   capabilities;<br>                   struct {<br>                       __u64 cap_usr_time / cap_usr_rdpmc / cap_bit0 : 1,<br>                             cap_bit0_is_deprecated : 1,<br>                             cap_user_rdpmc         : 1,<br>                             cap_user_time          : 1,<br>                             cap_user_time_zero     : 1,<br>                   };<br>               };<br>               __u16 pmc_width;<br>               __u16 time_shift;<br>               __u32 time_mult;<br>               __u64 time_offset;<br>               __u64 __reserved[120];   /* Pad to 1k */<br>               __u64 data_head;         /* head in the data section */<br>               __u64 data_tail;         /* user-space written tail */<br>           }<br><br>       The following list describes the fields in the <i>perf_event_mmap_page</i><br>       structure in more detail:<br><br>       <i>version</i><br>              Version number of this structure.<br><br>       <i>compat_version</i><br>              The lowest version this is compatible with.<br><br>       <i>lock</i>   A seqlock for synchronization.<br><br>       <i>index</i>  A unique hardware counter identifier.<br><br>       <i>offset</i> When using rdpmc for reads this offset value must be added to<br>              the one returned by rdpmc to get the current total event<br>              count.<br><br>       <i>time_enabled</i><br>              Time the event was active.<br><br>       <i>time_running</i><br>              Time the event was running.<br><br>       <i>cap_usr_time</i> / <i>cap_usr_rdpmc</i> / <i>cap_bit0</i> (since Linux 3.4)<br>              There was a bug in the definition of <i>cap_usr_time</i> and<br>              <i>cap_usr_rdpmc</i> from Linux 3.4 until Linux 3.11.  Both bits were<br>              defined to point to the same location, so it was impossible to<br>              know if <i>cap_usr_time</i> or <i>cap_usr_rdpmc</i> were actually set.<br><br>              Starting with Linux 3.12, these are renamed to <i>cap_bit0</i> and<br>              you should use the <i>cap_user_time</i> and <i>cap_user_rdpmc</i> fields<br>              instead.<br><br>       <i>cap_bit0_is_deprecated</i> (since Linux 3.12)<br>              If set, this bit indicates that the kernel supports the<br>              properly separated <i>cap_user_time</i> and <i>cap_user_rdpmc</i> bits.<br><br>              If not-set, it indicates an older kernel where <i>cap_usr_time</i><br>              and <i>cap_usr_rdpmc</i> map to the same bit and thus both features<br>              should be used with caution.<br><br>       <i>cap_user_rdpmc</i> (since Linux 3.12)<br>              If the hardware supports user-space read of performance<br>              counters without syscall (this is the \"rdpmc\" instruction on<br>              x86), then the following code can be used to do a read:<br><br>                  u32 seq, time_mult, time_shift, idx, width;<br>                  u64 count, enabled, running;<br>                  u64 cyc, time_offset;<br><br>                  do {<br>                      seq = pc-&gt;lock;<br>                      barrier();<br>                      enabled = pc-&gt;time_enabled;<br>                      running = pc-&gt;time_running;<br><br>                      if (pc-&gt;cap_usr_time &amp;&amp; enabled != running) {<br>                          cyc = rdtsc();<br>                          time_offset = pc-&gt;time_offset;<br>                          time_mult   = pc-&gt;time_mult;<br>                          time_shift  = pc-&gt;time_shift;<br>                      }<br><br>                      idx = pc-&gt;index;<br>                      count = pc-&gt;offset;<br><br>                      if (pc-&gt;cap_usr_rdpmc &amp;&amp; idx) {<br>                          width = pc-&gt;pmc_width;<br>                          count += rdpmc(idx - 1);<br>                      }<br><br>                      barrier();<br>                  } while (pc-&gt;lock != seq);<br><br>       <i>cap_user_time</i> (since Linux 3.12)<br>              This bit indicates the hardware has a constant, nonstop<br>              timestamp counter (TSC on x86).<br><br>       <i>cap_user_time_zero</i> (since Linux 3.12)<br>              Indicates the presence of <i>time_zero</i> which allows mapping<br>              timestamp values to the hardware clock.<br><br>       <i>pmc_width</i><br>              If <i>cap_usr_rdpmc</i>, this field provides the bit-width of the<br>              value read using the rdpmc or equivalent instruction.  This<br>              can be used to sign extend the result like:<br><br>                  pmc &lt;&lt;= 64 - pmc_width;<br>                  pmc &gt;&gt;= 64 - pmc_width; // signed shift right<br>                  count += pmc;<br><br>       <i>time_shift</i>, <i>time_mult</i>, <i>time_offset</i><br><br>              If <i>cap_usr_time</i>, these fields can be used to compute the time<br>              delta since time_enabled (in nanoseconds) using rdtsc or<br>              similar.<br><br>                  u64 quot, rem;<br>                  u64 delta;<br>                  quot = (cyc &gt;&gt; time_shift);<br>                  rem = cyc &amp; ((1 &lt;&lt; time_shift) - 1);<br>                  delta = time_offset + quot * time_mult +<br>                          ((rem * time_mult) &gt;&gt; time_shift);<br><br>              Where <i>time_offset</i>, <i>time_mult</i>, <i>time_shift</i>, and <i>cyc</i> are read in<br>              the seqcount loop described above.  This delta can then be<br>              added to enabled and possible running (if idx), improving the<br>              scaling:<br><br>                  enabled += delta;<br>                  if (idx)<br>                      running += delta;<br>                  quot = count / running;<br>                  rem  = count % running;<br>                  count = quot * enabled + (rem * enabled) / running;<br><br>       <i>time_zero</i> (since Linux 3.12)<br><br>              If <i>cap_usr_time_zero</i> is set, then the hardware clock (the TSC<br>              timestamp counter on x86) can be calculated from the<br>              <i>time_zero</i>, <i>time_mult</i>, and <i>time_shift</i> values:<br><br>                  time = timestamp - time_zero;<br>                  quot = time / time_mult;<br>                  rem  = time % time_mult;<br>                  cyc = (quot &lt;&lt; time_shift) + (rem &lt;&lt; time_shift) / time_mult;<br><br>              And vice versa:<br><br>                  quot = cyc &gt;&gt; time_shift;<br>                  rem  = cyc &amp; ((1 &lt;&lt; time_shift) - 1);<br>                  timestamp = time_zero + quot * time_mult +<br>                      ((rem * time_mult) &gt;&gt; time_shift);<br><br>       <i>data_head</i><br>              This points to the head of the data section.  The value<br>              continuously increases, it does not wrap.  The value needs to<br>              be manually wrapped by the size of the mmap buffer before<br>              accessing the samples.<br><br>              On SMP-capable platforms, after reading the <i>data_head</i> value,<br>              user space should issue an rmb().<br><br>       <i>data_tail</i><br>              When the mapping is <b>PROT_WRITE</b>, the <i>data_tail</i> value should be<br>              written by user space to reflect the last read data.  In this<br>              case, the kernel will not overwrite unread data.<br><br>       The following 2^n ring-buffer pages have the layout described below.<br><br>       If <i>perf_event_attr.sample_id_all</i> is set, then all event types will<br>       have the sample_type selected fields related to where/when (identity)<br>       an event took place (TID, TIME, ID, CPU, STREAM_ID) described in<br>       <b>PERF_RECORD_SAMPLE </b>below, it will be stashed just after the<br>       <i>perf_event_header</i> and the fields already present for the existing<br>       fields, that is, at the end of the payload.  That way a newer<br>       perf.data file will be supported by older perf tools, with these new<br>       optional fields being ignored.<br><br>       The mmap values start with a header:<br><br>           struct perf_event_header {<br>               __u32   type;<br>               __u16   misc;<br>               __u16   size;<br>           };<br><br>       Below, we describe the <i>perf_event_header</i> fields in more detail.  For<br>       ease of reading, the fields with shorter descriptions are presented<br>       first.<br><br>       <i>size</i>   This indicates the size of the record.<br><br>       <i>misc</i>   The <i>misc</i> field contains additional information about the<br>              sample.<br><br>              The CPU mode can be determined from this value by masking with<br>              <b>PERF_RECORD_MISC_CPUMODE_MASK </b>and looking for one of the<br>              following (note these are not bit masks, only one can be set<br>              at a time):<br><br>              <b>PERF_RECORD_MISC_CPUMODE_UNKNOWN</b><br>                     Unknown CPU mode.<br><br>              <b>PERF_RECORD_MISC_KERNEL</b><br>                     Sample happened in the kernel.<br><br>              <b>PERF_RECORD_MISC_USER</b><br>                     Sample happened in user code.<br><br>              <b>PERF_RECORD_MISC_HYPERVISOR</b><br>                     Sample happened in the hypervisor.<br><br>              <b>PERF_RECORD_MISC_GUEST_KERNEL </b>(since Linux 2.6.35)<br>                     Sample happened in the guest kernel.<br><br>              <b>PERF_RECORD_MISC_GUEST_USER  (since Linux 2.6.35)</b><br>                     Sample happened in guest user code.<br><br>              In addition, one of the following bits can be set:<br><br>              <b>PERF_RECORD_MISC_MMAP_DATA </b>(since Linux 3.10)<br>                     This is set when the mapping is not executable;<br>                     otherwise the mapping is executable.<br><br>              <b>PERF_RECORD_MISC_COMM_EXEC </b>(since Linux 3.16)<br>                     This is set for a <b>PERF_RECORD_COMM </b>record on kernels<br>                     more recent than Linux 3.16 if a process name change<br>                     was caused by an <b>exec</b>(2) system call.  It is an alias<br>                     for <b>PERF_RECORD_MISC_MMAP_DATA </b>since the two values<br>                     would not be set in the same record.<br><br>              <b>PERF_RECORD_MISC_EXACT_IP</b><br>                     This indicates that the content of <b>PERF_SAMPLE_IP</b><br>                     points to the actual instruction that triggered the<br>                     event.  See also <i>perf_event_attr.precise_ip</i>.<br><br>              <b>PERF_RECORD_MISC_EXT_RESERVED </b>(since Linux 2.6.35)<br>                     This indicates there is extended data available<br>                     (currently not used).<br><br>       <i>type</i>   The <i>type</i> value is one of the below.  The values in the<br>              corresponding record (that follows the header) depend on the<br>              <i>type</i> selected as shown.<br><br>              <b>PERF_RECORD_MMAP</b><br>                  The MMAP events record the <b>PROT_EXEC </b>mappings so that we<br>                  can correlate user-space IPs to code.  They have the<br>                  following structure:<br><br>                      struct {<br>                          struct perf_event_header header;<br>                          u32    pid, tid;<br>                          u64    addr;<br>                          u64    len;<br>                          u64    pgoff;<br>                          char   filename[];<br>                      };<br><br>                  <i>pid</i>    is the process ID.<br><br>                  <i>tid</i>    is the thread ID.<br><br>                  <i>addr</i>   is the address of the allocated memory.  <i>len</i> is the<br>                         length of the allocated memory.  <i>pgoff</i> is the page<br>                         offset of the allocated memory.  <i>filename</i> is a<br>                         string describing the backing of the allocated<br>                         memory.<br><br>              <b>PERF_RECORD_LOST</b><br>                  This record indicates when events are lost.<br><br>                      struct {<br>                          struct perf_event_header header;<br>                          u64 id;<br>                          u64 lost;<br>                          struct sample_id sample_id;<br>                      };<br><br>                  <i>id</i>     is the unique event ID for the samples that were<br>                         lost.<br><br>                  <i>lost</i>   is the number of events that were lost.<br><br>              <b>PERF_RECORD_COMM</b><br>                  This record indicates a change in the process name.<br><br>                      struct {<br>                          struct perf_event_header header;<br>                          u32 pid;<br>                          u32 tid;<br>                          char comm[];<br>                          struct sample_id sample_id;<br>                      };<br><br>                  <i>pid</i>    is the process ID.<br><br>                  <i>tid</i>    is the thread ID.<br><br>                  <i>comm</i>   is a string containing the new name of the process.<br><br>              <b>PERF_RECORD_EXIT</b><br>                  This record indicates a process exit event.<br><br>                      struct {<br>                          struct perf_event_header header;<br>                          u32 pid, ppid;<br>                          u32 tid, ptid;<br>                          u64 time;<br>                          struct sample_id sample_id;<br>                      };<br><br>              <b>PERF_RECORD_THROTTLE</b>, <b>PERF_RECORD_UNTHROTTLE</b><br>                  This record indicates a throttle/unthrottle event.<br><br>                      struct {<br>                          struct perf_event_header header;<br>                          u64 time;<br>                          u64 id;<br>                          u64 stream_id;<br>                          struct sample_id sample_id;<br>                      };<br><br>              <b>PERF_RECORD_FORK</b><br>                  This record indicates a fork event.<br><br>                      struct {<br>                          struct perf_event_header header;<br>                          u32 pid, ppid;<br>                          u32 tid, ptid;<br>                          u64 time;<br>                          struct sample_id sample_id;<br>                      };<br><br>              <b>PERF_RECORD_READ</b><br>                  This record indicates a read event.<br><br>                      struct {<br>                          struct perf_event_header header;<br>                          u32 pid, tid;<br>                          struct read_format values;<br>                          struct sample_id sample_id;<br>                      };<br><br>              <b>PERF_RECORD_SAMPLE</b><br>                  This record indicates a sample.<br><br>                      struct {<br>                          struct perf_event_header header;<br>                          u64   sample_id;  /* if PERF_SAMPLE_IDENTIFIER */<br>                          u64   ip;         /* if PERF_SAMPLE_IP */<br>                          u32   pid, tid;   /* if PERF_SAMPLE_TID */<br>                          u64   time;       /* if PERF_SAMPLE_TIME */<br>                          u64   addr;       /* if PERF_SAMPLE_ADDR */<br>                          u64   id;         /* if PERF_SAMPLE_ID */<br>                          u64   stream_id;  /* if PERF_SAMPLE_STREAM_ID */<br>                          u32   cpu, res;   /* if PERF_SAMPLE_CPU */<br>                          u64   period;     /* if PERF_SAMPLE_PERIOD */<br>                          struct read_format v; /* if PERF_SAMPLE_READ */<br>                          u64   nr;         /* if PERF_SAMPLE_CALLCHAIN */<br>                          u64   ips[nr];    /* if PERF_SAMPLE_CALLCHAIN */<br>                          u32   size;       /* if PERF_SAMPLE_RAW */<br>                          char  data[size]; /* if PERF_SAMPLE_RAW */<br>                          u64   bnr;        /* if PERF_SAMPLE_BRANCH_STACK */<br>                          struct perf_branch_entry lbr[bnr];<br>                                            /* if PERF_SAMPLE_BRANCH_STACK */<br>                          u64   abi;        /* if PERF_SAMPLE_REGS_USER */<br>                          u64   regs[weight(mask)];<br>                                            /* if PERF_SAMPLE_REGS_USER */<br>                          u64   size;       /* if PERF_SAMPLE_STACK_USER */<br>                          char  data[size]; /* if PERF_SAMPLE_STACK_USER */<br>                          u64   dyn_size;   /* if PERF_SAMPLE_STACK_USER */<br>                          u64   weight;     /* if PERF_SAMPLE_WEIGHT */<br>                          u64   data_src;   /* if PERF_SAMPLE_DATA_SRC */<br>                          u64   transaction;/* if PERF_SAMPLE_TRANSACTION */<br>                          u64   abi;        /* if PERF_SAMPLE_REGS_INTR */<br>                          u64   regs[weight(mask)];<br>                                            /* if PERF_SAMPLE_REGS_INTR */<br>                      };<br><br>                  <i>sample_id</i><br>                      If <b>PERF_SAMPLE_IDENTIFIER </b>is enabled, a 64-bit unique<br>                      ID is included.  This is a duplication of the<br>                      <b>PERF_SAMPLE_ID </b><i>id</i> value, but included at the beginning<br>                      of the sample so parsers can easily obtain the value.<br><br>                  <i>ip</i>  If <b>PERF_SAMPLE_IP </b>is enabled, then a 64-bit<br>                      instruction pointer value is included.<br><br>                  <i>pid</i>, <i>tid</i><br>                      If <b>PERF_SAMPLE_TID </b>is enabled, then a 32-bit process<br>                      ID and 32-bit thread ID are included.<br><br>                  <i>time</i><br>                      If <b>PERF_SAMPLE_TIME </b>is enabled, then a 64-bit<br>                      timestamp is included.  This is obtained via<br>                      local_clock() which is a hardware timestamp if<br>                      available and the jiffies value if not.<br><br>                  <i>addr</i><br>                      If <b>PERF_SAMPLE_ADDR </b>is enabled, then a 64-bit address<br>                      is included.  This is usually the address of a<br>                      tracepoint, breakpoint, or software event; otherwise<br>                      the value is 0.<br><br>                  <i>id</i>  If <b>PERF_SAMPLE_ID </b>is enabled, a 64-bit unique ID is<br>                      included.  If the event is a member of an event group,<br>                      the group leader ID is returned.  This ID is the same<br>                      as the one returned by <b>PERF_FORMAT_ID</b>.<br><br>                  <i>stream_id</i><br>                      If <b>PERF_SAMPLE_STREAM_ID </b>is enabled, a 64-bit unique<br>                      ID is included.  Unlike <b>PERF_SAMPLE_ID </b>the actual ID<br>                      is returned, not the group leader.  This ID is the<br>                      same as the one returned by <b>PERF_FORMAT_ID</b>.<br><br>                  <i>cpu</i>, <i>res</i><br>                      If <b>PERF_SAMPLE_CPU </b>is enabled, this is a 32-bit value<br>                      indicating which CPU was being used, in addition to a<br>                      reserved (unused) 32-bit value.<br><br>                  <i>period</i><br>                      If <b>PERF_SAMPLE_PERIOD </b>is enabled, a 64-bit value<br>                      indicating the current sampling period is written.<br><br>                  <i>v</i>   If <b>PERF_SAMPLE_READ </b>is enabled, a structure of type<br>                      read_format is included which has values for all<br>                      events in the event group.  The values included depend<br>                      on the <i>read_format</i> value used at <b>perf_event_open</b>()<br>                      time.<br><br>                  <i>nr</i>, <i>ips[nr]</i><br>                      If <b>PERF_SAMPLE_CALLCHAIN </b>is enabled, then a 64-bit<br>                      number is included which indicates how many following<br>                      64-bit instruction pointers will follow.  This is the<br>                      current callchain.<br><br>                  <i>size</i>, <i>data[size]</i><br>                      If <b>PERF_SAMPLE_RAW </b>is enabled, then a 32-bit value<br>                      indicating size is included followed by an array of<br>                      8-bit values of length size.  The values are padded<br>                      with 0 to have 64-bit alignment.<br><br>                      This RAW record data is opaque with respect to the<br>                      ABI.  The ABI doesn't make any promises with respect<br>                      to the stability of its content, it may vary depending<br>                      on event, hardware, and kernel version.<br><br>                  <i>bnr</i>, <i>lbr[bnr]</i><br>                      If <b>PERF_SAMPLE_BRANCH_STACK </b>is enabled, then a 64-bit<br>                      value indicating the number of records is included,<br>                      followed by <i>bnr perf_branch_entry</i> structures which<br>                      each include the fields:<br><br>                      <i>from</i>   This indicates the source instruction (may not<br>                             be a branch).<br><br>                      <i>to</i>     The branch target.<br><br>                      <i>mispred</i><br>                             The branch target was mispredicted.<br><br>                      <i>predicted</i><br>                             The branch target was predicted.<br><br>                      <i>in_tx</i> (since Linux 3.11)<br>                             The branch was in a transactional memory<br>                             transaction.<br><br>                      <i>abort</i> (since Linux 3.11)<br>                             The branch was in an aborted transactional<br>                             memory transaction.<br><br>                      The entries are from most to least recent, so the<br>                      first entry has the most recent branch.<br><br>                      Support for <i>mispred</i> and <i>predicted</i> is optional; if not<br>                      supported, both values will be 0.<br><br>                      The type of branches recorded is specified by the<br>                      <i>branch_sample_type</i> field.<br><br>                  <i>abi</i>, <i>regs[weight(mask)]</i><br>                      If <b>PERF_SAMPLE_REGS_USER </b>is enabled, then the user CPU<br>                      registers are recorded.<br><br>                      The <i>abi</i> field is one of <b>PERF_SAMPLE_REGS_ABI_NONE</b>,<br>                      <b>PERF_SAMPLE_REGS_ABI_32 </b>or <b>PERF_SAMPLE_REGS_ABI_64</b>.<br><br>                      The <i>regs</i> field is an array of the CPU registers that<br>                      were specified by the <i>sample_regs_user</i> attr field.<br>                      The number of values is the number of bits set in the<br>                      <i>sample_regs_user</i> bit mask.<br><br>                  <i>size</i>, <i>data[size]</i>, <i>dyn_size</i><br>                      If <b>PERF_SAMPLE_STACK_USER </b>is enabled, then the user<br>                      stack is recorded.  This can be used to generate stack<br>                      backtraces.  <i>size</i> is the size requested by the user in<br>                      <i>sample_stack_user</i> or else the maximum record size.<br>                      <i>data</i> is the stack data (a raw dump of the memory<br>                      pointed to by the stack pointer at the time of<br>                      sampling).  <i>dyn_size</i> is the amount of data actually<br>                      dumped (can be less than <i>size</i>).<br><br>                  <i>weight</i><br>                      If <b>PERF_SAMPLE_WEIGHT </b>is enabled, then a 64-bit value<br>                      provided by the hardware is recorded that indicates<br>                      how costly the event was.  This allows expensive<br>                      events to stand out more clearly in profiles.<br><br>                  <i>data_src</i><br>                      If <b>PERF_SAMPLE_DATA_SRC </b>is enabled, then a 64-bit<br>                      value is recorded that is made up of the following<br>                      fields:<br><br>                      <i>mem_op</i><br>                          Type of opcode, a bitwise combination of:<br><br>                          <b>PERF_MEM_OP_NA          </b>Not available<br>                          <b>PERF_MEM_OP_LOAD        </b>Load instruction<br>                          <b>PERF_MEM_OP_STORE       </b>Store instruction<br>                          <b>PERF_MEM_OP_PFETCH      </b>Prefetch<br>                          <b>PERF_MEM_OP_EXEC        </b>Executable code<br><br>                      <i>mem_lvl</i><br>                          Memory hierarchy level hit or miss, a bitwise<br>                          combination of the following, shifted left by<br>                          <b>PERF_MEM_LVL_SHIFT</b>:<br><br>                          <b>PERF_MEM_LVL_NA         </b>Not available<br>                          <b>PERF_MEM_LVL_HIT        </b>Hit<br>                          <b>PERF_MEM_LVL_MISS       </b>Miss<br>                          <b>PERF_MEM_LVL_L1         </b>Level 1 cache<br>                          <b>PERF_MEM_LVL_LFB        </b>Line fill buffer<br>                          <b>PERF_MEM_LVL_L2         </b>Level 2 cache<br>                          <b>PERF_MEM_LVL_L3         </b>Level 3 cache<br>                          <b>PERF_MEM_LVL_LOC_RAM    </b>Local DRAM<br>                          <b>PERF_MEM_LVL_REM_RAM1   </b>Remote DRAM 1 hop<br>                          <b>PERF_MEM_LVL_REM_RAM2   </b>Remote DRAM 2 hops<br>                          <b>PERF_MEM_LVL_REM_CCE1   </b>Remote cache 1 hop<br>                          <b>PERF_MEM_LVL_REM_CCE2   </b>Remote cache 2 hops<br>                          <b>PERF_MEM_LVL_IO         </b>I/O memory<br>                          <b>PERF_MEM_LVL_UNC        </b>Uncached memory<br><br>                      <i>mem_snoop</i><br>                          Snoop mode, a bitwise combination of the<br>                          following, shifted left by <b>PERF_MEM_SNOOP_SHIFT</b>:<br><br>                          <b>PERF_MEM_SNOOP_NA       </b>Not available<br>                          <b>PERF_MEM_SNOOP_NONE     </b>No snoop<br>                          <b>PERF_MEM_SNOOP_HIT      </b>Snoop hit<br>                          <b>PERF_MEM_SNOOP_MISS     </b>Snoop miss<br>                          <b>PERF_MEM_SNOOP_HITM     </b>Snoop hit modified<br><br>                      <i>mem_lock</i><br>                          Lock instruction, a bitwise combination of the<br>                          following, shifted left by <b>PERF_MEM_LOCK_SHIFT</b>:<br><br>                          <b>PERF_MEM_LOCK_NA        </b>Not available<br>                          <b>PERF_MEM_LOCK_LOCKED    </b>Locked transaction<br><br>                      <i>mem_dtlb</i><br>                          TLB access hit or miss, a bitwise combination of<br>                          the following, shifted left by <b>PERF_MEM_TLB_SHIFT</b>:<br><br>                          <b>PERF_MEM_TLB_NA         </b>Not available<br>                          <b>PERF_MEM_TLB_HIT        </b>Hit<br>                          <b>PERF_MEM_TLB_MISS       </b>Miss<br>                          <b>PERF_MEM_TLB_L1         </b>Level 1 TLB<br>                          <b>PERF_MEM_TLB_L2         </b>Level 2 TLB<br>                          <b>PERF_MEM_TLB_WK         </b>Hardware walker<br>                          <b>PERF_MEM_TLB_OS         </b>OS fault handler<br><br>                  <i>transaction</i><br>                      If the <b>PERF_SAMPLE_TRANSACTION </b>flag is set, then a<br>                      64-bit field is recorded describing the sources of any<br>                      transactional memory aborts.<br><br>                      The field is a bitwise combination of the following<br>                      values:<br><br>                      <b>PERF_TXN_ELISION</b><br>                             Abort from an elision type transaction (Intel-<br>                             CPU-specific).<br><br>                      <b>PERF_TXN_TRANSACTION</b><br>                             Abort from a generic transaction.<br><br>                      <b>PERF_TXN_SYNC</b><br>                             Synchronous abort (related to the reported<br>                             instruction).<br><br>                      <b>PERF_TXN_ASYNC</b><br>                             Asynchronous abort (not related to the reported<br>                             instruction).<br><br>                      <b>PERF_TXN_RETRY</b><br>                             Retryable abort (retrying the transaction may<br>                             have succeeded).<br><br>                      <b>PERF_TXN_CONFLICT</b><br>                             Abort due to memory conflicts with other<br>                             threads.<br><br>                      <b>PERF_TXN_CAPACITY_WRITE</b><br>                             Abort due to write capacity overflow.<br><br>                      <b>PERF_TXN_CAPACITY_READ</b><br>                             Abort due to read capacity overflow.<br><br>                      In addition, a user-specified abort code can be<br>                      obtained from the high 32 bits of the field by<br>                      shifting right by <b>PERF_TXN_ABORT_SHIFT </b>and masking<br>                      with <b>PERF_TXN_ABORT_MASK</b>.<br><br>                  <i>abi</i>, <i>regs[weight(mask)]</i><br>                      If <b>PERF_SAMPLE_REGS_INTR </b>is enabled, then the user CPU<br>                      registers are recorded.<br><br>                      The <i>abi</i> field is one of <b>PERF_SAMPLE_REGS_ABI_NONE</b>,<br>                      <b>PERF_SAMPLE_REGS_ABI_32 </b>or <b>PERF_SAMPLE_REGS_ABI_64</b>.<br><br>                      The <i>regs</i> field is an array of the CPU registers that<br>                      were specified by the <i>sample_regs_intr</i> attr field.<br>                      The number of values is the number of bits set in the<br>                      <i>sample_regs_intr</i> bit mask.<br><br>              <b>PERF_RECORD_MMAP2</b><br>                  This record includes extended information on mmap(2) calls<br>                  returning executable mappings.  The format is similar to<br>                  that of the <b>PERF_RECORD_MMAP </b>record, but includes extra<br>                  values that allow uniquely identifying shared mappings.<br><br>                      struct {<br>                          struct perf_event_header header;<br>                          u32 pid;<br>                          u32 tid;<br>                          u64 addr;<br>                          u64 len;<br>                          u64 pgoff;<br>                          u32 maj;<br>                          u32 min;<br>                          u64 ino;<br>                          u64 ino_generation;<br>                          u32 prot;<br>                          u32 flags;<br>                          char filename[];<br>                          struct sample_id sample_id;<br>                      };<br><br>                  <i>pid</i>    is the process ID.<br><br>                  <i>tid</i>    is the thread ID.<br><br>                  <i>addr</i>   is the address of the allocated memory.<br><br>                  <i>len</i>    is the length of the allocated memory.<br><br>                  <i>pgoff</i>  is the page offset of the allocated memory.<br><br>                  <i>maj</i>    is the major ID of the underlying device.<br><br>                  <i>min</i>    is the minor ID of the underlying device.<br><br>                  <i>ino</i>    is the inode number.<br><br>                  <i>ino_generation</i><br>                         is the inode generation.<br><br>                  <i>prot</i>   is the protection information.<br><br>                  <i>flags</i>  is the flags information.<br><br>                  <i>filename</i><br>                         is a string describing the backing of the allocated<br>                         memory.<br><br>   <b>Overflow handling</b><br>       Events can be set to notify when a threshold is crossed, indicating<br>       an overflow.  Overflow conditions can be captured by monitoring the<br>       event file descriptor with poll(2), select(2), or <b>epoll</b>(2).<br>       Alternately, a SIGIO signal handler can be created and the event<br>       configured with fcntl(2) to generate SIGIO signals.<br><br>       Overflows are generated only by sampling events (<i>sample_period</i> must<br>       have a nonzero value).<br><br>       There are two ways to generate overflow notifications.<br><br>       The first is to set a <i>wakeup_events</i> or <i>wakeup_watermark</i> value that<br>       will trigger if a certain number of samples or bytes have been<br>       written to the mmap ring buffer.  In this case <b>POLL_IN </b>is indicated.<br><br>       The other way is by use of the <b>PERF_EVENT_IOC_REFRESH </b>ioctl.  This<br>       ioctl adds to a counter that decrements each time the event<br>       overflows.  When nonzero, <b>POLL_IN </b>is indicated, but once the counter<br>       reaches 0 <b>POLL_HUP </b>is indicated and the underlying event is disabled.<br><br>       Refreshing an event group leader refreshes all siblings and<br>       refreshing with a parameter of 0 currently enables infinite<br>       refreshes; these behaviors are unsupported and should not be relied<br>       on.<br><br>       Starting with Linux 3.18, <b>POLL_HUP </b>is indicated if the event being<br>       monitored is attached to a different process and that process exits.<br><br>   <b>rdpmc instruction</b><br>       Starting with Linux 3.4 on x86, you can use the <i>rdpmc</i> instruction to<br>       get low-latency reads without having to enter the kernel.  Note that<br>       using <i>rdpmc</i> is not necessarily faster than other methods for reading<br>       event values.<br><br>       Support for this can be detected with the <i>cap_usr_rdpmc</i> field in the<br>       mmap page; documentation on how to calculate event values can be<br>       found in that section.<br><br>   <b>perf_event ioctl calls</b><br>       Various ioctls act on <b>perf_event_open</b>() file descriptors:<br><br>       <b>PERF_EVENT_IOC_ENABLE</b><br>              This enables the individual event or event group specified by<br>              the file descriptor argument.<br><br>              If the <b>PERF_IOC_FLAG_GROUP </b>bit is set in the ioctl argument,<br>              then all events in a group are enabled, even if the event<br>              specified is not the group leader (but see BUGS).<br><br>       <b>PERF_EVENT_IOC_DISABLE</b><br>              This disables the individual counter or event group specified<br>              by the file descriptor argument.<br><br>              Enabling or disabling the leader of a group enables or<br>              disables the entire group; that is, while the group leader is<br>              disabled, none of the counters in the group will count.<br>              Enabling or disabling a member of a group other than the<br>              leader affects only that counter; disabling a non-leader stops<br>              that counter from counting but doesn't affect any other<br>              counter.<br><br>              If the <b>PERF_IOC_FLAG_GROUP </b>bit is set in the ioctl argument,<br>              then all events in a group are disabled, even if the event<br>              specified is not the group leader (but see BUGS).<br><br>       <b>PERF_EVENT_IOC_REFRESH</b><br>              Non-inherited overflow counters can use this to enable a<br>              counter for a number of overflows specified by the argument,<br>              after which it is disabled.  Subsequent calls of this ioctl<br>              add the argument value to the current count.  An overflow<br>              notification with <b>POLL_IN </b>set will happen on each overflow<br>              until the count reaches 0; when that happens a notification<br>              with <b>POLL_HUP </b>set is sent and the event is disabled.  Using an<br>              argument of 0 is considered undefined behavior.<br><br>       <b>PERF_EVENT_IOC_RESET</b><br>              Reset the event count specified by the file descriptor<br>              argument to zero.  This resets only the counts; there is no<br>              way to reset the multiplexing <i>time_enabled</i> or <i>time_running</i><br>              values.<br><br>              If the <b>PERF_IOC_FLAG_GROUP </b>bit is set in the ioctl argument,<br>              then all events in a group are reset, even if the event<br>              specified is not the group leader (but see BUGS).<br><br>       <b>PERF_EVENT_IOC_PERIOD</b><br>              This updates the overflow period for the event.<br><br>              Since Linux 3.7 (on ARM) and Linux 3.14 (all other<br>              architectures), the new period takes effect immediately.  On<br>              older kernels, the new period did not take effect until after<br>              the next overflow.<br><br>              The argument is a pointer to a 64-bit value containing the<br>              desired new period.<br><br>              Prior to Linux 2.6.36 this ioctl always failed due to a bug in<br>              the kernel.<br><br>       <b>PERF_EVENT_IOC_SET_OUTPUT</b><br>              This tells the kernel to report event notifications to the<br>              specified file descriptor rather than the default one.  The<br>              file descriptors must all be on the same CPU.<br><br>              The argument specifies the desired file descriptor, or -1 if<br>              output should be ignored.<br><br>       <b>PERF_EVENT_IOC_SET_FILTER </b>(since Linux 2.6.33)<br>              This adds an ftrace filter to this event.<br><br>              The argument is a pointer to the desired ftrace filter.<br><br>       <b>PERF_EVENT_IOC_ID </b>(since Linux 3.12)<br>              This returns the event ID value for the given event file<br>              descriptor.<br><br>              The argument is a pointer to a 64-bit unsigned integer to hold<br>              the result.<br><br>   <b>Using prctl</b><br>       A process can enable or disable all the event groups that are<br>       attached to it using the prctl(2) <b>PR_TASK_PERF_EVENTS_ENABLE </b>and<br>       <b>PR_TASK_PERF_EVENTS_DISABLE </b>operations.  This applies to all counters<br>       on the calling process, whether created by this process or by<br>       another, and does not affect any counters that this process has<br>       created on other processes.  It enables or disables only the group<br>       leaders, not any other members in the groups.<br><br>   <b>perf_event related configuration files</b><br>       Files in <i>/proc/sys/kernel/</i><br><br>           <i>/proc/sys/kernel/perf_event_paranoid</i><br><br>                  The <i>perf_event_paranoid</i> file can be set to restrict access<br>                  to the performance counters.<br><br>                  2   allow only user-space measurements.<br><br>                  1   allow both kernel and user measurements (default).<br><br>                  0   allow access to CPU-specific data but not raw<br>                      tracepoint samples.<br><br>                  -1  no restrictions.<br><br>                  The existence of the <i>perf_event_paranoid</i> file is the<br>                  official method for determining if a kernel supports<br>                  <b>perf_event_open</b>().<br><br>           <i>/proc/sys/kernel/perf_event_max_sample_rate</i><br><br>                  This sets the maximum sample rate.  Setting this too high<br>                  can allow users to sample at a rate that impacts overall<br>                  machine performance and potentially lock up the machine.<br>                  The default value is 100000 (samples per second).<br><br>           <i>/proc/sys/kernel/perf_event_mlock_kb</i><br><br>                  Maximum number of pages an unprivileged user can mlock(2).<br>                  The default is 516 (kB).<br><br>       Files in <i>/sys/bus/event_source/devices/</i><br>           Since Linux 2.6.34, the kernel supports having multiple PMUs<br>           available for monitoring.  Information on how to program these<br>           PMUs can be found under <i>/sys/bus/event_source/devices/</i>.  Each<br>           subdirectory corresponds to a different PMU.<br><br>           <i>/sys/bus/event_source/devices/*/type</i> (since Linux 2.6.38)<br>                  This contains an integer that can be used in the <i>type</i><br>                  field of <i>perf_event_attr</i> to indicate that you wish to use<br>                  this PMU.<br><br>           <i>/sys/bus/event_source/devices/*/rdpmc</i> (since Linux 3.4)<br>                  If this file is 1, then direct user-space access to the<br>                  performance counter registers is allowed via the rdpmc<br>                  instruction.  This can be disabled by echoing 0 to the<br>                  file.<br><br>           <i>/sys/bus/event_source/devices/*/format/</i> (since Linux 3.4)<br>                  This subdirectory contains information on the<br>                  architecture-specific subfields available for programming<br>                  the various <i>config</i> fields in the <i>perf_event_attr</i> struct.<br><br>                  The content of each file is the name of the config field,<br>                  followed by a colon, followed by a series of integer bit<br>                  ranges separated by commas.  For example, the file <i>event</i><br>                  may contain the value <i>config1:1,6-10,44</i> which indicates<br>                  that event is an attribute that occupies bits 1,6-10, and<br>                  44 of <i>perf_event_attr::config1</i>.<br><br>           <i>/sys/bus/event_source/devices/*/events/</i> (since Linux 3.4)<br>                  This subdirectory contains files with predefined events.<br>                  The contents are strings describing the event settings<br>                  expressed in terms of the fields found in the previously<br>                  mentioned <i>./format/</i> directory.  These are not necessarily<br>                  complete lists of all events supported by a PMU, but<br>                  usually a subset of events deemed useful or interesting.<br><br>                  The content of each file is a list of attribute names<br>                  separated by commas.  Each entry has an optional value<br>                  (either hex or decimal).  If no value is specified, then<br>                  it is assumed to be a single-bit field with a value of 1.<br>                  An example entry may look like this:<br>                  <i>event=0x2,inv,ldlat=3</i>.<br><br>           <i>/sys/bus/event_source/devices/*/uevent</i><br>                  This file is the standard kernel device interface for<br>                  injecting hotplug events.<br><br>           <i>/sys/bus/event_source/devices/*/cpumask</i> (since Linux 3.7)<br>                  The <i>cpumask</i> file contains a comma-separated list of<br>                  integers that indicate a representative CPU number for<br>                  each socket (package) on the motherboard.  This is needed<br>                  when setting up uncore or northbridge events, as those<br>                  PMUs present socket-wide events.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       <b>perf_event_open</b>() returns the new file descriptor, or -1 if an error<br>       occurred (in which case, <i>errno</i> is set appropriately).<br></pre><br><h2>ERRORS  </h2><pre><br>       The errors returned by <b>perf_event_open</b>() can be inconsistent, and may<br>       vary across processor architectures and performance monitoring units.<br><br>       <b>E2BIG  </b>Returned if the <i>perf_event_attr size</i> value is too small<br>              (smaller than <b>PERF_ATTR_SIZE_VER0</b>), too big (larger than the<br>              page size), or larger than the kernel supports and the extra<br>              bytes are not zero.  When <b>E2BIG </b>is returned, the<br>              <i>perf_event_attr size</i> field is overwritten by the kernel to be<br>              the size of the structure it was expecting.<br><br>       <b>EACCES </b>Returned when the requested event requires <b>CAP_SYS_ADMIN</b><br>              permissions (or a more permissive perf_event paranoid<br>              setting).  Some common cases where an unprivileged process may<br>              encounter this error: attaching to a process owned by a<br>              different user; monitoring all processes on a given CPU (i.e.,<br>              specifying the <i>pid</i> argument as -1); and not setting<br>              <i>exclude_kernel</i> when the paranoid setting requires it.<br><br>       <b>EBADF  </b>Returned if the <i>group_fd</i> file descriptor is not valid, or, if<br>              <b>PERF_FLAG_PID_CGROUP </b>is set, the cgroup file descriptor in <i>pid</i><br>              is not valid.<br><br>       <b>EFAULT </b>Returned if the <i>attr</i> pointer points at an invalid memory<br>              address.<br><br>       <b>EINVAL </b>Returned if the specified event is invalid.  There are many<br>              possible reasons for this.  A not-exhaustive list: <i>sample_freq</i><br>              is higher than the maximum setting; the <i>cpu</i> to monitor does<br>              not exist; <i>read_format</i> is out of range; <i>sample_type</i> is out of<br>              range; the <i>flags</i> value is out of range; <i>exclusive</i> or <i>pinned</i><br>              set and the event is not a group leader; the event <i>config</i><br>              values are out of range or set reserved bits; the generic<br>              event selected is not supported; or there is not enough room<br>              to add the selected event.<br><br>       <b>EMFILE </b>Each opened event uses one file descriptor.  If a large number<br>              of events are opened the per-user file descriptor limit (often<br>              1024) will be hit and no more events can be created.<br><br>       <b>ENODEV </b>Returned when the event involves a feature not supported by<br>              the current CPU.<br><br>       <b>ENOENT </b>Returned if the <i>type</i> setting is not valid.  This error is also<br>              returned for some unsupported generic events.<br><br>       <b>ENOSPC </b>Prior to Linux 3.3, if there was not enough room for the<br>              event, <b>ENOSPC </b>was returned.  In Linux 3.3, this was changed to<br>              <b>EINVAL</b>.  <b>ENOSPC </b>is still returned if you try to add more<br>              breakpoint events than supported by the hardware.<br><br>       <b>ENOSYS </b>Returned if <b>PERF_SAMPLE_STACK_USER </b>is set in <i>sample_type</i> and<br>              it is not supported by hardware.<br><br>       <b>EOPNOTSUPP</b><br>              Returned if an event requiring a specific hardware feature is<br>              requested but there is no hardware support.  This includes<br>              requesting low-skid events if not supported, branch tracing if<br>              it is not available, sampling if no PMU interrupt is<br>              available, and branch stacks for software events.<br><br>       <b>EPERM  </b>Returned on many (but not all) architectures when an<br>              unsupported <i>exclude_hv</i>, <i>exclude_idle</i>, <i>exclude_user</i>, or<br>              <i>exclude_kernel</i> setting is specified.<br><br>              It can also happen, as with <b>EACCES</b>, when the requested event<br>              requires <b>CAP_SYS_ADMIN </b>permissions (or a more permissive<br>              perf_event paranoid setting).  This includes setting a<br>              breakpoint on a kernel address, and (since Linux 3.13) setting<br>              a kernel function-trace tracepoint.<br><br>       <b>ESRCH  </b>Returned if attempting to attach to a process that does not<br>              exist.<br></pre><br><h2>VERSION  </h2><pre><br>       <b>perf_event_open</b>() was introduced in Linux 2.6.31 but was called<br>       <b>perf_counter_open</b>().  It was renamed in Linux 2.6.32.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       This <b>perf_event_open</b>() system call Linux- specific and should not be<br>       used in programs intended to be portable.<br></pre><br><h2>NOTES  </h2><pre><br>       Glibc does not provide a wrapper for this system call; call it using<br>       syscall(2).  See the example below.<br><br>       The official way of knowing if <b>perf_event_open</b>() support is enabled<br>       is checking for the existence of the file<br>       <i>/proc/sys/kernel/perf_event_paranoid</i>.<br></pre><br><h2>BUGS  </h2><pre><br>       The <b>F_SETOWN_EX </b>option to fcntl(2) is needed to properly get overflow<br>       signals in threads.  This was introduced in Linux 2.6.32.<br><br>       Prior to Linux 2.6.33 (at least for x86), the kernel did not check if<br>       events could be scheduled together until read time.  The same happens<br>       on all known kernels if the NMI watchdog is enabled.  This means to<br>       see if a given set of events works you have to <b>perf_event_open</b>(),<br>       start, then read before you know for sure you can get valid<br>       measurements.<br><br>       Prior to Linux 2.6.34, event constraints were not enforced by the<br>       kernel.  In that case, some events would silently return \"0\" if the<br>       kernel scheduled them in an improper counter slot.<br><br>       Prior to Linux 2.6.34, there was a bug when multiplexing where the<br>       wrong results could be returned.<br><br>       Kernels from Linux 2.6.35 to Linux 2.6.39 can quickly crash the<br>       kernel if \"inherit\" is enabled and many threads are started.<br><br>       Prior to Linux 2.6.35, <b>PERF_FORMAT_GROUP </b>did not work with attached<br>       processes.<br><br>       There is a bug in the kernel code between Linux 2.6.36 and Linux 3.0<br>       that ignores the \"watermark\" field and acts as if a wakeup_event was<br>       chosen if the union has a nonzero value in it.<br><br>       From Linux 2.6.31 to Linux 3.4, the <b>PERF_IOC_FLAG_GROUP </b>ioctl<br>       argument was broken and would repeatedly operate on the event<br>       specified rather than iterating across all sibling events in a group.<br><br>       From Linux 3.4 to Linux 3.11, the mmap <i>cap_usr_rdpmc</i> and <i>cap_usr_time</i><br>       bits mapped to the same location.  Code should migrate to the new<br>       <i>cap_user_rdpmc</i> and <i>cap_user_time</i> fields instead.<br><br>       Always double-check your results!  Various generalized events have<br>       had wrong values.  For example, retired branches measured the wrong<br>       thing on AMD machines until Linux 2.6.35.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The following is a short example that measures the total instruction<br>       count of a call to printf(3).<br><br>       #include &lt;stdlib.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;unistd.h&gt;<br>       #include &lt;string.h&gt;<br>       #include &lt;sys/ioctl.h&gt;<br>       #include &lt;linux/perf_event.h&gt;<br>       #include &lt;asm/unistd.h&gt;<br><br>       static long<br>       perf_event_open(struct perf_event_attr *hw_event, pid_t pid,<br>                       int cpu, int group_fd, unsigned long flags)<br>       {<br>           int ret;<br><br>           ret = syscall(__NR_perf_event_open, hw_event, pid, cpu,<br>                          group_fd, flags);<br>           return ret;<br>       }<br><br>       int<br>       main(int argc, char **argv)<br>       {<br>           struct perf_event_attr pe;<br>           long long count;<br>           int fd;<br><br>           memset(&amp;pe, 0, sizeof(struct perf_event_attr));<br>           pe.type = PERF_TYPE_HARDWARE;<br>           pe.size = sizeof(struct perf_event_attr);<br>           pe.config = PERF_COUNT_HW_INSTRUCTIONS;<br>           pe.disabled = 1;<br>           pe.exclude_kernel = 1;<br>           pe.exclude_hv = 1;<br><br>           fd = perf_event_open(&amp;pe, 0, -1, -1, 0);<br>           if (fd == -1) {<br>              fprintf(stderr, \"Error opening leader %llx\\n\", pe.config);<br>              exit(EXIT_FAILURE);<br>           }<br><br>           ioctl(fd, PERF_EVENT_IOC_RESET, 0);<br>           ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);<br><br>           printf(\"Measuring instruction count for this printf\\n\");<br><br>           ioctl(fd, PERF_EVENT_IOC_DISABLE, 0);<br>           read(fd, &amp;count, sizeof(long long));<br><br>           printf(\"Used %lld instructions\\n\", count);<br><br>           close(fd);<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       fcntl(2), mmap(2), open(2), prctl(2), read(2)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23               PERF_EVENT_OPEN(2)</span><br></pre><br>"}