{"Man page": "<pre><br><span class=\"headline\">OPEN_BY_HANDLE_AT(2)      Linux Programmer's Manual     OPEN_BY_HANDLE_AT(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       name_to_handle_at,  open_by_handle_at  - obtain handle for a pathname<br>       and open file via a handle<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#define _GNU_SOURCE         </b>/* See feature_test_macros(7) */<br>       <b>#include &lt;sys/types.h&gt;</b><br>       <b>#include &lt;sys/stat.h&gt;</b><br>       <b>#include &lt;fcntl.h&gt;</b><br><br>       <b>int name_to_handle_at(int </b><i>dirfd</i><b>, const char *</b><i>pathname</i><b>,</b><br>                             <b>struct file_handle *</b><i>handle</i><b>,</b><br>                             <b>int *</b><i>mount_id</i><b>, int </b><i>flags</i><b>);</b><br><br>       <b>int open_by_handle_at(int </b><i>mount_fd</i><b>, struct file_handle *</b><i>handle</i><b>,</b><br>                             <b>int </b><i>flags</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>name_to_handle_at</b>() and <b>open_by_handle_at</b>() system calls split<br>       the functionality of openat(2) into two parts: <b>name_to_handle_at</b>()<br>       returns an opaque handle that corresponds to a specified file;<br>       <b>open_by_handle_at</b>() opens the file corresponding to a handle returned<br>       by a previous call to <b>name_to_handle_at</b>() and returns an open file<br>       descriptor.<br><br>   <b>name_to_handle_at()</b><br>       The <b>name_to_handle_at</b>() system call returns a file handle and a mount<br>       ID corresponding to the file specified by the <i>dirfd</i> and <i>pathname</i><br>       arguments.  The file handle is returned via the argument <i>handle</i>,<br>       which is a pointer to a structure of the following form:<br><br>           struct file_handle {<br>               unsigned int  handle_bytes;   /* Size of f_handle [in, out] */<br>               int           handle_type;    /* Handle type [out] */<br>               unsigned char f_handle[0];    /* File identifier (sized by<br>                                                caller) [out] */<br>           };<br><br>       It is the caller's responsibility to allocate the structure with a<br>       size large enough to hold the handle returned in <i>f_handle</i>.  Before<br>       the call, the <i>handle_bytes</i> field should be initialized to contain the<br>       allocated size for <i>f_handle</i>.  (The constant <b>MAX_HANDLE_SZ</b>, defined in<br>       <i>&lt;fcntl.h&gt;</i>, specifies the maximum possible size for a file handle.)<br>       Upon successful return, the <i>handle_bytes</i> field is updated to contain<br>       the number of bytes actually written to <i>f_handle</i>.<br><br>       The caller can discover the required size for the <i>file_handle</i><br>       structure by making a call in which <i>handle-&gt;handle_bytes</i> is zero; in<br>       this case, the call fails with the error <b>EOVERFLOW </b>and<br>       <i>handle-&gt;handle_bytes</i> is set to indicate the required size; the caller<br>       can then use this information to allocate a structure of the correct<br>       size (see EXAMPLE below).<br><br>       Other than the use of the <i>handle_bytes</i> field, the caller should treat<br>       the <i>file_handle</i> structure as an opaque data type: the <i>handle_type</i> and<br>       <i>f_handle</i> fields are needed only by a subsequent call to<br>       <b>open_by_handle_at</b>().<br><br>       The <i>flags</i> argument is a bit mask constructed by ORing together zero<br>       or more of <b>AT_EMPTY_PATH </b>and <b>AT_SYMLINK_FOLLOW</b>, described below.<br><br>       Together, the <i>pathname</i> and <i>dirfd</i> arguments identify the file for<br>       which a handle is to be obtained.  There are four distinct cases:<br><br>       *  If <i>pathname</i> is a nonempty string containing an absolute pathname,<br>          then a handle is returned for the file referred to by that<br>          pathname.  In this case, <i>dirfd</i> is ignored.<br><br>       *  If <i>pathname</i> is a nonempty string containing a relative pathname<br>          and <i>dirfd</i> has the special value <b>AT_FDCWD</b>, then <i>pathname</i> is<br>          interpreted relative to the current working directory of the<br>          caller, and a handle is returned for the file to which it refers.<br><br>       *  If <i>pathname</i> is a nonempty string containing a relative pathname<br>          and <i>dirfd</i> is a file descriptor referring to a directory, then<br>          <i>pathname</i> is interpreted relative to the directory referred to by<br>          <i>dirfd</i>, and a handle is returned for the file to which it refers.<br>          (See openat(2) for an explanation of why \"directory file<br>          descriptors\" are useful.)<br><br>       *  If <i>pathname</i> is an empty string and <i>flags</i> specifies the value<br>          <b>AT_EMPTY_PATH</b>, then <i>dirfd</i> can be an open file descriptor referring<br>          to any type of file, or <b>AT_FDCWD</b>, meaning the current working<br>          directory, and a handle is returned for the file to which it<br>          refers.<br><br>       The <i>mount_id</i> argument returns an identifier for the filesystem mount<br>       that corresponds to <i>pathname</i>.  This corresponds to the first field in<br>       one of the records in <i>/proc/self/mountinfo</i>.  Opening the pathname in<br>       the fifth field of that record yields a file descriptor for the mount<br>       point; that file descriptor can be used in a subsequent call to<br>       <b>open_by_handle_at</b>().<br><br>       By default, <b>name_to_handle_at</b>() does not dereference <i>pathname</i> if it<br>       is a symbolic link, and thus returns a handle for the link itself.<br>       If <b>AT_SYMLINK_FOLLOW </b>is specified in <i>flags</i>, <i>pathname</i> is dereferenced<br>       if it is a symbolic link (so that the call returns a handle for the<br>       file referred to by the link).<br><br>   <b>open_by_handle_at()</b><br>       The <b>open_by_handle_at</b>() system call opens the file referred to by<br>       <i>handle</i>, a file handle returned by a previous call to<br>       <b>name_to_handle_at</b>().<br><br>       The <i>mount_fd</i> argument is a file descriptor for any object (file,<br>       directory, etc.)  in the mounted filesystem with respect to which<br>       <i>handle</i> should be interpreted.  The special value <b>AT_FDCWD </b>can be<br>       specified, meaning the current working directory of the caller.<br><br>       The <i>flags</i> argument is as for open(2).  If <i>handle</i> refers to a symbolic<br>       link, the caller must specify the <b>O_PATH </b>flag, and the symbolic link<br>       is not dereferenced; the <b>O_NOFOLLOW </b>flag, if specified, is ignored.<br><br>       The caller must have the <b>CAP_DAC_READ_SEARCH </b>capability to invoke<br>       <b>open_by_handle_at</b>().<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>name_to_handle_at</b>() returns 0, and <b>open_by_handle_at</b>()<br>       returns a nonnegative file descriptor.<br><br>       In the event of an error, both system calls return -1 and set <i>errno</i><br>       to indicate the cause of the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>name_to_handle_at</b>() and <b>open_by_handle_at</b>() can fail for the same<br>       errors as openat(2).  In addition, they can fail with the errors<br>       noted below.<br><br>       <b>name_to_handle_at</b>() can fail with the following errors:<br><br>       <b>EFAULT </b><i>pathname</i>, <i>mount_id</i>, or <i>handle</i> points outside your accessible<br>              address space.<br><br>       <b>EINVAL </b><i>flags</i> includes an invalid bit value.<br><br>       <b>EINVAL </b><i>handle-&gt;handle_bytes</i> is greater than <b>MAX_HANDLE_SZ</b>.<br><br>       <b>ENOENT </b><i>pathname</i> is an empty string, but <b>AT_EMPTY_PATH </b>was not<br>              specified in <i>flags</i>.<br><br>       <b>ENOTDIR</b><br>              The file descriptor supplied in <i>dirfd</i> does not refer to a<br>              directory, and it is not the case that both <i>flags</i> includes<br>              <b>AT_EMPTY_PATH </b>and <i>pathname</i> is an empty string.<br><br>       <b>EOPNOTSUPP</b><br>              The filesystem does not support decoding of a pathname to a<br>              file handle.<br><br>       <b>EOVERFLOW</b><br>              The <i>handle-&gt;handle_bytes</i> value passed into the call was too<br>              small.  When this error occurs, <i>handle-&gt;handle_bytes</i> is<br>              updated to indicate the required size for the handle.<br><br>       <b>open_by_handle_at</b>() can fail with the following errors:<br><br>       <b>EBADF  </b><i>mount_fd</i> is not an open file descriptor.<br><br>       <b>EFAULT </b><i>handle</i> points outside your accessible address space.<br><br>       <b>EINVAL </b><i>handle-&gt;handle_bytes</i> is greater than <b>MAX_HANDLE_SZ </b>or is equal<br>              to zero.<br><br>       <b>ELOOP  </b><i>handle</i> refers to a symbolic link, but <b>O_PATH </b>was not specified<br>              in <i>flags</i>.<br><br>       <b>EPERM  </b>The caller does not have the <b>CAP_DAC_READ_SEARCH </b>capability.<br><br>       <b>ESTALE </b>The specified <i>handle</i> is not valid.  This error will occur if,<br>              for example, the file has been deleted.<br></pre><br><h2>VERSIONS  </h2><pre><br>       These system calls first appeared in Linux 2.6.39.  Library support<br>       is provided in glibc since version 2.14.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       These system calls are nonstandard Linux extensions.<br><br>       FreeBSD has a broadly similar pair of system calls in the form of<br>       <b>getfh</b>() and <b>openfh</b>().<br></pre><br><h2>NOTES  </h2><pre><br>       A file handle can be generated in one process using<br>       <b>name_to_handle_at</b>() and later used in a different process that calls<br>       <b>open_by_handle_at</b>().<br><br>       Some filesystem don't support the translation of pathnames to file<br>       handles, for example, <i>/proc</i>, <i>/sys</i>, and various network filesystems.<br><br>       A file handle may become invalid (\"stale\") if a file is deleted, or<br>       for other filesystem-specific reasons.  Invalid handles are notified<br>       by an <b>ESTALE </b>error from <b>open_by_handle_at</b>().<br><br>       These system calls are designed for use by user-space file servers.<br>       For example, a user-space NFS server might generate a file handle and<br>       pass it to an NFS client.  Later, when the client wants to open the<br>       file, it could pass the handle back to the server.  This sort of<br>       functionality allows a user-space file server to operate in a<br>       stateless fashion with respect to the files it serves.<br><br>       If <i>pathname</i> refers to a symbolic link and <i>flags</i> does not specify<br>       <b>AT_SYMLINK_FOLLOW</b>, then <b>name_to_handle_at</b>() returns a handle for the<br>       link (rather than the file to which it refers).  The process<br>       receiving the handle can later perform operations on the symbolic<br>       link by converting the handle to a file descriptor using<br>       <b>open_by_handle_at</b>() with the <b>O_PATH </b>flag, and then passing the file<br>       descriptor as the <i>dirfd</i> argument in system calls such as<br>       readlinkat(2) and fchownat(2).<br><br>   <b>Obtaining a persistent filesystem ID</b><br>       The mount IDs in <i>/proc/self/mountinfo</i> can be reused as filesystems<br>       are unmounted and mounted.  Therefore, the mount ID returned by<br>       <b>name_to_handle_at</b>() (in <i>*mount_id</i>) should not be treated as a<br>       persistent identifier for the corresponding mounted filesystem.<br>       However, an application can use the information in the <i>mountinfo</i><br>       record that corresponds to the mount ID to derive a persistent<br>       identifier.<br><br>       For example, one can use the device name in the fifth field of the<br>       <i>mountinfo</i> record to search for the corresponding device UUID via the<br>       symbolic links in <i>/dev/disks/by-uuid</i>.  (A more comfortable way of<br>       obtaining the UUID is to use the libblkid(3) library.)  That process<br>       can then be reversed, using the UUID to look up the device name, and<br>       then obtaining the corresponding mount point, in order to produce the<br>       <i>mount_fd</i> argument used by <b>open_by_handle_at</b>().<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The two programs below demonstrate the use of <b>name_to_handle_at</b>() and<br>       <b>open_by_handle_at</b>().  The first program (<i>t_name_to_handle_at.c</i>) uses<br>       <b>name_to_handle_at</b>() to obtain the file handle and mount ID for the<br>       file specified in its command-line argument; the handle and mount ID<br>       are written to standard output.<br><br>       The second program (<i>t_open_by_handle_at.c</i>) reads a mount ID and file<br>       handle from standard input.  The program then employs<br>       <b>open_by_handle_at</b>() to open the file using that handle.  If an<br>       optional command-line argument is supplied, then the <i>mount_fd</i><br>       argument for <b>open_by_handle_at</b>() is obtained by opening the directory<br>       named in that argument.  Otherwise, <i>mount_fd</i> is obtained by scanning<br>       <i>/proc/self/mountinfo</i> to find a record whose mount ID matches the<br>       mount ID read from standard input, and the mount directory specified<br>       in that record is opened.  (These programs do not deal with the fact<br>       that mount IDs are not persistent.)<br><br>       The following shell session demonstrates the use of these two<br>       programs:<br><br>           $ <b>echo 'Can you please think about it?' &gt; cecilia.txt</b><br>           $ <b>./t_name_to_handle_at cecilia.txt &gt; fh</b><br>           $ <b>./t_open_by_handle_at &lt; fh</b><br>           open_by_handle_at: Operation not permitted<br>           $ <b>sudo ./t_open_by_handle_at &lt; fh      </b># Need CAP_SYS_ADMIN<br>           Read 31 bytes<br>           $ <b>rm cecilia.txt</b><br><br>       Now we delete and (quickly) re-create the file so that it has the<br>       same content and (by chance) the same inode.  Nevertheless,<br>       <b>open_by_handle_at</b>() recognizes that the original file referred to by<br>       the file handle no longer exists.<br><br>           $ <b>stat --printf=\"%i\\n\" cecilia.txt     </b># Display inode number<br>           4072121<br>           $ <b>rm cecilia.txt</b><br>           $ <b>echo 'Can you please think about it?' &gt; cecilia.txt</b><br>           $ <b>stat --printf=\"%i\\n\" cecilia.txt     </b># Check inode number<br>           4072121<br>           $ <b>sudo ./t_open_by_handle_at &lt; fh</b><br>           open_by_handle_at: Stale NFS file handle<br><br>   <b>Program source: t_name_to_handle_at.c</b><br><br>       #define _GNU_SOURCE<br>       #include &lt;sys/types.h&gt;<br>       #include &lt;sys/stat.h&gt;<br>       #include &lt;fcntl.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;unistd.h&gt;<br>       #include &lt;errno.h&gt;<br>       #include &lt;string.h&gt;<br><br>       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\<br>                               } while (0)<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           struct file_handle *fhp;<br>           int mount_id, fhsize, flags, dirfd, j;<br>           char *pathname;<br><br>           if (argc != 2) {<br>               fprintf(stderr, \"Usage: %s pathname\\n\", argv[0]);<br>               exit(EXIT_FAILURE);<br>           }<br><br>           pathname = argv[1];<br><br>           /* Allocate file_handle structure */<br><br>           fhsize = sizeof(*fhp);<br>           fhp = malloc(fhsize);<br>           if (fhp == NULL)<br>               errExit(\"malloc\");<br><br>           /* Make an initial call to name_to_handle_at() to discover<br>              the size required for file handle */<br><br>           dirfd = AT_FDCWD;           /* For name_to_handle_at() calls */<br>           flags = 0;                  /* For name_to_handle_at() calls */<br>           fhp-&gt;handle_bytes = 0;<br>           if (name_to_handle_at(dirfd, pathname, fhp,<br>                       &amp;mount_id, flags) != -1 || errno != EOVERFLOW) {<br>               fprintf(stderr, \"Unexpected result from name_to_handle_at()\\n\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           /* Reallocate file_handle structure with correct size */<br><br>           fhsize = sizeof(struct file_handle) + fhp-&gt;handle_bytes;<br>           fhp = realloc(fhp, fhsize);         /* Copies fhp-&gt;handle_bytes */<br>           if (fhp == NULL)<br>               errExit(\"realloc\");<br><br>           /* Get file handle from pathname supplied on command line */<br><br>           if (name_to_handle_at(dirfd, pathname, fhp, &amp;mount_id, flags) == -1)<br>               errExit(\"name_to_handle_at\");<br><br>           /* Write mount ID, file handle size, and file handle to stdout,<br>              for later reuse by t_open_by_handle_at.c */<br><br>           printf(\"%d\\n\", mount_id);<br>           printf(\"%d %d   \", fhp-&gt;handle_bytes, fhp-&gt;handle_type);<br>           for (j = 0; j &lt; fhp-&gt;handle_bytes; j++)<br>               printf(\" %02x\", fhp-&gt;f_handle[j]);<br>           printf(\"\\n\");<br><br>           exit(EXIT_SUCCESS);<br>       }<br><br>   <b>Program source: t_open_by_handle_at.c</b><br><br>       #define _GNU_SOURCE<br>       #include &lt;sys/types.h&gt;<br>       #include &lt;sys/stat.h&gt;<br>       #include &lt;fcntl.h&gt;<br>       #include &lt;limits.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;unistd.h&gt;<br>       #include &lt;string.h&gt;<br><br>       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\<br>                               } while (0)<br><br>       /* Scan /proc/self/mountinfo to find the line whose mount ID matches<br>          'mount_id'. (An easier way to do this is to install and use the<br>          'libmount' library provided by the 'util-linux' project.)<br>          Open the corresponding mount path and return the resulting file<br>          descriptor. */<br><br>       static int<br>       open_mount_path_by_id(int mount_id)<br>       {<br>           char *linep;<br>           size_t lsize;<br>           char mount_path[PATH_MAX];<br>           int mi_mount_id, found;<br>           ssize_t nread;<br>           FILE *fp;<br><br>           fp = fopen(\"/proc/self/mountinfo\", \"r\");<br>           if (fp == NULL)<br>               errExit(\"fopen\");<br><br>           found = 0;<br>           linep = NULL;<br>           while (!found) {<br>               nread = getline(&amp;linep, &amp;lsize, fp);<br>               if (nread == -1)<br>                   break;<br><br>               nread = sscanf(linep, \"%d %*d %*s %*s %s\",<br>                              &amp;mi_mount_id, mount_path);<br>               if (nread != 2) {<br>                   fprintf(stderr, \"Bad sscanf()\\n\");<br>                   exit(EXIT_FAILURE);<br>               }<br><br>               if (mi_mount_id == mount_id)<br>                   found = 1;<br>           }<br>           free(linep);<br><br>           fclose(fp);<br><br>           if (!found) {<br>               fprintf(stderr, \"Could not find mount point\\n\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           return open(mount_path, O_RDONLY);<br>       }<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           struct file_handle *fhp;<br>           int mount_id, fd, mount_fd, handle_bytes, j;<br>           ssize_t nread;<br>           char buf[1000];<br>       #define LINE_SIZE 100<br>           char line1[LINE_SIZE], line2[LINE_SIZE];<br>           char *nextp;<br><br>           if ((argc &gt; 1 &amp;&amp; strcmp(argv[1], \"--help\") == 0) || argc &gt; 2) {<br>               fprintf(stderr, \"Usage: %s [mount-path]\\n\", argv[0]);<br>               exit(EXIT_FAILURE);<br>           }<br><br>           /* Standard input contains mount ID and file handle information:<br><br>                Line 1: &lt;mount_id&gt;<br>                Line 2: &lt;handle_bytes&gt; &lt;handle_type&gt;   &lt;bytes of handle in hex&gt;<br>           */<br><br>           if ((fgets(line1, sizeof(line1), stdin) == NULL) ||<br>                  (fgets(line2, sizeof(line2), stdin) == NULL)) {<br>               fprintf(stderr, \"Missing mount_id / file handle\\n\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           mount_id = atoi(line1);<br><br>           handle_bytes = strtoul(line2, &amp;nextp, 0);<br><br>           /* Given handle_bytes, we can now allocate file_handle structure */<br><br>           fhp = malloc(sizeof(struct file_handle) + handle_bytes);<br>           if (fhp == NULL)<br>               errExit(\"malloc\");<br><br>           fhp-&gt;handle_bytes = handle_bytes;<br><br>           fhp-&gt;handle_type = strtoul(nextp, &amp;nextp, 0);<br><br>           for (j = 0; j &lt; fhp-&gt;handle_bytes; j++)<br>               fhp-&gt;f_handle[j] = strtoul(nextp, &amp;nextp, 16);<br><br>           /* Obtain file descriptor for mount point, either by opening<br>              the pathname specified on the command line, or by scanning<br>              /proc/self/mounts to find a mount that matches the 'mount_id'<br>              that we received from stdin. */<br><br>           if (argc &gt; 1)<br>               mount_fd = open(argv[1], O_RDONLY);<br>           else<br>               mount_fd = open_mount_path_by_id(mount_id);<br><br>           if (mount_fd == -1)<br>               errExit(\"opening mount fd\");<br><br>           /* Open file using handle and mount point */<br><br>           fd = open_by_handle_at(mount_fd, fhp, O_RDONLY);<br>           if (fd == -1)<br>               errExit(\"open_by_handle_at\");<br><br>           /* Try reading a few bytes from the file */<br><br>           nread = read(fd, buf, sizeof(buf));<br>           if (nread == -1)<br>               errExit(\"read\");<br><br>           printf(\"Read %zd bytes\\n\", nread);<br><br>           exit(EXIT_SUCCESS);<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       open(2), libblkid(3), blkid(8), findfs(8), mount(8)<br><br>       The <i>libblkid</i> and <i>libmount</i> documentation in the latest <i>util-linux</i><br>       release at &#10216;https://www.kernel.org/pub/linux/utils/util-linux/&#10217;<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2014-06-13             OPEN_BY_HANDLE_AT(2)</span><br></pre><br>"}