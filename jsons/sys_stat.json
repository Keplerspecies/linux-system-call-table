{"Man page": "<pre><br><span class=\"headline\">STAT(2)                   Linux Programmer's Manual                  STAT(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       stat, fstat, lstat, fstatat - get file status<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/types.h&gt;</b><br>       <b>#include &lt;sys/stat.h&gt;</b><br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>int stat(const char *</b><i>pathname</i><b>, struct stat *</b><i>buf</i><b>);</b><br>       <b>int fstat(int </b><i>fd</i><b>, struct stat *</b><i>buf</i><b>);</b><br>       <b>int lstat(const char *</b><i>pathname</i><b>, struct stat *</b><i>buf</i><b>);</b><br><br>       <b>#include &lt;fcntl.h&gt;           </b>/* Definition of AT_* constants */<br>       <b>#include &lt;sys/stat.h&gt;</b><br><br>       <b>int fstatat(int </b><i>dirfd</i><b>, const char *</b><i>pathname</i><b>, struct stat *</b><i>buf</i><b>,</b><br>                   <b>int </b><i>flags</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>lstat</b>():<br>           /* glibc 2.19 and earlier */ _BSD_SOURCE ||<br>           /* Since glibc 2.20 */_DEFAULT_SOURCE ||<br>           _XOPEN_SOURCE &gt;= 500 || _XOPEN_SOURCE &amp;&amp; _XOPEN_SOURCE_EXTENDED<br>           || /* Since glibc 2.10: */ _POSIX_C_SOURCE &gt;= 200112L<br><br>       <b>fstatat</b>():<br>           Since glibc 2.10:<br>               _XOPEN_SOURCE &gt;= 700 || _POSIX_C_SOURCE &gt;= 200809L<br>           Before glibc 2.10:<br>               _ATFILE_SOURCE<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       These functions return information about a file, in the buffer<br>       pointed to by <i>buf</i>.  No permissions are required on the file itself,<br>       but&#8212;in the case of <b>stat</b>(), <b>fstatat</b>(), and <b>lstat</b>()&#8212;execute (search)<br>       permission is required on all of the directories in <i>pathname</i> that<br>       lead to the file.<br><br>       <b>stat</b>() and <b>fstatat</b>() retrieve information about the file pointed to<br>       by <i>pathname</i>; the differences for <b>fstatat</b>() are described below.<br><br>       <b>lstat</b>() is identical to <b>stat</b>(), except that if <i>pathname</i> is a symbolic<br>       link, then it returns information about the link itself, not the file<br>       that it refers to.<br><br>       <b>fstat</b>() is identical to <b>stat</b>(), except that the file about which<br>       information is to be retrieved is specified by the file descriptor<br>       <i>fd</i>.<br><br>       All of these system calls return a <i>stat</i> structure, which contains the<br>       following fields:<br><br>           struct stat {<br>               dev_t     st_dev;         /* ID of device containing file */<br>               ino_t     st_ino;         /* inode number */<br>               mode_t    st_mode;        /* protection */<br>               nlink_t   st_nlink;       /* number of hard links */<br>               uid_t     st_uid;         /* user ID of owner */<br>               gid_t     st_gid;         /* group ID of owner */<br>               dev_t     st_rdev;        /* device ID (if special file) */<br>               off_t     st_size;        /* total size, in bytes */<br>               blksize_t st_blksize;     /* blocksize for filesystem I/O */<br>               blkcnt_t  st_blocks;      /* number of 512B blocks allocated */<br><br>               /* Since Linux 2.6, the kernel supports nanosecond<br>                  precision for the following timestamp fields.<br>                  For the details before Linux 2.6, see NOTES. */<br><br>               struct timespec st_atim;  /* time of last access */<br>               struct timespec st_mtim;  /* time of last modification */<br>               struct timespec st_ctim;  /* time of last status change */<br><br>           #define st_atime st_atim.tv_sec      /* Backward compatibility */<br>           #define st_mtime st_mtim.tv_sec<br>           #define st_ctime st_ctim.tv_sec<br>           };<br><br>       <i>Note:</i> the order of fields in the <i>stat</i> structure varies somewhat<br>       across architectures.  In addition, the definition above does not<br>       show the padding bytes that may be present between some fields on<br>       various architectures.  Consult the glibc and kernel source code if<br>       you need to know the details.<br><br>       <i>Note:</i> For performance and simplicity reasons, different fields in the<br>       <i>stat</i> structure may contain state information from different moments<br>       during the execution of the system call.  For example, if <i>st_mode</i> or<br>       <i>st_uid</i> is changed by another process by calling chmod(2) or chown(2),<br>       <b>stat</b>() might return the old <i>st_mode</i> together with the new <i>st_uid</i>, or<br>       the old <i>st_uid</i> together with the new <i>st_mode</i>.<br><br>       The <i>st_dev</i> field describes the device on which this file resides.<br>       (The major(3) and minor(3) macros may be useful to decompose the<br>       device ID in this field.)<br><br>       The <i>st_rdev</i> field describes the device that this file (inode)<br>       represents.<br><br>       The <i>st_size</i> field gives the size of the file (if it is a regular file<br>       or a symbolic link) in bytes.  The size of a symbolic link is the<br>       length of the pathname it contains, without a terminating null byte.<br><br>       The <i>st_blocks</i> field indicates the number of blocks allocated to the<br>       file, 512-byte units.  (This may be smaller than <i>st_size</i>/512 when the<br>       file has holes.)<br><br>       The <i>st_blksize</i> field gives the \"preferred\" blocksize for efficient<br>       filesystem I/O.  (Writing to a file in smaller chunks may cause an<br>       inefficient read-modify-rewrite.)<br><br>       Not all of the Linux filesystems implement all of the time fields.<br>       Some filesystem types allow mounting in such a way that file and/or<br>       directory accesses do not cause an update of the <i>st_atime</i> field.<br>       (See <i>noatime</i>, <i>nodiratime</i>, and <i>relatime</i> in mount(8), and related<br>       information in mount(2).)  In addition, <i>st_atime</i> is not updated if a<br>       file is opened with the <b>O_NOATIME</b>; see open(2).<br><br>       The field <i>st_atime</i> is changed by file accesses, for example, by<br>       execve(2), mknod(2), pipe(2), utime(2), and read(2) (of more than<br>       zero bytes).  Other routines, like mmap(2), may or may not update<br>       <i>st_atime</i>.<br><br>       The field <i>st_mtime</i> is changed by file modifications, for example, by<br>       mknod(2), truncate(2), utime(2), and write(2) (of more than zero<br>       bytes).  Moreover, <i>st_mtime</i> of a directory is changed by the creation<br>       or deletion of files in that directory.  The <i>st_mtime</i> field is <i>not</i><br>       changed for changes in owner, group, hard link count, or mode.<br><br>       The field <i>st_ctime</i> is changed by writing or by setting inode<br>       information (i.e., owner, group, link count, mode, etc.).<br><br>       POSIX refers to the <i>st_mode</i> bits corresponding to the mask <b>S_IFMT</b><br>       (see below) as the <i>file type</i>, the 12 bits corresponding to the mask<br>       07777 as the <i>file mode bits</i> and the least significant 9 bits (0777)<br>       as the <i>file permission bits</i>.<br><br>       The following mask values are defined for the file type of the<br>       <i>st_mode</i> field:<br><br>           <b>S_IFMT     </b>0170000   bit mask for the file type bit field<br><br>           <b>S_IFSOCK   </b>0140000   socket<br>           <b>S_IFLNK    </b>0120000   symbolic link<br>           <b>S_IFREG    </b>0100000   regular file<br>           <b>S_IFBLK    </b>0060000   block device<br>           <b>S_IFDIR    </b>0040000   directory<br>           <b>S_IFCHR    </b>0020000   character device<br>           <b>S_IFIFO    </b>0010000   FIFO<br><br>       Thus, to test for a regular file (for example), one could write:<br><br>           stat(pathname, &amp;sb);<br>           if ((sb.st_mode &amp; S_IFMT) == S_IFREG) {<br>               /* Handle regular file */<br>           }<br><br>       Because tests of the above form are common, additional macros are<br>       defined by POSIX to allow the test of the file type in <i>st_mode</i> to be<br>       written more concisely:<br><br>           <b>S_ISREG</b>(m)  is it a regular file?<br><br>           <b>S_ISDIR</b>(m)  directory?<br><br>           <b>S_ISCHR</b>(m)  character device?<br><br>           <b>S_ISBLK</b>(m)  block device?<br><br>           <b>S_ISFIFO</b>(m) FIFO (named pipe)?<br><br>           <b>S_ISLNK</b>(m)  symbolic link?  (Not in POSIX.1-1996.)<br><br>           <b>S_ISSOCK</b>(m) socket?  (Not in POSIX.1-1996.)<br><br>       The preceding code snippet could thus be rewritten as:<br><br>           stat(pathname, &amp;sb);<br>           if (S_ISREG(sb.st_mode)) {<br>               /* Handle regular file */<br>           }<br><br>       The definitions of most of the above file type test macros are<br>       provided if any of the following feature test macros is defined:<br>       <b>_BSD_SOURCE </b>(in glibc 2.19 and earlier), <b>_SVID_SOURCE </b>(in glibc 2.19<br>       and earlier), or <b>_DEFAULT_SOURCE </b>(in glibc 2.20 and later).  In<br>       addition, definitions of all of the above macros except <b>S_IFSOCK </b>and<br>       <b>S_ISSOCK</b>() are provided if <b>_XOPEN_SOURCE </b>is defined.  The definition<br>       of <b>S_IFSOCK </b>can also be exposed by defining <b>_XOPEN_SOURCE </b>with a<br>       value of 500 or greater.<br><br>       The definition of <b>S_ISSOCK</b>() is exposed if any of the following<br>       feature test macros is defined: <b>_BSD_SOURCE </b>(in glibc 2.19 and<br>       earlier), <b>_DEFAULT_SOURCE </b>(in glibc 2.20 and later), <b>_XOPEN_SOURCE</b><br>       with a value of 500 or greater, or <b>_POSIX_C_SOURCE </b>with a value of<br>       200112L or greater.<br><br>       The following mask values are defined for the file mode component of<br>       the <i>st_mode</i> field:<br><br>           <b>S_ISUID     </b>04000   set-user-ID bit<br>           <b>S_ISGID     </b>02000   set-group-ID bit (see below)<br>           <b>S_ISVTX     </b>01000   sticky bit (see below)<br><br>           <b>S_IRWXU     </b>00700   owner has read, write, and execute permission<br>           <b>S_IRUSR     </b>00400   owner has read permission<br>           <b>S_IWUSR     </b>00200   owner has write permission<br>           <b>S_IXUSR     </b>00100   owner has execute permission<br><br>           <b>S_IRWXG     </b>00070   group has read, write, and execute permission<br>           <b>S_IRGRP     </b>00040   group has read permission<br>           <b>S_IWGRP     </b>00020   group has write permission<br>           <b>S_IXGRP     </b>00010   group has execute permission<br><br>           <b>S_IRWXO     </b>00007   others (not in group) have read, write, and<br>                               execute permission<br>           <b>S_IROTH     </b>00004   others have read permission<br>           <b>S_IWOTH     </b>00002   others have write permission<br>           <b>S_IXOTH     </b>00001   others have execute permission<br><br>       The set-group-ID bit (<b>S_ISGID</b>) has several special uses.  For a<br>       directory, it indicates that BSD semantics is to be used for that<br>       directory: files created there inherit their group ID from the<br>       directory, not from the effective group ID of the creating process,<br>       and directories created there will also get the <b>S_ISGID </b>bit set.  For<br>       a file that does not have the group execution bit (<b>S_IXGRP</b>) set, the<br>       set-group-ID bit indicates mandatory file/record locking.<br><br>       The sticky bit (<b>S_ISVTX</b>) on a directory means that a file in that<br>       directory can be renamed or deleted only by the owner of the file, by<br>       the owner of the directory, and by a privileged process.<br><br>   <b>fstatat()</b><br>       The <b>fstatat</b>() system call operates in exactly the same way as <b>stat</b>(),<br>       except for the differences described here.<br><br>       If the pathname given in <i>pathname</i> is relative, then it is interpreted<br>       relative to the directory referred to by the file descriptor <i>dirfd</i><br>       (rather than relative to the current working directory of the calling<br>       process, as is done by <b>stat</b>() for a relative pathname).<br><br>       If <i>pathname</i> is relative and <i>dirfd</i> is the special value <b>AT_FDCWD</b>, then<br>       <i>pathname</i> is interpreted relative to the current working directory of<br>       the calling process (like <b>stat</b>()).<br><br>       If <i>pathname</i> is absolute, then <i>dirfd</i> is ignored.<br><br>       <i>flags</i> can either be 0, or include one or more of the following flags<br>       ORed:<br><br>       <b>AT_EMPTY_PATH </b>(since Linux 2.6.39)<br>              If <i>pathname</i> is an empty string, operate on the file referred<br>              to by <i>dirfd</i> (which may have been obtained using the open(2)<br>              <b>O_PATH </b>flag).  If <i>dirfd</i> is <b>AT_FDCWD</b>, the call operates on the<br>              current working directory.  In this case, <i>dirfd</i> can refer to<br>              any type of file, not just a directory.  This flag is Linux-<br>              specific; define <b>_GNU_SOURCE </b>to obtain its definition.<br><br>       <b>AT_NO_AUTOMOUNT </b>(since Linux 2.6.38)<br>              Don't automount the terminal (\"basename\") component of<br>              <i>pathname</i> if it is a directory that is an automount point.<br>              This allows the caller to gather attributes of an automount<br>              point (rather than the location it would mount).  This flag<br>              can be used in tools that scan directories to prevent mass-<br>              automounting of a directory of automount points.  The<br>              <b>AT_NO_AUTOMOUNT </b>flag has no effect if the mount point has<br>              already been mounted over.  This flag is Linux-specific;<br>              define <b>_GNU_SOURCE </b>to obtain its definition.<br><br>       <b>AT_SYMLINK_NOFOLLOW</b><br>              If <i>pathname</i> is a symbolic link, do not dereference it: instead<br>              return information about the link itself, like <b>lstat</b>().  (By<br>              default, <b>fstatat</b>() dereferences symbolic links, like <b>stat</b>().)<br><br>       See openat(2) for an explanation of the need for <b>fstatat</b>().<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, zero is returned.  On error, -1 is returned, and <i>errno</i> is<br>       set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EACCES </b>Search permission is denied for one of the directories in the<br>              path prefix of <i>pathname</i>.  (See also path_resolution(7).)<br><br>       <b>EBADF  </b><i>fd</i> is bad.<br><br>       <b>EFAULT </b>Bad address.<br><br>       <b>ELOOP  </b>Too many symbolic links encountered while traversing the path.<br><br>       <b>ENAMETOOLONG</b><br>              <i>pathname</i> is too long.<br><br>       <b>ENOENT </b>A component of <i>pathname</i> does not exist, or <i>pathname</i> is an<br>              empty string.<br><br>       <b>ENOMEM </b>Out of memory (i.e., kernel memory).<br><br>       <b>ENOTDIR</b><br>              A component of the path prefix of <i>pathname</i> is not a directory.<br><br>       <b>EOVERFLOW</b><br>              <i>pathname</i> or <i>fd</i> refers to a file whose size, inode number, or<br>              number of blocks cannot be represented in, respectively, the<br>              types <i>off_t</i>, <i>ino_t</i>, or <i>blkcnt_t</i>.  This error can occur when,<br>              for example, an application compiled on a 32-bit platform<br>              without <i>-D_FILE_OFFSET_BITS=64</i> calls <b>stat</b>() on a file whose<br>              size exceeds <i>(1&lt;&lt;31)-1</i> bytes.<br><br>       The following additional errors can occur for <b>fstatat</b>():<br><br>       <b>EBADF  </b><i>dirfd</i> is not a valid file descriptor.<br><br>       <b>EINVAL </b>Invalid flag specified in <i>flags</i>.<br><br>       <b>ENOTDIR</b><br>              <i>pathname</i> is relative and <i>dirfd</i> is a file descriptor referring<br>              to a file other than a directory.<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>fstatat</b>() was added to Linux in kernel 2.6.16; library support was<br>       added to glibc in version 2.4.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>stat</b>(), <b>fstat</b>(), <b>lstat</b>(): SVr4, 4.3BSD, POSIX.1-2001, POSIX.1.2008.<br><br>       <b>fstatat</b>(): POSIX.1-2008.<br><br>       According to POSIX.1-2001, <b>lstat</b>() on a symbolic link need return<br>       valid information only in the <i>st_size</i> field and the file type of the<br>       <i>st_mode</i> field of the <i>stat</i> structure.  POSIX.1-2008 tightens the<br>       specification, requiring <b>lstat</b>() to return valid information in all<br>       fields except the mode bits in <i>st_mode</i>.<br><br>       Use of the <i>st_blocks</i> and <i>st_blksize</i> fields may be less portable.<br>       (They were introduced in BSD.  The interpretation differs between<br>       systems, and possibly on a single system when NFS mounts are<br>       involved.)  If you need to obtain the definition of the <i>blkcnt_t</i> or<br>       <i>blksize_t</i> types from <i>&lt;sys/stat.h&gt;</i>, then define <b>_XOPEN_SOURCE </b>with the<br>       value 500 or greater (before including <i>any</i> header files).<br><br>       POSIX.1-1990 did not describe the <b>S_IFMT</b>, <b>S_IFSOCK</b>, <b>S_IFLNK</b>, <b>S_IFREG</b>,<br>       <b>S_IFBLK</b>, <b>S_IFDIR</b>, <b>S_IFCHR</b>, <b>S_IFIFO</b>, <b>S_ISVTX </b>constants, but instead<br>       demanded the use of the macros <b>S_ISDIR</b>(), and so on.  The <b>S_IF*</b><br>       constants are present in POSIX.1-2001 and later.<br><br>       The <b>S_ISLNK</b>() and <b>S_ISSOCK</b>() macros are not in POSIX.1-1996, but both<br>       are present in POSIX.1-2001; the former is from SVID 4, the latter<br>       from SUSv2.<br><br>       UNIX V7 (and later systems) had <b>S_IREAD</b>, <b>S_IWRITE</b>, <b>S_IEXEC</b>, where<br>       POSIX prescribes the synonyms <b>S_IRUSR</b>, <b>S_IWUSR</b>, <b>S_IXUSR</b>.<br><br>   <b>Other systems</b><br>       Values that have been (or are) in use on various systems:<br><br>       hex    name       ls   octal    description<br>       f000   S_IFMT          170000   mask for file type<br>       0000                   000000   SCO out-of-service inode; BSD<br>                                       unknown type; SVID-v2 and XPG2 have<br>                                       both 0 and 0100000 for ordinary file<br>       1000   S_IFIFO    p|   010000   FIFO (named pipe)<br>       2000   S_IFCHR    c    020000   character special (V7)<br>       3000   S_IFMPC         030000   multiplexed character special (V7)<br>       4000   S_IFDIR    d/   040000   directory (V7)<br>       5000   S_IFNAM         050000   XENIX named special file with two<br>                                       subtypes, distinguished by <i>st_rdev</i><br>                                       values 1, 2<br>       0001   S_INSEM    s    000001   XENIX semaphore subtype of IFNAM<br>       0002   S_INSHD    m    000002   XENIX shared data subtype of IFNAM<br>       6000   S_IFBLK    b    060000   block special (V7)<br>       7000   S_IFMPB         070000   multiplexed block special (V7)<br>       8000   S_IFREG    -    100000   regular (V7)<br>       9000   S_IFCMP         110000   VxFS compressed<br>       9000   S_IFNWK    n    110000   network special (HP-UX)<br>       a000   S_IFLNK    l@   120000   symbolic link (BSD)<br>       b000   S_IFSHAD        130000   Solaris shadow inode for ACL (not<br>                                       seen by user space)<br>       c000   S_IFSOCK   s=   140000   socket (BSD; also \"S_IFSOC\" on VxFS)<br>       d000   S_IFDOOR   D&gt;   150000   Solaris door<br>       e000   S_IFWHT    w%   160000   BSD whiteout (not used for inode)<br>       0200   S_ISVTX         001000   sticky bit: save swapped text even<br>                                       after use (V7)<br>                                       reserved (SVID-v2)<br>                                       On nondirectories: don't cache this<br>                                       file (SunOS)<br>                                       On directories: restricted deletion<br>                                       flag (SVID-v4.2)<br>       0400   S_ISGID         002000   set-group-ID on execution (V7)<br>                                       for directories: use BSD semantics<br>                                       for propagation of GID<br><br>       0400   S_ENFMT         002000   System V file locking enforcement<br>                                       (shared with S_ISGID)<br>       0800   S_ISUID         004000   set-user-ID on execution (V7)<br>       0800   S_CDF           004000   directory is a context dependent<br>                                       file (HP-UX)<br><br>       A sticky command appeared in Version 32V AT&amp;T UNIX.<br></pre><br><h2>NOTES  </h2><pre><br>       On Linux, <b>lstat</b>() will generally not trigger automounter action,<br>       whereas <b>stat</b>() will (but see fstatat(2)).<br><br>       For most files under the <i>/proc</i> directory, <b>stat</b>() does not return the<br>       file size in the <i>st_size</i> field; instead the field is returned with<br>       the value 0.<br><br>   <b>Timestamp fields</b><br>       Older kernels and older standards did not support nanosecond<br>       timestamp fields.  Instead, there were three timestamp fields&#8212;<br>       <i>st_atime</i>, <i>st_mtime</i>, and <i>st_ctime</i>&#8212;typed as <i>time_t</i> that recorded<br>       timestamps with one-second precision.<br><br>       Since kernel 2.5.48, the <i>stat</i> structure supports nanosecond<br>       resolution for the three file timestamp fields.  The nanosecond<br>       components of each timestamp are available via names of the form<br>       <i>st_atim.tv_nsec</i> if the <b>_BSD_SOURCE </b>or <b>_SVID_SOURCE </b>feature test macro<br>       is defined.  Nanosecond timestamps are nowadays standardized,<br>       starting with POSIX.1-2008, and, starting with version 2.12, glibc<br>       also exposes the nanosecond component names if <b>_POSIX_C_SOURCE </b>is<br>       defined with the value 200809L or greater, or <b>_XOPEN_SOURCE </b>is<br>       defined with the value 700 or greater.  If none of the aforementioned<br>       macros are defined, then the nanosecond values are exposed with names<br>       of the form <i>st_atimensec</i>.<br><br>       Nanosecond timestamps are supported on XFS, JFS, Btrfs, and ext4<br>       (since Linux 2.6.23).  Nanosecond timestamps are not supported in<br>       ext2, ext3, and Reiserfs.  On filesystems that do not support<br>       subsecond timestamps, the nanosecond fields are returned with the<br>       value 0.<br><br>   <b>C library/kernel differences</b><br>       Over time, increases in the size of the <i>stat</i> structure have led to<br>       three successive versions of <b>stat</b>(): <i>sys_stat</i>() (slot <i>__NR_oldstat</i>),<br>       <i>sys_newstat</i>() (slot <i>__NR_stat</i>), and <i>sys_stat64()</i> (slot <i>__NR_stat64</i>)<br>       on 32-bit platforms such as i386.  The first two versions were<br>       already present in Linux 1.0 (albeit with different names); the last<br>       was added in Linux 2.4.  Similar remarks apply for <b>fstat</b>() and<br>       <b>lstat</b>().<br><br>       The kernel-internal versions of the <i>stat</i> structure dealt with by the<br>       different versions are, respectively:<br><br>              <i>__old_kernel_stat</i><br>                     The original structure, with rather narrow fields, and<br>                     no padding.<br><br>              <i>stat</i>   Larger <i>st_ino</i> field and padding added to various parts<br>                     of the structure to allow for future expansion.<br><br>              <i>stat64</i> Even larger <i>st_ino</i> field, larger <i>st_uid</i> and <i>st_gid</i><br>                     fields to accommodate the Linux-2.4 expansion of UIDs<br>                     and GIDs to 32 bits, and various other enlarged fields<br>                     and further padding in the structure.  (Various padding<br>                     bytes were eventually consumed in Linux 2.6, with the<br>                     advent of 32-bit device IDs and nanosecond components<br>                     for the timestamp fields.)<br><br>       The glibc <b>stat</b>() wrapper function hides these details from<br>       applications, invoking the most recent version of the system call<br>       provided by the kernel, and repacking the returned information if<br>       required for old binaries.<br><br>       On modern 64-bit systems, life is simpler: there is a single <b>stat</b>()<br>       system call and the kernel deals with a <i>stat</i> structure that contains<br>       fields of a sufficient size.<br><br>       The underlying system call employed by the glibc <b>fstatat</b>() wrapper<br>       function is actually called <b>fstatat64</b>() or, on some architectures,<br>       <b>newfstatat</b>().<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The following program calls <b>stat</b>() and displays selected fields in<br>       the returned <i>stat</i> structure.<br><br>       #include &lt;sys/types.h&gt;<br>       #include &lt;sys/stat.h&gt;<br>       #include &lt;time.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;stdlib.h&gt;<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           struct stat sb;<br><br>           if (argc != 2) {<br>               fprintf(stderr, \"Usage: %s &lt;pathname&gt;\\n\", argv[0]);<br>               exit(EXIT_FAILURE);<br>           }<br><br>           if (stat(argv[1], &amp;sb) == -1) {<br>               perror(\"stat\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           printf(\"File type:                \");<br><br>           switch (sb.st_mode &amp; S_IFMT) {<br>           case S_IFBLK:  printf(\"block device\\n\");            break;<br>           case S_IFCHR:  printf(\"character device\\n\");        break;<br>           case S_IFDIR:  printf(\"directory\\n\");               break;<br>           case S_IFIFO:  printf(\"FIFO/pipe\\n\");               break;<br>           case S_IFLNK:  printf(\"symlink\\n\");                 break;<br>           case S_IFREG:  printf(\"regular file\\n\");            break;<br>           case S_IFSOCK: printf(\"socket\\n\");                  break;<br>           default:       printf(\"unknown?\\n\");                break;<br>           }<br><br>           printf(\"I-node number:            %ld\\n\", (long) sb.st_ino);<br><br>           printf(\"Mode:                     %lo (octal)\\n\",<br>                   (unsigned long) sb.st_mode);<br><br>           printf(\"Link count:               %ld\\n\", (long) sb.st_nlink);<br>           printf(\"Ownership:                UID=%ld   GID=%ld\\n\",<br>                   (long) sb.st_uid, (long) sb.st_gid);<br><br>           printf(\"Preferred I/O block size: %ld bytes\\n\",<br>                   (long) sb.st_blksize);<br>           printf(\"File size:                %lld bytes\\n\",<br>                   (long long) sb.st_size);<br>           printf(\"Blocks allocated:         %lld\\n\",<br>                   (long long) sb.st_blocks);<br><br>           printf(\"Last status change:       %s\", ctime(&amp;sb.st_ctime));<br>           printf(\"Last file access:         %s\", ctime(&amp;sb.st_atime));<br>           printf(\"Last file modification:   %s\", ctime(&amp;sb.st_mtime));<br><br>           exit(EXIT_SUCCESS);<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       ls(1), stat(1), access(2), chmod(2), chown(2), readlink(2), utime(2),<br>       capabilities(7), symlink(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                          STAT(2)</span><br></pre><br>"}