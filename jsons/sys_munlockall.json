{"Man page": "<pre><br><span class=\"headline\">MLOCK(2)                  Linux Programmer's Manual                 MLOCK(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       mlock, munlock, mlockall, munlockall - lock and unlock memory<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/mman.h&gt;</b><br><br>       <b>int mlock(const void *</b><i>addr</i><b>, size_t </b><i>len</i><b>);</b><br>       <b>int munlock(const void *</b><i>addr</i><b>, size_t </b><i>len</i><b>);</b><br><br>       <b>int mlockall(int </b><i>flags</i><b>);</b><br>       <b>int munlockall(void);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>mlock</b>() and <b>mlockall</b>() respectively lock part or all of the calling<br>       process's virtual address space into RAM, preventing that memory from<br>       being paged to the swap area.  <b>munlock</b>() and <b>munlockall</b>() perform the<br>       converse operation, respectively unlocking part or all of the calling<br>       process's virtual address space, so that pages in the specified<br>       virtual address range may once more to be swapped out if required by<br>       the kernel memory manager.  Memory locking and unlocking are<br>       performed in units of whole pages.<br><br>   <b>mlock() and munlock()</b><br>       <b>mlock</b>() locks pages in the address range starting at <i>addr</i> and<br>       continuing for <i>len</i> bytes.  All pages that contain a part of the<br>       specified address range are guaranteed to be resident in RAM when the<br>       call returns successfully; the pages are guaranteed to stay in RAM<br>       until later unlocked.<br><br>       <b>munlock</b>() unlocks pages in the address range starting at <i>addr</i> and<br>       continuing for <i>len</i> bytes.  After this call, all pages that contain a<br>       part of the specified memory range can be moved to external swap<br>       space again by the kernel.<br><br>   <b>mlockall() and munlockall()</b><br>       <b>mlockall</b>() locks all pages mapped into the address space of the<br>       calling process.  This includes the pages of the code, data and stack<br>       segment, as well as shared libraries, user space kernel data, shared<br>       memory, and memory-mapped files.  All mapped pages are guaranteed to<br>       be resident in RAM when the call returns successfully; the pages are<br>       guaranteed to stay in RAM until later unlocked.<br><br>       The <i>flags</i> argument is constructed as the bitwise OR of one or more of<br>       the following constants:<br><br>       <b>MCL_CURRENT </b>Lock all pages which are currently mapped into the<br>                   address space of the process.<br><br>       <b>MCL_FUTURE  </b>Lock all pages which will become mapped into the address<br>                   space of the process in the future.  These could be for<br>                   instance new pages required by a growing heap and stack<br>                   as well as new memory-mapped files or shared memory<br>                   regions.<br><br>       If <b>MCL_FUTURE </b>has been specified, then a later system call (e.g.,<br>       mmap(2), sbrk(2), malloc(3)), may fail if it would cause the number<br>       of locked bytes to exceed the permitted maximum (see below).  In the<br>       same circumstances, stack growth may likewise fail: the kernel will<br>       deny stack expansion and deliver a <b>SIGSEGV </b>signal to the process.<br><br>       <b>munlockall</b>() unlocks all pages mapped into the address space of the<br>       calling process.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, these system calls return 0.  On error, -1 is returned,<br>       <i>errno</i> is set appropriately, and no changes are made to any locks in<br>       the address space of the process.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>ENOMEM </b>(Linux 2.6.9 and later) the caller had a nonzero<br>              <b>RLIMIT_MEMLOCK </b>soft resource limit, but tried to lock more<br>              memory than the limit permitted.  This limit is not enforced<br>              if the process is privileged (<b>CAP_IPC_LOCK</b>).<br><br>       <b>ENOMEM </b>(Linux 2.4 and earlier) the calling process tried to lock more<br>              than half of RAM.<br><br>       <b>EPERM  </b>The caller is not privileged, but needs privilege<br>              (<b>CAP_IPC_LOCK</b>) to perform the requested operation.<br><br>       For <b>mlock</b>() and <b>munlock</b>():<br><br>       <b>EAGAIN </b>Some or all of the specified address range could not be<br>              locked.<br><br>       <b>EINVAL </b>The result of the addition <i>start</i>+<i>len</i> was less than <i>start</i><br>              (e.g., the addition may have resulted in an overflow).<br><br>       <b>EINVAL </b>(Not on Linux) <i>addr</i> was not a multiple of the page size.<br><br>       <b>ENOMEM </b>Some of the specified address range does not correspond to<br>              mapped pages in the address space of the process.<br><br>       <b>ENOMEM </b>Locking or unlocking a region would result in the total number<br>              of mappings with distinct attributes (e.g., locked versus<br>              unlocked) exceeding the allowed maximum.  (For example,<br>              unlocking a range in the middle of a currently locked mapping<br>              would result in three mappings: two locked mappings at each<br>              end and an unlocked mapping in the middle.)<br><br>       For <b>mlockall</b>():<br><br>       <b>EINVAL </b>Unknown <i>flags</i> were specified.<br><br>       For <b>munlockall</b>():<br><br>       <b>EPERM  </b>(Linux 2.6.8 and earlier) The caller was not privileged<br>              (<b>CAP_IPC_LOCK</b>).<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008, SVr4.<br></pre><br><h2>AVAILABILITY  </h2><pre><br>       On POSIX systems on which <b>mlock</b>() and <b>munlock</b>() are available,<br>       <b>_POSIX_MEMLOCK_RANGE </b>is defined in <i>&lt;unistd.h&gt;</i> and the number of bytes<br>       in a page can be determined from the constant <b>PAGESIZE </b>(if defined)<br>       in <i>&lt;limits.h&gt;</i> or by calling <i>sysconf(_SC_PAGESIZE)</i>.<br><br>       On POSIX systems on which <b>mlockall</b>() and <b>munlockall</b>() are available,<br>       <b>_POSIX_MEMLOCK </b>is defined in <i>&lt;unistd.h&gt;</i> to a value greater than 0.<br>       (See also sysconf(3).)<br></pre><br><h2>NOTES  </h2><pre><br>       Memory locking has two main applications: real-time algorithms and<br>       high-security data processing.  Real-time applications require<br>       deterministic timing, and, like scheduling, paging is one major cause<br>       of unexpected program execution delays.  Real-time applications will<br>       usually also switch to a real-time scheduler with<br>       sched_setscheduler(2).  Cryptographic security software often handles<br>       critical bytes like passwords or secret keys as data structures.  As<br>       a result of paging, these secrets could be transferred onto a<br>       persistent swap store medium, where they might be accessible to the<br>       enemy long after the security software has erased the secrets in RAM<br>       and terminated.  (But be aware that the suspend mode on laptops and<br>       some desktop computers will save a copy of the system's RAM to disk,<br>       regardless of memory locks.)<br><br>       Real-time processes that are using <b>mlockall</b>() to prevent delays on<br>       page faults should reserve enough locked stack pages before entering<br>       the time-critical section, so that no page fault can be caused by<br>       function calls.  This can be achieved by calling a function that<br>       allocates a sufficiently large automatic variable (an array) and<br>       writes to the memory occupied by this array in order to touch these<br>       stack pages.  This way, enough pages will be mapped for the stack and<br>       can be locked into RAM.  The dummy writes ensure that not even copy-<br>       on-write page faults can occur in the critical section.<br><br>       Memory locks are not inherited by a child created via fork(2) and are<br>       automatically removed (unlocked) during an execve(2) or when the<br>       process terminates.  The <b>mlockall</b>() <b>MCL_FUTURE </b>setting is not<br>       inherited by a child created via fork(2) and is cleared during an<br>       execve(2).<br><br>       The memory lock on an address range is automatically removed if the<br>       address range is unmapped via munmap(2).<br><br>       Memory locks do not stack, that is, pages which have been locked<br>       several times by calls to <b>mlock</b>() or <b>mlockall</b>() will be unlocked by a<br>       single call to <b>munlock</b>() for the corresponding range or by<br>       <b>munlockall</b>().  Pages which are mapped to several locations or by<br>       several processes stay locked into RAM as long as they are locked at<br>       least at one location or by at least one process.<br><br>   <b>Linux notes</b><br>       Under Linux, <b>mlock</b>() and <b>munlock</b>() automatically round <i>addr</i> down to<br>       the nearest page boundary.  However, POSIX.1 allows an implementation<br>       to require that <i>addr</i> is page aligned, so portable applications should<br>       ensure this.<br><br>       The <i>VmLck</i> field of the Linux-specific <i>/proc/PID/status</i> file shows how<br>       many kilobytes of memory the process with ID <i>PID</i> has locked using<br>       <b>mlock</b>(), <b>mlockall</b>(), and mmap(2) <b>MAP_LOCKED</b>.<br><br>   <b>Limits and permissions</b><br>       In Linux 2.6.8 and earlier, a process must be privileged<br>       (<b>CAP_IPC_LOCK</b>) in order to lock memory and the <b>RLIMIT_MEMLOCK </b>soft<br>       resource limit defines a limit on how much memory the process may<br>       lock.<br><br>       Since Linux 2.6.9, no limits are placed on the amount of memory that<br>       a privileged process can lock and the <b>RLIMIT_MEMLOCK </b>soft resource<br>       limit instead defines a limit on how much memory an unprivileged<br>       process may lock.<br></pre><br><h2>BUGS  </h2><pre><br>       In the 2.4 series Linux kernels up to and including 2.4.17, a bug<br>       caused the <b>mlockall</b>() <b>MCL_FUTURE </b>flag to be inherited across a<br>       fork(2).  This was rectified in kernel 2.4.18.<br><br>       Since kernel 2.6.9, if a privileged process calls<br>       <i>mlockall(MCL_FUTURE)</i> and later drops privileges (loses the<br>       <b>CAP_IPC_LOCK </b>capability by, for example, setting its effective UID to<br>       a nonzero value), then subsequent memory allocations (e.g., mmap(2),<br>       brk(2)) will fail if the <b>RLIMIT_MEMLOCK </b>resource limit is<br>       encountered.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       mmap(2), setrlimit(2), shmctl(2), sysconf(3), proc(5),<br>       capabilities(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                         MLOCK(2)</span><br></pre><br>"}