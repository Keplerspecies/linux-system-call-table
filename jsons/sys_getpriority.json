{"Man page": "<pre><br><span class=\"headline\">GETPRIORITY(2)            Linux Programmer's Manual           GETPRIORITY(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       getpriority, setpriority - get/set program scheduling priority<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/time.h&gt;</b><br>       <b>#include &lt;sys/resource.h&gt;</b><br><br>       <b>int getpriority(int </b><i>which</i><b>, id_t </b><i>who</i><b>);</b><br>       <b>int setpriority(int </b><i>which</i><b>, id_t </b><i>who</i><b>, int </b><i>prio</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The scheduling priority of the process, process group, or user, as<br>       indicated by <i>which</i> and <i>who</i> is obtained with the <b>getpriority</b>() call<br>       and set with the <b>setpriority</b>() call.<br><br>       The value <i>which</i> is one of <b>PRIO_PROCESS</b>, <b>PRIO_PGRP</b>, or <b>PRIO_USER</b>, and<br>       <i>who</i> is interpreted relative to <i>which</i> (a process identifier for<br>       <b>PRIO_PROCESS</b>, process group identifier for <b>PRIO_PGRP</b>, and a user ID<br>       for <b>PRIO_USER</b>).  A zero value for <i>who</i> denotes (respectively) the<br>       calling process, the process group of the calling process, or the<br>       real user ID of the calling process.  <i>Prio</i> is a value in the range<br>       -20 to 19 (but see the Notes below).  The default priority is 0;<br>       lower priorities cause more favorable scheduling.<br><br>       The <b>getpriority</b>() call returns the highest priority (lowest numerical<br>       value) enjoyed by any of the specified processes.  The <b>setpriority</b>()<br>       call sets the priorities of all of the specified processes to the<br>       specified value.  Only the superuser may lower priorities.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       Since <b>getpriority</b>() can legitimately return the value -1, it is<br>       necessary to clear the external variable <i>errno</i> prior to the call,<br>       then check it afterward to determine if -1 is an error or a<br>       legitimate value.  The <b>setpriority</b>() call returns 0 if there is no<br>       error, or -1 if there is.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EINVAL </b><i>which</i> was not one of <b>PRIO_PROCESS</b>, <b>PRIO_PGRP</b>, or <b>PRIO_USER</b>.<br><br>       <b>ESRCH  </b>No process was located using the <i>which</i> and <i>who</i> values<br>              specified.<br><br>       In addition to the errors indicated above, <b>setpriority</b>() may fail if:<br><br>       <b>EACCES </b>The caller attempted to lower a process priority, but did not<br>              have the required privilege (on Linux: did not have the<br>              <b>CAP_SYS_NICE </b>capability).  Since Linux 2.6.12, this error<br>              occurs only if the caller attempts to set a process priority<br>              outside the range of the <b>RLIMIT_NICE </b>soft resource limit of<br>              the target process; see getrlimit(2) for details.<br><br>       <b>EPERM  </b>A process was located, but its effective user ID did not match<br>              either the effective or the real user ID of the caller, and<br>              was not privileged (on Linux: did not have the <b>CAP_SYS_NICE</b><br>              capability).  But see NOTES below.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (these interfaces first<br>       appeared in 4.2BSD).<br></pre><br><h2>NOTES  </h2><pre><br>       A child created by fork(2) inherits its parent's nice value.  The<br>       nice value is preserved across execve(2).<br><br>       The degree to which their relative nice value affects the scheduling<br>       of processes varies across UNIX systems, and, on Linux, across kernel<br>       versions.  Starting with kernel 2.6.23, Linux adopted an algorithm<br>       that causes relative differences in nice values to have a much<br>       stronger effect.  This causes very low nice values (+19) to truly<br>       provide little CPU to a process whenever there is any other higher<br>       priority load on the system, and makes high nice values (-20) deliver<br>       most of the CPU to applications that require it (e.g., some audio<br>       applications).<br><br>       The details on the condition for <b>EPERM </b>depend on the system.  The<br>       above description is what POSIX.1-2001 says, and seems to be followed<br>       on all System V-like systems.  Linux kernels before 2.6.12 required<br>       the real or effective user ID of the caller to match the real user of<br>       the process <i>who</i> (instead of its effective user ID).  Linux 2.6.12 and<br>       later require the effective user ID of the caller to match the real<br>       or effective user ID of the process <i>who</i>.  All BSD-like systems (SunOS<br>       4.1.3, Ultrix 4.2, 4.3BSD, FreeBSD 4.3, OpenBSD-2.5, ...) behave in<br>       the same manner as Linux 2.6.12 and later.<br><br>       The actual priority range varies between kernel versions.  Linux<br>       before 1.3.36 had -infinity..15.  Since kernel 1.3.43, Linux has the<br>       range -20..19.  On some other systems, the range of nice values is<br>       -20..20.<br><br>       Including <i>&lt;sys/time.h&gt;</i> is not required these days, but increases<br>       portability.  (Indeed, <i>&lt;sys/resource.h&gt;</i> defines the <i>rusage</i> structure<br>       with fields of type <i>struct timeval</i> defined in <i>&lt;sys/time.h&gt;</i>.)<br><br>   <b>C library/kernel differences</b><br>       Within the kernel, nice values are actually represented using the<br>       range 40..1 (since negative numbers are error codes) and these are<br>       the values employed by the <b>setpriority</b>() and <b>getpriority</b>() system<br>       calls.  The glibc wrapper functions for these system calls handle the<br>       translations between the user-land and kernel representations of the<br>       nice value according to the formula <i>unice = 20 - knice</i>.  (Thus, the<br>       kernel's 40..1 range corresponds to the range -20..19 as seen by user<br>       space.)<br></pre><br><h2>BUGS  </h2><pre><br>       According to POSIX, the nice value is a per-process setting.<br>       However, under the current Linux/NPTL implementation of POSIX<br>       threads, the nice value is a per-thread attribute: different threads<br>       in the same process can have different nice values.  Portable<br>       applications should avoid relying on the Linux behavior, which may be<br>       made standards conformant in the future.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       nice(1), renice(1), fork(2), capabilities(7), sched(7)<br><br>       <i>Documentation/scheduler/sched-nice-design.txt</i> in the Linux kernel<br>       source tree (since Linux 2.6.23)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                   GETPRIORITY(2)</span><br></pre><br>"}