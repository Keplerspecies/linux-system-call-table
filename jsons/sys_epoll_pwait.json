{"Man page": "<pre><br><span class=\"headline\">EPOLL_WAIT(2)             Linux Programmer's Manual            EPOLL_WAIT(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       epoll_wait,  epoll_pwait  -  wait  for  an I/O event on an epoll file<br>       descriptor<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/epoll.h&gt;</b><br><br>       <b>int epoll_wait(int </b><i>epfd</i><b>, struct epoll_event *</b><i>events</i><b>,</b><br>                      <b>int </b><i>maxevents</i><b>, int </b><i>timeout</i><b>);</b><br>       <b>int epoll_pwait(int </b><i>epfd</i><b>, struct epoll_event *</b><i>events</i><b>,</b><br>                      <b>int </b><i>maxevents</i><b>, int </b><i>timeout</i><b>,</b><br>                      <b>const sigset_t *</b><i>sigmask</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>epoll_wait</b>() system call waits for events on the epoll(7)<br>       instance referred to by the file descriptor <i>epfd</i>.  The memory area<br>       pointed to by <i>events</i> will contain the events that will be available<br>       for the caller.  Up to <i>maxevents</i> are returned by <b>epoll_wait</b>().  The<br>       <i>maxevents</i> argument must be greater than zero.<br><br>       The <i>timeout</i> argument specifies the number of milliseconds that<br>       <b>epoll_wait</b>() will block.  The call will block until either:<br><br>       *  a file descriptor delivers an event;<br><br>       *  the call is interrupted by a signal handler; or<br><br>       *  the timeout expires.<br><br>       Note that the <i>timeout</i> interval will be rounded up to the system clock<br>       granularity, and kernel scheduling delays mean that the blocking<br>       interval may overrun by a small amount.  Specifying a <i>timeout</i> of -1<br>       causes <b>epoll_wait</b>() to block indefinitely, while specifying a <i>timeout</i><br>       equal to zero cause <b>epoll_wait</b>() to return immediately, even if no<br>       events are available.<br><br>       The <i>struct epoll_event</i> is defined as:<br><br>           typedef union epoll_data {<br>               void    *ptr;<br>               int      fd;<br>               uint32_t u32;<br>               uint64_t u64;<br>           } epoll_data_t;<br><br>           struct epoll_event {<br>               uint32_t     events;    /* Epoll events */<br>               epoll_data_t data;      /* User data variable */<br>           };<br><br>       The <i>data</i> of each returned structure will contain the same data the<br>       user set with an epoll_ctl(2) (<b>EPOLL_CTL_ADD</b>, <b>EPOLL_CTL_MOD</b>) while<br>       the <i>events</i> member will contain the returned event bit field.<br><br>   <b>epoll_pwait()</b><br>       The relationship between <b>epoll_wait</b>() and <b>epoll_pwait</b>() is analogous<br>       to the relationship between select(2) and pselect(2): like<br>       pselect(2), <b>epoll_pwait</b>() allows an application to safely wait until<br>       either a file descriptor becomes ready or until a signal is caught.<br><br>       The following <b>epoll_pwait</b>() call:<br><br>           ready = epoll_pwait(epfd, &amp;events, maxevents, timeout, &amp;sigmask);<br><br>       is equivalent to <i>atomically</i> executing the following calls:<br><br>           sigset_t origmask;<br><br>           pthread_sigmask(SIG_SETMASK, &amp;sigmask, &amp;origmask);<br>           ready = epoll_wait(epfd, &amp;events, maxevents, timeout);<br>           pthread_sigmask(SIG_SETMASK, &amp;origmask, NULL);<br><br>       The <i>sigmask</i> argument may be specified as NULL, in which case<br>       <b>epoll_pwait</b>() is equivalent to <b>epoll_wait</b>().<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       When successful, <b>epoll_wait</b>() returns the number of file descriptors<br>       ready for the requested I/O, or zero if no file descriptor became<br>       ready during the requested <i>timeout</i> milliseconds.  When an error<br>       occurs, <b>epoll_wait</b>() returns -1 and <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EBADF  </b><i>epfd</i> is not a valid file descriptor.<br><br>       <b>EFAULT </b>The memory area pointed to by <i>events</i> is not accessible with<br>              write permissions.<br><br>       <b>EINTR  </b>The call was interrupted by a signal handler before either (1)<br>              any of the requested events occurred or (2) the <i>timeout</i><br>              expired; see signal(7).<br><br>       <b>EINVAL </b><i>epfd</i> is not an <b>epoll </b>file descriptor, or <i>maxevents</i> is less<br>              than or equal to zero.<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>epoll_wait</b>() was added to the kernel in version 2.6.  Library support<br>       is provided in glibc starting with version 2.3.2.<br><br>       <b>epoll_pwait</b>() was added to Linux in kernel 2.6.19.  Library support<br>       is provided in glibc starting with version 2.6.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>epoll_wait</b>() is Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       While one thread is blocked in a call to <b>epoll_pwait</b>(), it is<br>       possible for another thread to add a file descriptor to the waited-<br>       upon <b>epoll </b>instance.  If the new file descriptor becomes ready, it<br>       will cause the <b>epoll_wait</b>() call to unblock.<br><br>       For a discussion of what may happen if a file descriptor in an <b>epoll</b><br>       instance being monitored by <b>epoll_wait</b>() is closed in another thread,<br>       see select(2).<br></pre><br><h2>BUGS  </h2><pre><br>       In kernels before 2.6.37, a <i>timeout</i> value larger than approximately<br>       <i>LONG_MAX / HZ</i> milliseconds is treated as -1 (i.e., infinity).  Thus,<br>       for example, on a system where the <i>sizeof(long)</i> is 4 and the kernel<br>       <i>HZ</i> value is 1000, this means that timeouts greater than 35.79 minutes<br>       are treated as infinity.<br><br>   <b>C library/kernel differences</b><br>       The raw <b>epoll_pwait</b>() system call has a sixth argument, <i>size_t</i><br>       <i>sigsetsize</i>, which specifies the size in bytes of the <i>sigmask</i><br>       argument.  The glibc <b>epoll_pwait</b>() wrapper function specifies this<br>       argument as a fixed value (equal to <i>sizeof(sigset_t)</i>).<br></pre><br><h2>SEE ALSO  </h2><pre><br>       epoll_create(2), epoll_ctl(2), epoll(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-05-07                    EPOLL_WAIT(2)</span><br></pre><br>"}