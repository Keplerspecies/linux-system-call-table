{"Man page": "<pre><br><span class=\"headline\">SIGALTSTACK(2)            Linux Programmer's Manual           SIGALTSTACK(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       sigaltstack - set and/or get signal stack context<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;signal.h&gt;</b><br><br>       <b>int sigaltstack(const stack_t *</b><i>ss</i><b>, stack_t *</b><i>oss</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>sigaltstack</b>():<br>           _BSD_SOURCE || _XOPEN_SOURCE &gt;= 500 ||<br>           _XOPEN_SOURCE &amp;&amp; _XOPEN_SOURCE_EXTENDED<br>           || /* Since glibc 2.12: */ _POSIX_C_SOURCE &gt;= 200809L<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>sigaltstack</b>() allows a process to define a new alternate signal stack<br>       and/or retrieve the state of an existing alternate signal stack.  An<br>       alternate signal stack is used during the execution of a signal<br>       handler if the establishment of that handler (see sigaction(2))<br>       requested it.<br><br>       The normal sequence of events for using an alternate signal stack is<br>       the following:<br><br>       1. Allocate an area of memory to be used for the alternate signal<br>          stack.<br><br>       2. Use <b>sigaltstack</b>() to inform the system of the existence and<br>          location of the alternate signal stack.<br><br>       3. When establishing a signal handler using sigaction(2), inform the<br>          system that the signal handler should be executed on the alternate<br>          signal stack by specifying the <b>SA_ONSTACK </b>flag.<br><br>       The <i>ss</i> argument is used to specify a new alternate signal stack,<br>       while the <i>oss</i> argument is used to retrieve information about the<br>       currently established signal stack.  If we are interested in<br>       performing just one of these tasks, then the other argument can be<br>       specified as NULL.  Each of these arguments is a structure of the<br>       following type:<br><br>           typedef struct {<br>               void  *ss_sp;     /* Base address of stack */<br>               int    ss_flags;  /* Flags */<br>               size_t ss_size;   /* Number of bytes in stack */<br>           } stack_t;<br><br>       To establish a new alternate signal stack, <i>ss.ss_flags</i> is set to<br>       zero, and <i>ss.ss_sp</i> and <i>ss.ss_size</i> specify the starting address and<br>       size of the stack.  The constant <b>SIGSTKSZ </b>is defined to be large<br>       enough to cover the usual size requirements for an alternate signal<br>       stack, and the constant <b>MINSIGSTKSZ </b>defines the minimum size required<br>       to execute a signal handler.<br><br>       When a signal handler is invoked on the alternate stack, the kernel<br>       automatically aligns the address given in <i>ss.ss_sp</i> to a suitable<br>       address boundary for the underlying hardware architecture.<br><br>       To disable an existing stack, specify <i>ss.ss_flags</i> as <b>SS_DISABLE</b>.  In<br>       this case, the remaining fields in <i>ss</i> are ignored.<br><br>       If <i>oss</i> is not NULL, then it is used to return information about the<br>       alternate signal stack which was in effect prior to the call to<br>       <b>sigaltstack</b>().  The <i>oss.ss_sp</i> and <i>oss.ss_size</i> fields return the<br>       starting address and size of that stack.  The <i>oss.ss_flags</i> may return<br>       either of the following values:<br><br>       <b>SS_ONSTACK</b><br>              The process is currently executing on the alternate signal<br>              stack.  (Note that it is not possible to change the alternate<br>              signal stack if the process is currently executing on it.)<br><br>       <b>SS_DISABLE</b><br>              The alternate signal stack is currently disabled.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       <b>sigaltstack</b>() returns 0 on success, or -1 on failure with <i>errno</i> set<br>       to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EFAULT </b>Either <i>ss</i> or <i>oss</i> is not NULL and points to an area outside of<br>              the process's address space.<br><br>       <b>EINVAL </b><i>ss</i> is not NULL and the <i>ss_flags</i> field contains a nonzero value<br>              other than <b>SS_DISABLE</b>.<br><br>       <b>ENOMEM </b>The specified size of the new alternate signal stack<br>              <i>ss.ss_size</i> was less than <b>MINSTKSZ</b>.<br><br>       <b>EPERM  </b>An attempt was made to change the alternate signal stack while<br>              it was active (i.e., the process was already executing on the<br>              current alternate signal stack).<br></pre><br><h2>ATTRIBUTES  </h2><pre><br>       For an explanation of the terms used in this section, see<br>       attributes(7).<br><br>       &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9516;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9516;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;<br>       &#9474;<b>Interface     </b>&#9474; <b>Attribute     </b>&#9474; <b>Value   </b>&#9474;<br>       &#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;<br>       &#9474;<b>sigaltstack</b>() &#9474; Thread safety &#9474; MT-Safe &#9474;<br>       &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9524;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9524;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2009, SUSv2, SVr4.<br></pre><br><h2>NOTES  </h2><pre><br>       The most common usage of an alternate signal stack is to handle the<br>       <b>SIGSEGV </b>signal that is generated if the space available for the<br>       normal process stack is exhausted: in this case, a signal handler for<br>       <b>SIGSEGV </b>cannot be invoked on the process stack; if we wish to handle<br>       it, we must use an alternate signal stack.<br><br>       Establishing an alternate signal stack is useful if a process expects<br>       that it may exhaust its standard stack.  This may occur, for example,<br>       because the stack grows so large that it encounters the upwardly<br>       growing heap, or it reaches a limit established by a call to<br>       <b>setrlimit(RLIMIT_STACK, &amp;rlim)</b>.  If the standard stack is exhausted,<br>       the kernel sends the process a <b>SIGSEGV </b>signal.  In these<br>       circumstances the only way to catch this signal is on an alternate<br>       signal stack.<br><br>       On most hardware architectures supported by Linux, stacks grow<br>       downward.  <b>sigaltstack</b>() automatically takes account of the direction<br>       of stack growth.<br><br>       Functions called from a signal handler executing on an alternate<br>       signal stack will also use the alternate signal stack.  (This also<br>       applies to any handlers invoked for other signals while the process<br>       is executing on the alternate signal stack.)  Unlike the standard<br>       stack, the system does not automatically extend the alternate signal<br>       stack.  Exceeding the allocated size of the alternate signal stack<br>       will lead to unpredictable results.<br><br>       A successful call to execve(2) removes any existing alternate signal<br>       stack.  A child process created via fork(2) inherits a copy of its<br>       parent's alternate signal stack settings.<br><br>       <b>sigaltstack</b>() supersedes the older <b>sigstack</b>() call.  For backward<br>       compatibility, glibc also provides <b>sigstack</b>().  All new applications<br>       should be written using <b>sigaltstack</b>().<br><br>   <b>History</b><br>       4.2BSD had a <b>sigstack</b>() system call.  It used a slightly different<br>       struct, and had the major disadvantage that the caller had to know<br>       the direction of stack growth.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The following code segment demonstrates the use of <b>sigaltstack</b>():<br><br>           stack_t ss;<br><br>           ss.ss_sp = malloc(SIGSTKSZ);<br>           if (ss.ss_sp == NULL)<br>               /* Handle error */;<br>           ss.ss_size = SIGSTKSZ;<br>           ss.ss_flags = 0;<br>           if (sigaltstack(&amp;ss, NULL) == -1)<br>               /* Handle error */;<br></pre><br><h2>SEE ALSO  </h2><pre><br>       execve(2), setrlimit(2), sigaction(2), siglongjmp(3), sigsetjmp(3),<br>       signal(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                   SIGALTSTACK(2)</span><br></pre><br>"}