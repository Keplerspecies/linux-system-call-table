{"Man page": "<pre><br><span class=\"headline\">DUP(2)                    Linux Programmer's Manual                   DUP(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       dup, dup2, dup3 - duplicate a file descriptor<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>int dup(int </b><i>oldfd</i><b>);</b><br>       <b>int dup2(int </b><i>oldfd</i><b>, int </b><i>newfd</i><b>);</b><br><br>       <b>#define _GNU_SOURCE             </b>/* See feature_test_macros(7) */<br>       <b>#include &lt;fcntl.h&gt;              </b>/* Obtain O_* constant definitions */<br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>int dup3(int </b><i>oldfd</i><b>, int </b><i>newfd</i><b>, int </b><i>flags</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>dup</b>() system call creates a copy of the file descriptor <i>oldfd</i>,<br>       using the lowest-numbered unused descriptor for the new descriptor.<br><br>       After a successful return, the old and new file descriptors may be<br>       used interchangeably.  They refer to the same open file description<br>       (see open(2)) and thus share file offset and file status flags; for<br>       example, if the file offset is modified by using lseek(2) on one of<br>       the descriptors, the offset is also changed for the other.<br><br>       The two descriptors do not share file descriptor flags (the close-on-<br>       exec flag).  The close-on-exec flag (<b>FD_CLOEXEC</b>; see fcntl(2)) for<br>       the duplicate descriptor is off.<br><br>   <b>dup2()</b><br>       The <b>dup2</b>() system call performs the same task as <b>dup</b>(), but instead<br>       of using the lowest-numbered unused file descriptor, it uses the<br>       descriptor number specified in <i>newfd</i>.  If the descriptor <i>newfd</i> was<br>       previously open, it is silently closed before being reused.<br><br>       The steps of closing and reusing the file descriptor <i>newfd</i> are<br>       performed <i>atomically</i>.  This is important, because trying to implement<br>       equivalent functionality using close(2) and <b>dup</b>() would be subject to<br>       race conditions, whereby <i>newfd</i> might be reused between the two steps.<br>       Such reuse could happen because the main program is interrupted by a<br>       signal handler that allocates a file descriptor, or because a<br>       parallel thread allocates a file descriptor.<br><br>       Note the following points:<br><br>       *  If <i>oldfd</i> is not a valid file descriptor, then the call fails, and<br>          <i>newfd</i> is not closed.<br><br>       *  If <i>oldfd</i> is a valid file descriptor, and <i>newfd</i> has the same value<br>          as <i>oldfd</i>, then <b>dup2</b>() does nothing, and returns <i>newfd</i>.<br><br>   <b>dup3()</b><br>       <b>dup3</b>() is the same as <b>dup2</b>(), except that:<br><br>       *  The caller can force the close-on-exec flag to be set for the new<br>          file descriptor by specifying <b>O_CLOEXEC </b>in <i>flags</i>.  See the<br>          description of the same flag in open(2) for reasons why this may<br>          be useful.<br><br>       *  If <i>oldfd</i> equals <i>newfd</i>, then <b>dup3</b>() fails with the error <b>EINVAL</b>.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, these system calls return the new descriptor.  On error,<br>       -1 is returned, and <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EBADF  </b><i>oldfd</i> isn't an open file descriptor.<br><br>       <b>EBADF  </b><i>newfd</i> is out of the allowed range for file descriptors (see<br>              the discussion of <b>RLIMIT_NOFILE </b>in getrlimit(2)).<br><br>       <b>EBUSY  </b>(Linux only) This may be returned by <b>dup2</b>() or <b>dup3</b>() during a<br>              race condition with open(2) and <b>dup</b>().<br><br>       <b>EINTR  </b>The <b>dup2</b>() or <b>dup3</b>() call was interrupted by a signal; see<br>              signal(7).<br><br>       <b>EINVAL </b>(<b>dup3</b>()) <i>flags</i> contain an invalid value.<br><br>       <b>EINVAL </b>(<b>dup3</b>()) <i>oldfd</i> was equal to <i>newfd</i>.<br><br>       <b>EMFILE </b>The process already has the maximum number of file descriptors<br>              open and tried to open a new one (see the discussion of<br>              <b>RLIMIT_NOFILE </b>in getrlimit(2)).<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>dup3</b>() was added to Linux in version 2.6.27; glibc support is<br>       available starting with version 2.9.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>dup</b>(), <b>dup2</b>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.<br><br>       <b>dup3</b>() is Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       The error returned by <b>dup2</b>() is different from that returned by<br>       <b>fcntl(</b>..., <b>F_DUPFD</b>, ...<b>)  </b>when <i>newfd</i> is out of range.  On some<br>       systems, <b>dup2</b>() also sometimes returns <b>EINVAL </b>like <b>F_DUPFD</b>.<br><br>       If <i>newfd</i> was open, any errors that would have been reported at<br>       close(2) time are lost.  If this is of concern, then&#8212;unless the<br>       program is single-threaded and does not allocate file descriptors in<br>       signal handlers&#8212;the correct approach is <i>not</i> to close <i>newfd</i> before<br>       calling <b>dup2</b>(), because of the race condition described above.<br>       Instead, code something like the following could be used:<br><br>           /* Obtain a duplicate of 'newfd' that can subsequently<br>              be used to check for close() errors; an EBADF error<br>              means that 'newfd' was not open. */<br><br>           tmpfd = dup(newfd);<br>           if (tmpfd == -1 &amp;&amp; errno != EBADF) {<br>               /* Handle unexpected dup() error */<br>           }<br><br>           /* Atomically duplicate 'oldfd' on 'newfd' */<br><br>           if (dup2(oldfd, newfd) == -1) {<br>               /* Handle dup2() error */<br>           }<br><br>           /* Now check for close() errors on the file originally<br>              referred to by 'newfd' */<br><br>           if (tmpfd != -1) {<br>               if (close(tmpfd) == -1) {<br>                   /* Handle errors from close */<br>               }<br>           }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       close(2), fcntl(2), open(2)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-08-08                           DUP(2)</span><br></pre><br>"}