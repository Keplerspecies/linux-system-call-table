{"Man page": "<pre><br><span class=\"headline\">TIMER_GETOVERRUN(2)       Linux Programmer's Manual      TIMER_GETOVERRUN(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       timer_getoverrun - get overrun count for a POSIX per-process timer<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;time.h&gt;</b><br><br>       <b>int timer_getoverrun(timer_t </b><i>timerid</i><b>);</b><br><br>       Link with <i>-lrt</i>.<br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>timer_getoverrun</b>(): _POSIX_C_SOURCE &gt;= 199309L<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>timer_getoverrun</b>() returns the \"overrun count\" for the timer referred<br>       to by <i>timerid</i>.  An application can use the overrun count to<br>       accurately calculate the number of timer expirations that would have<br>       occurred over a given time interval.  Timer overruns can occur both<br>       when receiving expiration notifications via signals (<b>SIGEV_SIGNAL</b>),<br>       and via threads (<b>SIGEV_THREAD</b>).<br><br>       When expiration notifications are delivered via a signal, overruns<br>       can occur as follows.  Regardless of whether or not a real-time<br>       signal is used for timer notifications, the system queues at most one<br>       signal per timer.  (This is the behavior specified by POSIX.1.  The<br>       alternative, queuing one signal for each timer expiration, could<br>       easily result in overflowing the allowed limits for queued signals on<br>       the system.)  Because of system scheduling delays, or because the<br>       signal may be temporarily blocked, there can be a delay between the<br>       time when the notification signal is generated and the time when it<br>       is delivered (e.g., caught by a signal handler) or accepted (e.g.,<br>       using sigwaitinfo(2)).  In this interval, further timer expirations<br>       may occur.  The timer overrun count is the number of additional timer<br>       expirations that occurred between the time when the signal was<br>       generated and when it was delivered or accepted.<br><br>       Timer overruns can also occur when expiration notifications are<br>       delivered via invocation of a thread, since there may be an arbitrary<br>       delay between an expiration of the timer and the invocation of the<br>       notification thread, and in that delay interval, additional timer<br>       expirations may occur.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>timer_getoverrun</b>() returns the overrun count of the<br>       specified timer; this count may be 0 if no overruns have occurred.<br>       On failure, -1 is returned, and <i>errno</i> is set to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EINVAL </b><i>timerid</i> is not a valid timer ID.<br></pre><br><h2>VERSIONS  </h2><pre><br>       This system call is available since Linux 2.6.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008.<br></pre><br><h2>NOTES  </h2><pre><br>       When timer notifications are delivered via signals (<b>SIGEV_SIGNAL</b>), on<br>       Linux it is also possible to obtain the overrun count via the<br>       <i>si_overrun</i> field of the <i>siginfo_t</i> structure (see sigaction(2)).  This<br>       allows an application to avoid the overhead of making a system call<br>       to obtain the overrun count, but is a nonportable extension to<br>       POSIX.1.<br><br>       POSIX.1 discusses timer overruns only in the context of timer<br>       notifications using signals.<br></pre><br><h2>BUGS  </h2><pre><br>       POSIX.1 specifies that if the timer overrun count is equal to or<br>       greater than an implementation-defined maximum, <b>DELAYTIMER_MAX</b>, then<br>       <b>timer_getoverrun</b>() should return <b>DELAYTIMER_MAX</b>.  However, Linux does<br>       not implement this feature: instead, if the timer overrun value<br>       exceeds the maximum representable integer, the counter cycles,<br>       starting once more from low values.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       See timer_create(2).<br></pre><br><h2>SEE ALSO  </h2><pre><br>       clock_gettime(2), sigaction(2), signalfd(2), sigwaitinfo(2),<br>       timer_create(2), timer_delete(2), timer_settime(2), signal(7),<br>       time(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-08-08              TIMER_GETOVERRUN(2)</span><br></pre><br>"}