{"Man page": "<pre><br><span class=\"headline\">BRK(2)                    Linux Programmer's Manual                   BRK(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       brk, sbrk - change data segment size<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>int brk(void *</b><i>addr</i><b>);</b><br><br>       <b>void *sbrk(intptr_t </b><i>increment</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>brk</b>(), <b>sbrk</b>():<br>           Since glibc 2.12:<br>               _BSD_SOURCE || _SVID_SOURCE ||<br>                   (_XOPEN_SOURCE &gt;= 500 ||<br>                       _XOPEN_SOURCE &amp;&amp; _XOPEN_SOURCE_EXTENDED) &amp;&amp;<br>                   !(_POSIX_C_SOURCE &gt;= 200112L || _XOPEN_SOURCE &gt;= 600)<br>           Before glibc 2.12:<br>               _BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE &gt;= 500 ||<br>               _XOPEN_SOURCE &amp;&amp; _XOPEN_SOURCE_EXTENDED<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>brk</b>() and <b>sbrk</b>() change the location of the <i>program break</i>, which<br>       defines the end of the process's data segment (i.e., the program<br>       break is the first location after the end of the uninitialized data<br>       segment).  Increasing the program break has the effect of allocating<br>       memory to the process; decreasing the break deallocates memory.<br><br>       <b>brk</b>() sets the end of the data segment to the value specified by<br>       <i>addr</i>, when that value is reasonable, the system has enough memory,<br>       and the process does not exceed its maximum data size (see<br>       setrlimit(2)).<br><br>       <b>sbrk</b>() increments the program's data space by <i>increment</i> bytes.<br>       Calling <b>sbrk</b>() with an <i>increment</i> of 0 can be used to find the current<br>       location of the program break.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>brk</b>() returns zero.  On error, -1 is returned, and <i>errno</i><br>       is set to <b>ENOMEM</b>.<br><br>       On success, <b>sbrk</b>() returns the previous program break.  (If the break<br>       was increased, then this value is a pointer to the start of the newly<br>       allocated memory).  On error, <i>(void *) -1</i> is returned, and <i>errno</i> is<br>       set to <b>ENOMEM</b>.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       4.3BSD; SUSv1, marked LEGACY in SUSv2, removed in POSIX.1-2001.<br></pre><br><h2>NOTES  </h2><pre><br>       Avoid using <b>brk</b>() and <b>sbrk</b>(): the malloc(3) memory allocation package<br>       is the portable and comfortable way of allocating memory.<br><br>       Various systems use various types for the argument of <b>sbrk</b>().  Common<br>       are <i>int</i>, <i>ssize_t</i>, <i>ptrdiff_t</i>, <i>intptr_t</i>.<br><br>   <b>C library/kernel differences</b><br>       The return value described above for <b>brk</b>() is the behavior provided<br>       by the glibc wrapper function for the Linux <b>brk</b>() system call.  (On<br>       most other implementations, the return value from <b>brk</b>() is the same;<br>       this return value was also specified in SUSv2.)  However, the actual<br>       Linux system call returns the new program break on success.  On<br>       failure, the system call returns the current break.  The glibc<br>       wrapper function does some work (i.e., checks whether the new break<br>       is less than <i>addr</i>) to provide the 0 and -1 return values described<br>       above.<br><br>       On Linux, <b>sbrk</b>() is implemented as a library function that uses the<br>       <b>brk</b>() system call, and does some internal bookkeeping so that it can<br>       return the old break value.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       execve(2), getrlimit(2), end(3), malloc(3)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                           BRK(2)</span><br></pre><br>"}