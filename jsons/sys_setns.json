{"Man page": "<pre><br><span class=\"headline\">SETNS(2)                  Linux Programmer's Manual                 SETNS(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       setns - reassociate thread with a namespace<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#define _GNU_SOURCE             </b>/* See feature_test_macros(7) */<br>       <b>#include &lt;sched.h&gt;</b><br><br>       <b>int setns(int </b><i>fd</i><b>, int </b><i>nstype</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       Given a file descriptor referring to a namespace, reassociate the<br>       calling thread with that namespace.<br><br>       The <i>fd</i> argument is a file descriptor referring to one of the<br>       namespace entries in a <i>/proc/[pid]/ns/</i> directory; see namespaces(7)<br>       for further information on <i>/proc/[pid]/ns/</i>.  The calling thread will<br>       be reassociated with the corresponding namespace, subject to any<br>       constraints imposed by the <i>nstype</i> argument.<br><br>       The <i>nstype</i> argument specifies which type of namespace the calling<br>       thread may be reassociated with.  This argument can have one of the<br>       following values:<br><br>       <b>0      </b>Allow any type of namespace to be joined.<br><br>       <b>CLONE_NEWIPC </b>(since Linux 3.0)<br>              <i>fd</i> must refer to an IPC namespace.<br><br>       <b>CLONE_NEWNET </b>(since Linux 3.0)<br>              <i>fd</i> must refer to a network namespace.<br><br>       <b>CLONE_NEWNS </b>(since Linux 3.8)<br>              <i>fd</i> must refer to a mount namespace.<br><br>       <b>CLONE_NEWPID </b>(since Linux 3.8)<br>              <i>fd</i> must refer to a descendant PID namespace.<br><br>       <b>CLONE_NEWUSER </b>(since Linux 3.8)<br>              <i>fd</i> must refer to a user namespace.<br><br>       <b>CLONE_NEWUTS </b>(since Linux 3.0)<br>              <i>fd</i> must refer to a UTS namespace.<br><br>       Specifying <i>nstype</i> as 0 suffices if the caller knows (or does not<br>       care) what type of namespace is referred to by <i>fd</i>.  Specifying a<br>       nonzero value for <i>nstype</i> is useful if the caller does not know what<br>       type of namespace is referred to by <i>fd</i> and wants to ensure that the<br>       namespace is of a particular type.  (The caller might not know the<br>       type of the namespace referred to by <i>fd</i> if the file descriptor was<br>       opened by another process and, for example, passed to the caller via<br>       a UNIX domain socket.)<br><br>       <b>CLONE_NEWPID </b>behaves somewhat differently from the other <i>nstype</i><br>       values: reassociating the calling thread with a PID namespace changes<br>       only the PID namespace that child processes of the caller will be<br>       created in; it does not change the PID namespace of the caller<br>       itself.  Reassociating with a PID namespace is allowed only if the<br>       PID namespace specified by <i>fd</i> is a descendant (child, grandchild,<br>       etc.)  of the PID namespace of the caller.  For further details on<br>       PID namespaces, see pid_namespaces(7).<br><br>       A process reassociating itself with a user namespace must have the<br>       <b>CAP_SYS_ADMIN </b>capability in the target user namespace.  Upon<br>       successfully joining a user namespace, a process is granted all<br>       capabilities in that namespace, regardless of its user and group IDs.<br>       A multithreaded process may not change user namespace with <b>setns</b>().<br>       It is not permitted to use <b>setns</b>() to reenter the caller's current<br>       user namespace.  This prevents a caller that has dropped capabilities<br>       from regaining those capabilities via a call to <b>setns</b>().  For<br>       security reasons, a process can't join a new user namespace if it is<br>       sharing filesystem-related attributes (the attributes whose sharing<br>       is controlled by the clone(2) <b>CLONE_FS </b>flag) with another process.<br>       For further details on user namespaces, see user_namespaces(7).<br><br>       A process may not be reassociated with a new mount namespace if it is<br>       multithreaded.  Changing the mount namespace requires that the caller<br>       possess both <b>CAP_SYS_CHROOT </b>and <b>CAP_SYS_ADMIN </b>capabilities in its own<br>       user namespace and <b>CAP_SYS_ADMIN </b>in the target mount namespace.  See<br>       user_namespaces(7) for details on the interaction of user namespaces<br>       and mount namespaces.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>setns</b>() returns 0.  On failure, -1 is returned and <i>errno</i><br>       is set to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EBADF  </b><i>fd</i> is not a valid file descriptor.<br><br>       <b>EINVAL </b><i>fd</i> refers to a namespace whose type does not match that<br>              specified in <i>nstype</i>.<br><br>       <b>EINVAL </b>There is problem with reassociating the thread with the<br>              specified namespace.<br><br>       <b>EINVAL </b>The caller tried to join an ancestor (parent, grandparent, and<br>              so on) PID namespace.<br><br>       <b>EINVAL </b>The caller attempted to join the user namespace in which it is<br>              already a member.<br><br>       <b>EINVAL </b>The caller shares filesystem (<b>CLONE_FS</b>) state (in particular,<br>              the root directory) with other processes and tried to join a<br>              new user namespace.<br><br>       <b>EINVAL </b>The caller is multithreaded and tried to join a new user<br>              namespace.<br><br>       <b>ENOMEM </b>Cannot allocate sufficient memory to change the specified<br>              namespace.<br><br>       <b>EPERM  </b>The calling thread did not have the required capability for<br>              this operation.<br></pre><br><h2>VERSIONS  </h2><pre><br>       The <b>setns</b>() system call first appeared in Linux in kernel 3.0;<br>       library support was added to glibc in version 2.14.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       The <b>setns</b>() system call is Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       Not all of the attributes that can be shared when a new thread is<br>       created using clone(2) can be changed using <b>setns</b>().<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The program below takes two or more arguments.  The first argument<br>       specifies the pathname of a namespace file in an existing<br>       <i>/proc/[pid]/ns/</i> directory.  The remaining arguments specify a command<br>       and its arguments.  The program opens the namespace file, joins that<br>       namespace using <b>setns</b>(), and executes the specified command inside<br>       that namespace.<br><br>       The following shell session demonstrates the use of this program<br>       (compiled as a binary named <i>ns_exec</i>) in conjunction with the<br>       <b>CLONE_NEWUTS </b>example program in the clone(2) man page (complied as a<br>       binary named <i>newuts</i>).<br><br>       We begin by executing the example program in clone(2) in the<br>       background.  That program creates a child in a separate UTS<br>       namespace.  The child changes the hostname in its namespace, and then<br>       both processes display the hostnames in their UTS namespaces, so that<br>       we can see that they are different.<br><br>           $ <b>su                   </b># Need privilege for namespace operations<br>           Password:<br>           # <b>./newuts bizarro &amp;</b><br>           [1] 3549<br>           clone() returned 3550<br>           uts.nodename in child:  bizarro<br>           uts.nodename in parent: antero<br>           # <b>uname -n             </b># Verify hostname in the shell<br>           antero<br><br>       We then run the program shown below, using it to execute a shell.<br>       Inside that shell, we verify that the hostname is the one set by the<br>       child created by the first program:<br><br>           # <b>./ns_exec /proc/3550/ns/uts /bin/bash</b><br>           # <b>uname -n             </b># Executed in shell started by ns_exec<br>           bizarro<br><br>   <b>Program source</b><br>       #define _GNU_SOURCE<br>       #include &lt;fcntl.h&gt;<br>       #include &lt;sched.h&gt;<br>       #include &lt;unistd.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;stdio.h&gt;<br><br>       #define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \\<br>                               } while (0)<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           int fd;<br><br>           if (argc &lt; 3) {<br>               fprintf(stderr, \"%s /proc/PID/ns/FILE cmd args...\\n\", argv[0]);<br>               exit(EXIT_FAILURE);<br>           }<br><br>           fd = open(argv[1], O_RDONLY);  /* Get descriptor for namespace */<br>           if (fd == -1)<br>               errExit(\"open\");<br><br>           if (setns(fd, 0) == -1)        /* Join that namespace */<br>               errExit(\"setns\");<br><br>           execvp(argv[2], &amp;argv[2]);     /* Execute a command in namespace */<br>           errExit(\"execvp\");<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       clone(2), fork(2), unshare(2), vfork(2), namespaces(7), unix(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-01-10                         SETNS(2)</span><br></pre><br>"}