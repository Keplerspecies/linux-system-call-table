{"Man page": "<pre><br><span class=\"headline\">TEE(2)                    Linux Programmer's Manual                   TEE(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       tee - duplicating pipe content<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#define _GNU_SOURCE         </b>/* See feature_test_macros(7) */<br>       <b>#include &lt;fcntl.h&gt;</b><br><br>       <b>ssize_t tee(int </b><i>fd_in</i><b>, int </b><i>fd_out</i><b>, size_t </b><i>len</i><b>, unsigned int </b><i>flags</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>tee</b>() duplicates up to <i>len</i> bytes of data from the pipe referred to by<br>       the file descriptor <i>fd_in</i> to the pipe referred to by the file<br>       descriptor <i>fd_out</i>.  It does not consume the data that is duplicated<br>       from <i>fd_in</i>; therefore, that data can be copied by a subsequent<br>       splice(2).<br><br>       <i>flags</i> is a a bit mask that is composed by ORing together zero or more<br>       of the following values:<br><br>       <b>SPLICE_F_MOVE      </b>Currently has no effect for <b>tee</b>(); see splice(2).<br><br>       <b>SPLICE_F_NONBLOCK  </b>Do not block on I/O; see splice(2) for further<br>                          details.<br><br>       <b>SPLICE_F_MORE      </b>Currently has no effect for <b>tee</b>(), but may be<br>                          implemented in the future; see splice(2).<br><br>       <b>SPLICE_F_GIFT      </b>Unused for <b>tee</b>(); see vmsplice(2).<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       Upon successful completion, <b>tee</b>() returns the number of bytes that<br>       were duplicated between the input and output.  A return value of 0<br>       means that there was no data to transfer, and it would not make sense<br>       to block, because there are no writers connected to the write end of<br>       the pipe referred to by <i>fd_in</i>.<br><br>       On error, <b>tee</b>() returns -1 and <i>errno</i> is set to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EAGAIN SPLICE_F_NONBLOCK </b>was specified in <i>flags</i>, and the operation<br>              would block.<br><br>       <b>EINVAL </b><i>fd_in</i> or <i>fd_out</i> does not refer to a pipe; or <i>fd_in</i> and <i>fd_out</i><br>              refer to the same pipe.<br><br>       <b>ENOMEM </b>Out of memory.<br></pre><br><h2>VERSIONS  </h2><pre><br>       The <b>tee</b>() system call first appeared in Linux 2.6.17; library support<br>       was added to glibc in version 2.5.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       This system call is Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       Conceptually, <b>tee</b>() copies the data between the two pipes.  In<br>       reality no real data copying takes place though: under the covers,<br>       <b>tee</b>() assigns data to the output by merely grabbing a reference to<br>       the input.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The example below implements a basic tee(1) program using the <b>tee</b>()<br>       system call.  Here is an example of its use:<br><br>           $ <b>date |./a.out out.log | cat</b><br>           Tue Oct 28 10:06:00 CET 2014<br>           $ <b>cat out.log</b><br>           Tue Oct 28 10:06:00 CET 2014<br><br>   <b>Program source</b><br>       #define _GNU_SOURCE<br>       #include &lt;fcntl.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;unistd.h&gt;<br>       #include &lt;errno.h&gt;<br>       #include &lt;limits.h&gt;<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           int fd;<br>           int len, slen;<br><br>           if (argc != 2) {<br>               fprintf(stderr, \"Usage: %s &lt;file&gt;\\n\", argv[0]);<br>               exit(EXIT_FAILURE);<br>           }<br><br>           fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC, 0644);<br>           if (fd == -1) {<br>               perror(\"open\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           do {<br>               /*<br>                * tee stdin to stdout.<br>                */<br>               len = tee(STDIN_FILENO, STDOUT_FILENO,<br>                         INT_MAX, SPLICE_F_NONBLOCK);<br><br>               if (len &lt; 0) {<br>                   if (errno == EAGAIN)<br>                       continue;<br>                   perror(\"tee\");<br>                   exit(EXIT_FAILURE);<br>               } else<br>                   if (len == 0)<br>                       break;<br><br>               /*<br>                * Consume stdin by splicing it to a file.<br>                */<br>               while (len &gt; 0) {<br>                   slen = splice(STDIN_FILENO, NULL, fd, NULL,<br>                                 len, SPLICE_F_MOVE);<br>                   if (slen &lt; 0) {<br>                       perror(\"splice\");<br>                       break;<br>                   }<br>                   len -= slen;<br>               }<br>           } while (1);<br><br>           close(fd);<br>           exit(EXIT_SUCCESS);<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       splice(2), vmsplice(2)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2014-12-31                           TEE(2)</span><br></pre><br>"}