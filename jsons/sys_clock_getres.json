{"Man page": "<pre><br><span class=\"headline\">CLOCK_GETRES(2)           Linux Programmer's Manual          CLOCK_GETRES(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       clock_getres, clock_gettime, clock_settime - clock and time functions<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;time.h&gt;</b><br><br>       <b>int clock_getres(clockid_t </b><i>clk_id</i><b>, struct timespec *</b><i>res</i><b>);</b><br><br>       <b>int clock_gettime(clockid_t </b><i>clk_id</i><b>, struct timespec *</b><i>tp</i><b>);</b><br><br>       <b>int clock_settime(clockid_t </b><i>clk_id</i><b>, const struct timespec *</b><i>tp</i><b>);</b><br><br>       Link with <i>-lrt</i> (only for glibc versions before 2.17).<br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>clock_getres</b>(), <b>clock_gettime</b>(), <b>clock_settime</b>():<br>              _POSIX_C_SOURCE &gt;= 199309L<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The function <b>clock_getres</b>() finds the resolution (precision) of the<br>       specified clock <i>clk_id</i>, and, if <i>res</i> is non-NULL, stores it in the<br>       <i>struct timespec</i> pointed to by <i>res</i>.  The resolution of clocks depends<br>       on the implementation and cannot be configured by a particular<br>       process.  If the time value pointed to by the argument <i>tp</i> of<br>       <b>clock_settime</b>() is not a multiple of <i>res</i>, then it is truncated to a<br>       multiple of <i>res</i>.<br><br>       The functions <b>clock_gettime</b>() and <b>clock_settime</b>() retrieve and set<br>       the time of the specified clock <i>clk_id</i>.<br><br>       The <i>res</i> and <i>tp</i> arguments are <i>timespec</i> structures, as specified in<br>       <i>&lt;time.h&gt;</i>:<br><br>           struct timespec {<br>               time_t   tv_sec;        /* seconds */<br>               long     tv_nsec;       /* nanoseconds */<br>           };<br><br>       The <i>clk_id</i> argument is the identifier of the particular clock on<br>       which to act.  A clock may be system-wide and hence visible for all<br>       processes, or per-process if it measures time only within a single<br>       process.<br><br>       All implementations support the system-wide real-time clock, which is<br>       identified by <b>CLOCK_REALTIME</b>.  Its time represents seconds and<br>       nanoseconds since the Epoch.  When its time is changed, timers for a<br>       relative interval are unaffected, but timers for an absolute point in<br>       time are affected.<br><br>       More clocks may be implemented.  The interpretation of the<br>       corresponding time values and the effect on timers is unspecified.<br><br>       Sufficiently recent versions of glibc and the Linux kernel support<br>       the following clocks:<br><br>       <b>CLOCK_REALTIME</b><br>              System-wide clock that measures real (i.e., wall-clock) time.<br>              Setting this clock requires appropriate privileges.  This<br>              clock is affected by discontinuous jumps in the system time<br>              (e.g., if the system administrator manually changes the<br>              clock), and by the incremental adjustments performed by<br>              adjtime(3) and NTP.<br><br>       <b>CLOCK_REALTIME_COARSE </b>(since Linux 2.6.32; Linux-specific)<br>              A faster but less precise version of <b>CLOCK_REALTIME</b>.  Use when<br>              you need very fast, but not fine-grained timestamps.<br><br>       <b>CLOCK_MONOTONIC</b><br>              Clock that cannot be set and represents monotonic time<br>              since some unspecified starting point.  This clock is<br>              not affected by discontinuous jumps in the system time<br>              (e.g., if the system administrator manually changes the<br>              clock), but is affected by the incremental adjustments<br>              performed by adjtime(3) and NTP.<br><br>       <b>CLOCK_MONOTONIC_COARSE </b>(since Linux 2.6.32; Linux-specific)<br>              A faster but less precise version of <b>CLOCK_MONOTONIC</b>.<br>              Use when you need very fast, but not fine-grained<br>              timestamps.<br><br>       <b>CLOCK_MONOTONIC_RAW </b>(since Linux 2.6.28; Linux-specific)<br>              Similar to <b>CLOCK_MONOTONIC</b>, but provides access to a<br>              raw hardware-based time that is not subject to NTP<br>              adjustments or the incremental adjustments performed by<br>              adjtime(3).<br><br>       <b>CLOCK_BOOTTIME </b>(since Linux 2.6.39; Linux-specific)<br>              Identical to <b>CLOCK_MONOTONIC</b>, except it also includes<br>              any time that the system is suspended.  This allows<br>              applications to get a suspend-aware monotonic clock<br>              without having to deal with the complications of<br>              <b>CLOCK_REALTIME</b>, which may have discontinuities if the<br>              time is changed using settimeofday(2).<br><br>       <b>CLOCK_PROCESS_CPUTIME_ID </b>(since Linux 2.6.12)<br>              Per-process CPU-time clock (measures CPU time consumed<br>              by all threads in the process).<br><br>       <b>CLOCK_THREAD_CPUTIME_ID </b>(since Linux 2.6.12)<br>              Thread-specific CPU-time clock.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       <b>clock_gettime</b>(), <b>clock_settime</b>() and <b>clock_getres</b>() return 0<br>       for success, or -1 for failure (in which case <i>errno</i> is set<br>       appropriately).<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EFAULT </b><i>tp</i> points outside the accessible address space.<br><br>       <b>EINVAL </b>The <i>clk_id</i> specified is not supported on this system.<br><br>       <b>EPERM  clock_settime</b>() does not have permission to set the<br>              clock indicated.<br></pre><br><h2>VERSIONS  </h2><pre><br>       These system calls first appeared in Linux 2.6.<br></pre><br><h2>ATTRIBUTES  </h2><pre><br>       For an explanation of the terms used in this section, see<br>       attributes(7).<br><br>       &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9516;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9516;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;<br>       &#9474;<b>Interface        </b>&#9474; <b>Attribute     </b>&#9474; <b>Value   </b>&#9474;<br>       &#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;<br>       &#9474;<b>clock_getres</b>(),  &#9474; Thread safety &#9474; MT-Safe &#9474;<br>       &#9474;<b>clock_gettime</b>(), &#9474;               &#9474;         &#9474;<br>       &#9474;<b>clock_settime</b>()  &#9474;               &#9474;         &#9474;<br>       &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9524;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9524;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008, SUSv2.<br></pre><br><h2>AVAILABILITY  </h2><pre><br>       On POSIX systems on which these functions are available, the<br>       symbol <b>_POSIX_TIMERS </b>is defined in <i>&lt;unistd.h&gt;</i> to a value<br>       greater than 0.  The symbols <b>_POSIX_MONOTONIC_CLOCK</b>,<br>       <b>_POSIX_CPUTIME</b>, <b>_POSIX_THREAD_CPUTIME </b>indicate that<br>       <b>CLOCK_MONOTONIC</b>, <b>CLOCK_PROCESS_CPUTIME_ID</b>,<br>       <b>CLOCK_THREAD_CPUTIME_ID </b>are available.  (See also sysconf(3).)<br></pre><br><h2>NOTES  </h2><pre><br>   <b>Historical note for SMP systems</b><br>       Before Linux added kernel support for <b>CLOCK_PROCESS_CPUTIME_ID</b><br>       and <b>CLOCK_THREAD_CPUTIME_ID</b>, glibc implemented these clocks on<br>       many platforms using timer registers from the CPUs (TSC on<br>       i386, AR.ITC on Itanium).  These registers may differ between<br>       CPUs and as a consequence these clocks may return <b>bogus</b><br>       <b>results </b>if a process is migrated to another CPU.<br><br>       If the CPUs in an SMP system have different clock sources,<br>       then there is no way to maintain a correlation between the<br>       timer registers since each CPU will run at a slightly<br>       different frequency.  If that is the case, then<br>       <i>clock_getcpuclockid(0)</i> will return <b>ENOENT </b>to signify this<br>       condition.  The two clocks will then be useful only if it can<br>       be ensured that a process stays on a certain CPU.<br><br>       The processors in an SMP system do not start all at exactly<br>       the same time and therefore the timer registers are typically<br>       running at an offset.  Some architectures include code that<br>       attempts to limit these offsets on bootup.  However, the code<br>       cannot guarantee to accurately tune the offsets.  Glibc<br>       contains no provisions to deal with these offsets (unlike the<br>       Linux Kernel).  Typically these offsets are small and<br>       therefore the effects may be negligible in most cases.<br><br>       Since glibc 2.4, the wrapper functions for the system calls<br>       described in this page avoid the abovementioned problems by<br>       employing the kernel implementation of<br>       <b>CLOCK_PROCESS_CPUTIME_ID </b>and <b>CLOCK_THREAD_CPUTIME_ID</b>, on<br>       systems that provide such an implementation (i.e., Linux<br>       2.6.12 and later).<br></pre><br><h2>BUGS  </h2><pre><br>       According to POSIX.1-2001, a process with \"appropriate<br>       privileges\" may set the <b>CLOCK_PROCESS_CPUTIME_ID </b>and<br>       <b>CLOCK_THREAD_CPUTIME_ID </b>clocks using <b>clock_settime</b>().  On<br>       Linux, these clocks are not settable (i.e., no process has<br>       \"appropriate privileges\").<br></pre><br><h2>SEE ALSO  </h2><pre><br>       date(1), gettimeofday(2), settimeofday(2), time(2),<br>       adjtime(3), clock_getcpuclockid(3), ctime(3), ftime(3),<br>       pthread_getcpuclockid(3), sysconf(3), time(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i><br>       project.  A description of the project, information about<br>       reporting bugs, and the latest version of this page, can be<br>       found at http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">                                 2015-07-23                  CLOCK_GETRES(2)</span><br></pre><br>"}