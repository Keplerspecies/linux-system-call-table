{"Man page": "<pre><br><span class=\"headline\">FUTEX(2)                  Linux Programmer's Manual                 FUTEX(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       futex - fast user-space locking<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;linux/futex.h&gt;</b><br>       <b>#include &lt;sys/time.h&gt;</b><br><br>       <b>int futex(int *</b><i>uaddr</i><b>, int </b><i>op</i><b>, int </b><i>val</i><b>, const struct timespec *</b><i>timeout</i><b>,</b><br>                 <b>int *</b><i>uaddr2</i><b>, int </b><i>val3</i><b>);</b><br>       <i>Note</i>: There is no glibc wrapper for this system call; see NOTES.<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>futex</b>() system call provides a method for a program to wait for a<br>       value at a given address to change, and a method to wake up anyone<br>       waiting on a particular address (while the addresses for the same<br>       memory in separate processes may not be equal, the kernel maps them<br>       internally so the same memory mapped in different locations will<br>       correspond for <b>futex</b>() calls).  This system call is typically used to<br>       implement the contended case of a lock in shared memory, as described<br>       in futex(7).<br><br>       When a futex(7) operation did not finish uncontended in user space, a<br>       call needs to be made to the kernel to arbitrate.  Arbitration can<br>       either mean putting the calling process to sleep or, conversely,<br>       waking a waiting process.<br><br>       Callers of this function are expected to adhere to the semantics as<br>       set out in futex(7).  As these semantics involve writing nonportable<br>       assembly instructions, this in turn probably means that most users<br>       will in fact be library authors and not general application<br>       developers.<br><br>       The <i>uaddr</i> argument needs to point to an aligned integer which stores<br>       the counter.  The operation to execute is passed via the <i>op</i> argument,<br>       along with a value <i>val</i>.<br><br>       Five operations are currently defined:<br><br>       <b>FUTEX_WAIT</b><br>              This operation atomically verifies that the futex address<br>              <i>uaddr</i> still contains the value <i>val</i>, and sleeps awaiting<br>              <b>FUTEX_WAKE </b>on this futex address.  If the <i>timeout</i> argument is<br>              non-NULL, its contents specify the duration of the wait.<br>              (This interval will be rounded up to the system clock<br>              granularity, and kernel scheduling delays mean that the<br>              blocking interval may overrun by a small amount.)  If <i>timeout</i><br>              is NULL, the call blocks indefinitely.  The arguments <i>uaddr2</i><br>              and <i>val3</i> are ignored.<br><br>              For futex(7), this call is executed if decrementing the count<br>              gave a negative value (indicating contention), and will sleep<br>              until another process releases the futex and executes the<br>              <b>FUTEX_WAKE </b>operation.<br><br>       <b>FUTEX_WAKE</b><br>              This operation wakes at most <i>val</i> processes waiting on this<br>              futex address (i.e., inside <b>FUTEX_WAIT</b>).  The arguments<br>              <i>timeout</i>, <i>uaddr2</i> and <i>val3</i> are ignored.<br><br>              For futex(7), this is executed if incrementing the count<br>              showed that there were waiters, once the futex value has been<br>              set to 1 (indicating that it is available).<br><br>       <b>FUTEX_FD </b>(present up to and including Linux 2.6.25)<br>              To support asynchronous wakeups, this operation associates a<br>              file descriptor with a futex.  If another process executes a<br>              <b>FUTEX_WAKE</b>, the process will receive the signal number that<br>              was passed in <i>val</i>.  The calling process must close the<br>              returned file descriptor after use.  The arguments <i>timeout</i>,<br>              <i>uaddr2</i> and <i>val3</i> are ignored.<br><br>              To prevent race conditions, the caller should test if the<br>              futex has been upped after <b>FUTEX_FD </b>returns.<br><br>              Because it was inherently racy, <b>FUTEX_FD </b>has been removed from<br>              Linux 2.6.26 onward.<br><br>       <b>FUTEX_REQUEUE </b>(since Linux 2.5.70)<br>              This operation was introduced in order to avoid a \"thundering<br>              herd\" effect when <b>FUTEX_WAKE </b>is used and all processes woken<br>              up need to acquire another futex.  This call wakes up <i>val</i><br>              processes, and requeues all other waiters on the futex at<br>              address <i>uaddr2</i>.  The arguments <i>timeout</i> and <i>val3</i> are ignored.<br><br>       <b>FUTEX_CMP_REQUEUE </b>(since Linux 2.6.7)<br>              There was a race in the intended use of <b>FUTEX_REQUEUE</b>, so<br>              <b>FUTEX_CMP_REQUEUE </b>was introduced.  This is similar to<br>              <b>FUTEX_REQUEUE</b>, but first checks whether the location <i>uaddr</i><br>              still contains the value <i>val3</i>.  If not, the operation fails<br>              with the error <b>EAGAIN</b>.  The argument <i>timeout</i> is ignored.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       In the event of an error, all operations return -1, and set <i>errno</i> to<br>       indicate the error.  The return value on success depends on the<br>       operation, as described in the following list:<br><br>       <b>FUTEX_WAIT</b><br>              Returns 0 if the process was woken by a <b>FUTEX_WAKE </b>call.  See<br>              ERRORS for the various possible error returns.<br><br>       <b>FUTEX_WAKE</b><br>              Returns the number of processes woken up.<br><br>       <b>FUTEX_FD</b><br>              Returns the new file descriptor associated with the futex.<br><br>       <b>FUTEX_REQUEUE</b><br>              Returns the number of processes woken up.<br><br>       <b>FUTEX_CMP_REQUEUE</b><br>              Returns the number of processes woken up.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EACCES </b>No read access to futex memory.<br><br>       <b>EAGAIN FUTEX_CMP_REQUEUE </b>detected that the value pointed to by <i>uaddr</i><br>              is not equal to the expected value <i>val3</i>.  (This probably<br>              indicates a race; use the safe <b>FUTEX_WAKE </b>now.)<br><br>       <b>EFAULT </b>Error retrieving <i>timeout</i> information from user space.<br><br>       <b>EINTR  </b>A <b>FUTEX_WAIT </b>operation was interrupted by a signal (see<br>              signal(7)) or a spurious wakeup.<br><br>       <b>EINVAL </b>Invalid argument.<br><br>       <b>ENFILE </b>The system limit on the total number of open files has been<br>              reached.<br><br>       <b>ENOSYS </b>Invalid operation specified in <i>op</i>.<br><br>       <b>ETIMEDOUT</b><br>              Timeout during the <b>FUTEX_WAIT </b>operation.<br><br>       <b>EWOULDBLOCK</b><br>              <i>op</i> was <b>FUTEX_WAIT </b>and the value pointed to by <i>uaddr</i> was not<br>              equal to the expected value <i>val</i> at the time of the call.<br></pre><br><h2>VERSIONS  </h2><pre><br>       Initial futex support was merged in Linux 2.5.7 but with different<br>       semantics from what was described above.  A 4-argument system call<br>       with the semantics described in this page was introduced in Linux<br>       2.5.40.  In Linux 2.5.70, one argument was added.  In Linux 2.6.7, a<br>       sixth argument was added&#8212;messy, especially on the s390 architecture.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       This system call is Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       To reiterate, bare futexes are not intended as an easy-to-use<br>       abstraction for end-users.  (There is no wrapper function for this<br>       system call in glibc.)  Implementors are expected to be assembly<br>       literate and to have read the sources of the futex user-space library<br>       referenced below.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       restart_syscall(2), futex(7)<br><br>       <i>Fuss, Futexes and Furwocks: Fast Userlevel Locking in Linux</i><br>       (proceedings of the Ottawa Linux Symposium 2002), online at<br>       &#10216;http://kernel.org/doc/ols/2002/ols2002-pages-479-495.pdf&#10217;<br><br>       Futex example library, futex-*.tar.bz2 at<br>       &#10216;ftp://ftp.kernel.org/pub/linux/kernel/people/rusty/&#10217;<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2014-05-21                         FUTEX(2)</span><br></pre><br>"}