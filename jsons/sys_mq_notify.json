{"Man page": "<pre><br><span class=\"headline\">MQ_NOTIFY(3)              Linux Programmer's Manual             MQ_NOTIFY(3)</span><br></pre><br><h2>NAME  </h2><pre><br>       mq_notify - register for notification when a message is available<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;mqueue.h&gt;</b><br><br>       <b>int mq_notify(mqd_t </b><i>mqdes</i><b>, const struct sigevent *</b><i>sevp</i><b>);</b><br><br>       Link with <i>-lrt</i>.<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>mq_notify</b>() allows the calling process to register or unregister for<br>       delivery of an asynchronous notification when a new message arrives<br>       on the empty message queue referred to by the descriptor <i>mqdes</i>.<br><br>       The <i>sevp</i> argument is a pointer to a <i>sigevent</i> structure.  For the<br>       definition and general details of this structure, see sigevent(7).<br><br>       If <i>sevp</i> is a non-null pointer, then <b>mq_notify</b>() registers the calling<br>       process to receive message notification.  The <i>sigev_notify</i> field of<br>       the <i>sigevent</i> structure to which <i>sevp</i> points specifies how<br>       notification is to be performed.  This field has one of the following<br>       values:<br><br>       <b>SIGEV_NONE</b><br>              A \"null\" notification: the calling process is registered as<br>              the target for notification, but when a message arrives, no<br>              notification is sent.<br><br>       <b>SIGEV_SIGNAL</b><br>              Notify the process by sending the signal specified in<br>              <i>sigev_signo</i>.  See sigevent(7) for general details.  The<br>              <i>si_code</i> field of the <i>siginfo_t</i> structure will be set to<br>              <b>SI_MESGQ</b>.  In addition, <i>si_pid</i> will be set to the PID of the<br>              process that sent the message, and <i>si_uid</i> will be set to the<br>              real user ID of the sending process.<br><br>       <b>SIGEV_THREAD</b><br>              Upon message delivery, invoke <i>sigev_notify_function</i> as if it<br>              were the start function of a new thread.  See sigevent(7) for<br>              details.<br><br>       Only one process can be registered to receive notification from a<br>       message queue.<br><br>       If <i>sevp</i> is NULL, and the calling process is currently registered to<br>       receive notifications for this message queue, then the registration<br>       is removed; another process can then register to receive a message<br>       notification for this queue.<br><br>       Message notification occurs only when a new message arrives and the<br>       queue was previously empty.  If the queue was not empty at the time<br>       <b>mq_notify</b>() was called, then a notification will occur only after the<br>       queue is emptied and a new message arrives.<br><br>       If another process or thread is waiting to read a message from an<br>       empty queue using mq_receive(3), then any message notification<br>       registration is ignored: the message is delivered to the process or<br>       thread calling mq_receive(3), and the message notification<br>       registration remains in effect.<br><br>       Notification occurs once: after a notification is delivered, the<br>       notification registration is removed, and another process can<br>       register for message notification.  If the notified process wishes to<br>       receive the next notification, it can use <b>mq_notify</b>() to request a<br>       further notification.  This should be done before emptying all unread<br>       messages from the queue.  (Placing the queue in nonblocking mode is<br>       useful for emptying the queue of messages without blocking once it is<br>       empty.)<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success <b>mq_notify</b>() returns 0; on error, -1 is returned, with<br>       <i>errno</i> set to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EBADF  </b>The descriptor specified in <i>mqdes</i> is invalid.<br><br>       <b>EBUSY  </b>Another process has already registered to receive notification<br>              for this message queue.<br><br>       <b>EINVAL </b><i>sevp-&gt;sigev_notify</i> is not one of the permitted values; or<br>              <i>sevp-&gt;sigev_notify</i> is <b>SIGEV_SIGNAL </b>and <i>sevp-&gt;sigev_signo</i> is<br>              not a valid signal number.<br><br>       <b>ENOMEM </b>Insufficient memory.<br><br>       POSIX.1-2008 says that an implementation <i>may</i> generate an <b>EINVAL </b>error<br>       if <i>sevp</i> is NULL, and the caller is not currently registered to<br>       receive notifications for the queue <i>mqdes</i>.<br></pre><br><h2>ATTRIBUTES  </h2><pre><br>       For an explanation of the terms used in this section, see<br>       attributes(7).<br><br>       &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9516;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9516;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;<br>       &#9474;<b>Interface   </b>&#9474; <b>Attribute     </b>&#9474; <b>Value   </b>&#9474;<br>       &#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;<br>       &#9474;<b>mq_notify</b>() &#9474; Thread safety &#9474; MT-Safe &#9474;<br>       &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9524;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9524;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001.<br></pre><br><h2>NOTES  </h2><pre><br>   <b>C library/kernel differences</b><br>       In the glibc implementation, the <b>mq_notify</b>() library function is<br>       implemented on top of the system call of the same name.  When <i>sevp</i> is<br>       NULL, or specifies a notification mechanism other than <b>SIGEV_THREAD</b>,<br>       the library function directly invokes the system call.  For<br>       <b>SIGEV_THREAD</b>, much of the implementation resides within the library,<br>       rather than the kernel.  (This is necessarily so, since the thread<br>       involved in handling the notification is one that must be managed by<br>       the C library POSIX threads implementation.)  The implementation<br>       involves the use of a raw netlink(7) socket and creates a new thread<br>       for each notification that is delivered to the process.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The following program registers a notification request for the<br>       message queue named in its command-line argument.  Notification is<br>       performed by creating a thread.  The thread executes a function which<br>       reads one message from the queue and then terminates the process.<br><br>   <b>Program source</b><br>       #include &lt;pthread.h&gt;<br>       #include &lt;mqueue.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;unistd.h&gt;<br><br>       #define handle_error(msg) \\<br>           do { perror(msg); exit(EXIT_FAILURE); } while (0)<br><br>       static void                     /* Thread start function */<br>       tfunc(union sigval sv)<br>       {<br>           struct mq_attr attr;<br>           ssize_t nr;<br>           void *buf;<br>           mqd_t mqdes = *((mqd_t *) sv.sival_ptr);<br><br>           /* Determine max. msg size; allocate buffer to receive msg */<br><br>           if (mq_getattr(mqdes, &amp;attr) == -1)<br>               handle_error(\"mq_getattr\");<br>           buf = malloc(attr.mq_msgsize);<br>           if (buf == NULL)<br>               handle_error(\"malloc\");<br><br>           nr = mq_receive(mqdes, buf, attr.mq_msgsize, NULL);<br>           if (nr == -1)<br>               handle_error(\"mq_receive\");<br><br>           printf(\"Read %zd bytes from MQ\\n\", nr);<br>           free(buf);<br>           exit(EXIT_SUCCESS);         /* Terminate the process */<br>       }<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           mqd_t mqdes;<br>           struct sigevent sev;<br><br>           if (argc != 2) {<br>               fprintf(stderr, \"Usage: %s &lt;mq-name&gt;\\n\", argv[0]);<br>               exit(EXIT_FAILURE);<br>           }<br><br>           mqdes = mq_open(argv[1], O_RDONLY);<br>           if (mqdes == (mqd_t) -1)<br>               handle_error(\"mq_open\");<br><br>           sev.sigev_notify = SIGEV_THREAD;<br>           sev.sigev_notify_function = tfunc;<br>           sev.sigev_notify_attributes = NULL;<br>           sev.sigev_value.sival_ptr = &amp;mqdes;   /* Arg. to thread func. */<br>           if (mq_notify(mqdes, &amp;sev) == -1)<br>               handle_error(\"mq_notify\");<br><br>           pause();    /* Process will be terminated by thread function */<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       mq_close(3), mq_getattr(3), mq_open(3), mq_receive(3), mq_send(3),<br>       mq_unlink(3), mq_overview(7), sigevent(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                     MQ_NOTIFY(3)</span><br></pre><br>"}