{"Man page": "<pre><br><span class=\"headline\">NANOSLEEP(2)              Linux Programmer's Manual             NANOSLEEP(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       nanosleep - high-resolution sleep<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;time.h&gt;</b><br><br>       <b>int nanosleep(const struct timespec *</b><i>req</i><b>, struct timespec *</b><i>rem</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>nanosleep</b>(): _POSIX_C_SOURCE &gt;= 199309L<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>nanosleep</b>() suspends the execution of the calling thread until either<br>       at least the time specified in <i>*req</i> has elapsed, or the delivery of a<br>       signal that triggers the invocation of a handler in the calling<br>       thread or that terminates the process.<br><br>       If the call is interrupted by a signal handler, <b>nanosleep</b>() returns<br>       -1, sets <i>errno</i> to <b>EINTR</b>, and writes the remaining time into the<br>       structure pointed to by <i>rem</i> unless <i>rem</i> is NULL.  The value of <i>*rem</i><br>       can then be used to call <b>nanosleep</b>() again and complete the specified<br>       pause (but see NOTES).<br><br>       The structure <i>timespec</i> is used to specify intervals of time with<br>       nanosecond precision.  It is defined as follows:<br><br>           struct timespec {<br>               time_t tv_sec;        /* seconds */<br>               long   tv_nsec;       /* nanoseconds */<br>           };<br><br>       The value of the nanoseconds field must be in the range 0 to<br>       999999999.<br><br>       Compared to sleep(3) and usleep(3), <b>nanosleep</b>() has the following<br>       advantages: it provides a higher resolution for specifying the sleep<br>       interval; POSIX.1 explicitly specifies that it does not interact with<br>       signals; and it makes the task of resuming a sleep that has been<br>       interrupted by a signal handler easier.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On successfully sleeping for the requested interval, <b>nanosleep</b>()<br>       returns 0.  If the call is interrupted by a signal handler or<br>       encounters an error, then it returns -1, with <i>errno</i> set to indicate<br>       the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EFAULT </b>Problem with copying information from user space.<br><br>       <b>EINTR  </b>The pause has been interrupted by a signal that was delivered<br>              to the thread.  The remaining sleep time has been written into<br>              <i>*rem</i> so that the thread can easily call <b>nanosleep</b>() again and<br>              continue with the pause.<br><br>       <b>EINVAL </b>The value in the <i>tv_nsec</i> field was not in the range 0 to<br>              999999999 or <i>tv_sec</i> was negative.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008.<br></pre><br><h2>NOTES  </h2><pre><br>       If the interval specified in <i>req</i> is not an exact multiple of the<br>       granularity underlying clock (see time(7)), then the interval will be<br>       rounded up to the next multiple.  Furthermore, after the sleep<br>       completes, there may still be a delay before the CPU becomes free to<br>       once again execute the calling thread.<br><br>       The fact that <b>nanosleep</b>() sleeps for a relative interval can be<br>       problematic if the call is repeatedly restarted after being<br>       interrupted by signals, since the time between the interruptions and<br>       restarts of the call will lead to drift in the time when the sleep<br>       finally completes.  This problem can be avoided by using<br>       clock_nanosleep(2) with an absolute time value.<br><br>       POSIX.1 specifies that <b>nanosleep</b>() should measure time against the<br>       <b>CLOCK_REALTIME </b>clock.  However, Linux measures the time using the<br>       <b>CLOCK_MONOTONIC </b>clock.  This probably does not matter, since the<br>       POSIX.1 specification for clock_settime(2) says that discontinuous<br>       changes in <b>CLOCK_REALTIME </b>should not affect <b>nanosleep</b>():<br><br>              Setting the value of the <b>CLOCK_REALTIME </b>clock via<br>              clock_settime(2) shall have no effect on threads that are<br>              blocked waiting for a relative time service based upon this<br>              clock, including the <b>nanosleep</b>() function; ...  Consequently,<br>              these time services shall expire when the requested relative<br>              interval elapses, independently of the new or old value of the<br>              clock.<br><br>   <b>Old behavior</b><br>       In order to support applications requiring much more precise pauses<br>       (e.g., in order to control some time-critical hardware), <b>nanosleep</b>()<br>       would handle pauses of up to 2 ms by busy waiting with microsecond<br>       precision when called from a thread scheduled under a real-time<br>       policy like <b>SCHED_FIFO </b>or <b>SCHED_RR</b>.  This special extension was<br>       removed in kernel 2.5.39, hence is still present in current 2.4<br>       kernels, but not in 2.6 kernels.<br></pre><br><h2>BUGS  </h2><pre><br>       In Linux 2.4, if <b>nanosleep</b>() is stopped by a signal (e.g., <b>SIGTSTP</b>),<br>       then the call fails with the error <b>EINTR </b>after the thread is resumed<br>       by a <b>SIGCONT </b>signal.  If the system call is subsequently restarted,<br>       then the time that the thread spent in the stopped state is <i>not</i><br>       counted against the sleep interval.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       clock_nanosleep(2), restart_syscall(2), sched_setscheduler(2),<br>       timer_create(2), sleep(3), usleep(3), time(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-08-08                     NANOSLEEP(2)</span><br></pre><br>"}