{"Man page": "<pre><br><span class=\"headline\">FCNTL(2)                  Linux Programmer's Manual                 FCNTL(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       fcntl - manipulate file descriptor<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;unistd.h&gt;</b><br>       <b>#include &lt;fcntl.h&gt;</b><br><br>       <b>int fcntl(int </b><i>fd</i><b>, int </b><i>cmd</i><b>, ... /* </b><i>arg</i> <b>*/ );</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>fcntl</b>() performs one of the operations described below on the open<br>       file descriptor <i>fd</i>.  The operation is determined by <i>cmd</i>.<br><br>       <b>fcntl</b>() can take an optional third argument.  Whether or not this<br>       argument is required is determined by <i>cmd</i>.  The required argument<br>       type is indicated in parentheses after each <i>cmd</i> name (in most cases,<br>       the required type is <i>int</i>, and we identify the argument using the name<br>       <i>arg</i>), or <i>void</i> is specified if the argument is not required.<br><br>       Certain of the operations below are supported only since a particular<br>       Linux kernel version.  The preferred method of checking whether the<br>       host kernel supports a particular operation is to invoke <b>fcntl</b>() with<br>       the desired <i>cmd</i> value and then test whether the call failed with<br>       <b>EINVAL</b>, indicating that the kernel does not recognize this value.<br><br>   <b>Duplicating a file descriptor</b><br>       <b>F_DUPFD </b>(<i>int</i>)<br>              Find the lowest numbered available file descriptor greater<br>              than or equal to <i>arg</i> and make it be a copy of <i>fd</i>.  This is<br>              different from dup2(2), which uses exactly the descriptor<br>              specified.<br><br>              On success, the new descriptor is returned.<br><br>              See dup(2) for further details.<br><br>       <b>F_DUPFD_CLOEXEC </b>(<i>int</i>; since Linux 2.6.24)<br>              As for <b>F_DUPFD</b>, but additionally set the close-on-exec flag<br>              for the duplicate descriptor.  Specifying this flag permits a<br>              program to avoid an additional <b>fcntl</b>() <b>F_SETFD </b>operation to<br>              set the <b>FD_CLOEXEC </b>flag.  For an explanation of why this flag<br>              is useful, see the description of <b>O_CLOEXEC </b>in open(2).<br><br>   <b>File descriptor flags</b><br>       The following commands manipulate the flags associated with a file<br>       descriptor.  Currently, only one such flag is defined: <b>FD_CLOEXEC</b>,<br>       the close-on-exec flag.  If the <b>FD_CLOEXEC </b>bit is 0, the file<br>       descriptor will remain open across an execve(2), otherwise it will be<br>       closed.<br><br>       <b>F_GETFD </b>(<i>void</i>)<br>              Read the file descriptor flags; <i>arg</i> is ignored.<br><br>       <b>F_SETFD </b>(<i>int</i>)<br>              Set the file descriptor flags to the value specified by <i>arg</i>.<br><br>       In multithreaded programs, using <b>fcntl</b>() <b>F_SETFD </b>to set the close-on-<br>       exec flag at the same time as another thread performs a fork(2) plus<br>       execve(2) is vulnerable to a race condition that may unintentionally<br>       leak the file descriptor to the program executed in the child<br>       process.  See the discussion of the <b>O_CLOEXEC </b>flag in open(2) for<br>       details and a remedy to the problem.<br><br>   <b>File status flags</b><br>       Each open file description has certain associated status flags,<br>       initialized by open(2) and possibly modified by <b>fcntl</b>().  Duplicated<br>       file descriptors (made with dup(2), <b>fcntl</b>(F_DUPFD), fork(2), etc.)<br>       refer to the same open file description, and thus share the same file<br>       status flags.<br><br>       The file status flags and their semantics are described in open(2).<br><br>       <b>F_GETFL </b>(<i>void</i>)<br>              Get the file access mode and the file status flags; <i>arg</i> is<br>              ignored.<br><br>       <b>F_SETFL </b>(<i>int</i>)<br>              Set the file status flags to the value specified by <i>arg</i>.  File<br>              access mode (<b>O_RDONLY</b>, <b>O_WRONLY</b>, <b>O_RDWR</b>) and file creation<br>              flags (i.e., <b>O_CREAT</b>, <b>O_EXCL</b>, <b>O_NOCTTY</b>, <b>O_TRUNC</b>) in <i>arg</i> are<br>              ignored.  On Linux this command can change only the <b>O_APPEND</b>,<br>              <b>O_ASYNC</b>, <b>O_DIRECT</b>, <b>O_NOATIME</b>, and <b>O_NONBLOCK </b>flags.  It is not<br>              possible to change the <b>O_DSYNC </b>and <b>O_SYNC </b>flags; see BUGS,<br>              below.<br><br>   <b>Advisory record locking</b><br>       Linux implements traditional (\"process-associated\") UNIX record<br>       locks, as standardized by POSIX.  For a Linux-specific alternative<br>       with better semantics, see the discussion of open file description<br>       locks below.<br><br>       <b>F_SETLK</b>, <b>F_SETLKW</b>, and <b>F_GETLK </b>are used to acquire, release, and test<br>       for the existence of record locks (also known as byte-range, file-<br>       segment, or file-region locks).  The third argument, <i>lock</i>, is a<br>       pointer to a structure that has at least the following fields (in<br>       unspecified order).<br><br>           struct flock {<br>               ...<br>               short l_type;    /* Type of lock: F_RDLCK,<br>                                   F_WRLCK, F_UNLCK */<br>               short l_whence;  /* How to interpret l_start:<br>                                   SEEK_SET, SEEK_CUR, SEEK_END */<br>               off_t l_start;   /* Starting offset for lock */<br>               off_t l_len;     /* Number of bytes to lock */<br>               pid_t l_pid;     /* PID of process blocking our lock<br>                                   (set by F_GETLK and F_OFD_GETLK) */<br>               ...<br>           };<br><br>       The <i>l_whence</i>, <i>l_start</i>, and <i>l_len</i> fields of this structure specify the<br>       range of bytes we wish to lock.  Bytes past the end of the file may<br>       be locked, but not bytes before the start of the file.<br><br>       <i>l_start</i> is the starting offset for the lock, and is interpreted<br>       relative to either: the start of the file (if <i>l_whence</i> is <b>SEEK_SET</b>);<br>       the current file offset (if <i>l_whence</i> is <b>SEEK_CUR</b>); or the end of the<br>       file (if <i>l_whence</i> is <b>SEEK_END</b>).  In the final two cases, <i>l_start</i> can<br>       be a negative number provided the offset does not lie before the<br>       start of the file.<br><br>       <i>l_len</i> specifies the number of bytes to be locked.  If <i>l_len</i> is<br>       positive, then the range to be locked covers bytes <i>l_start</i> up to and<br>       including <i>l_start</i>+<i>l_len</i>-1.  Specifying 0 for <i>l_len</i> has the special<br>       meaning: lock all bytes starting at the location specified by<br>       <i>l_whence</i> and <i>l_start</i> through to the end of file, no matter how large<br>       the file grows.<br><br>       POSIX.1-2001 allows (but does not require) an implementation to<br>       support a negative <i>l_len</i> value; if <i>l_len</i> is negative, the interval<br>       described by <i>lock</i> covers bytes <i>l_start</i>+<i>l_len</i> up to and including<br>       <i>l_start</i>-1.  This is supported by Linux since kernel versions 2.4.21<br>       and 2.5.49.<br><br>       The <i>l_type</i> field can be used to place a read (<b>F_RDLCK</b>) or a write<br>       (<b>F_WRLCK</b>) lock on a file.  Any number of processes may hold a read<br>       lock (shared lock) on a file region, but only one process may hold a<br>       write lock (exclusive lock).  An exclusive lock excludes all other<br>       locks, both shared and exclusive.  A single process can hold only one<br>       type of lock on a file region; if a new lock is applied to an<br>       already-locked region, then the existing lock is converted to the new<br>       lock type.  (Such conversions may involve splitting, shrinking, or<br>       coalescing with an existing lock if the byte range specified by the<br>       new lock does not precisely coincide with the range of the existing<br>       lock.)<br><br>       <b>F_SETLK </b>(<i>struct flock *</i>)<br>              Acquire a lock (when <i>l_type</i> is <b>F_RDLCK </b>or <b>F_WRLCK</b>) or release<br>              a lock (when <i>l_type</i> is <b>F_UNLCK</b>) on the bytes specified by the<br>              <i>l_whence</i>, <i>l_start</i>, and <i>l_len</i> fields of <i>lock</i>.  If a conflicting<br>              lock is held by another process, this call returns -1 and sets<br>              <i>errno</i> to <b>EACCES </b>or <b>EAGAIN</b>.  (The error returned in this case<br>              differs across implementations, so POSIX requires a portable<br>              application to check for both errors.)<br><br>       <b>F_SETLKW </b>(<i>struct flock *</i>)<br>              As for <b>F_SETLK</b>, but if a conflicting lock is held on the file,<br>              then wait for that lock to be released.  If a signal is caught<br>              while waiting, then the call is interrupted and (after the<br>              signal handler has returned) returns immediately (with return<br>              value -1 and <i>errno</i> set to <b>EINTR</b>; see signal(7)).<br><br>       <b>F_GETLK </b>(<i>struct flock *</i>)<br>              On input to this call, <i>lock</i> describes a lock we would like to<br>              place on the file.  If the lock could be placed, <b>fcntl</b>() does<br>              not actually place it, but returns <b>F_UNLCK </b>in the <i>l_type</i> field<br>              of <i>lock</i> and leaves the other fields of the structure<br>              unchanged.<br><br>              If one or more incompatible locks would prevent this lock<br>              being placed, then <b>fcntl</b>() returns details about one of those<br>              locks in the <i>l_type</i>, <i>l_whence</i>, <i>l_start</i>, and <i>l_len</i> fields of<br>              <i>lock</i>.  If the conflicting lock is a traditional (process-<br>              associated) record lock, then the <i>l_pid</i> field is set to the<br>              PID of the process holding that lock.  If the conflicting lock<br>              is an open file description lock, then <i>l_pid</i> is set to -1.<br>              Note that the returned information may already be out of date<br>              by the time the caller inspects it.<br><br>       In order to place a read lock, <i>fd</i> must be open for reading.  In order<br>       to place a write lock, <i>fd</i> must be open for writing.  To place both<br>       types of lock, open a file read-write.<br><br>       When placing locks with <b>F_SETLKW</b>, the kernel detects <i>deadlocks</i>,<br>       whereby two or more processes have their lock requests mutually<br>       blocked by locks held by the other processes.  For example, suppose<br>       process A holds a write lock on byte 100 of a file, and process B<br>       holds a write lock on byte 200.  If each process then attempts to<br>       lock the byte already locked by the other process using <b>F_SETLKW</b>,<br>       then, without deadlock detection, both processes would remain blocked<br>       indefinitely.  When the kernel detects such deadlocks, it causes one<br>       of the blocking lock requests to immediately fail with the error<br>       <b>EDEADLK</b>; an application that encounters such an error should release<br>       some of its locks to allow other applications to proceed before<br>       attempting regain the locks that it requires.  Circular deadlocks<br>       involving more than two processes are also detected.  Note, however,<br>       that there are limitations to the kernel's deadlock-detection<br>       algorithm; see BUGS.<br><br>       As well as being removed by an explicit <b>F_UNLCK</b>, record locks are<br>       automatically released when the process terminates.<br><br>       Record locks are not inherited by a child created via fork(2), but<br>       are preserved across an execve(2).<br><br>       Because of the buffering performed by the stdio(3) library, the use<br>       of record locking with routines in that package should be avoided;<br>       use read(2) and write(2) instead.<br><br>       The record locks described above are associated with the process<br>       (unlike the open file description locks described below).  This has<br>       some unfortunate consequences:<br><br>       *  If a process closes <i>any</i> file descriptor referring to a file, then<br>          all of the process's locks on that file are released, regardless<br>          of the file descriptor(s) on which the locks were obtained.  This<br>          is bad: it means that a process can lose its locks on a file such<br>          as <i>/etc/passwd</i> or <i>/etc/mtab</i> when for some reason a library<br>          function decides to open, read, and close the same file.<br><br>       *  The threads in a process share locks.  In other words, a<br>          multithreaded program can't use record locking to ensure that<br>          threads don't simultaneously access the same region of a file.<br><br>       Open file description locks solve both of these problems.<br><br>   <b>Open file description locks (non-POSIX)</b><br>       Open file description locks are advisory byte-range locks whose<br>       operation is in most respects identical to the traditional record<br>       locks described above.  This lock type is Linux-specific, and<br>       available since Linux 3.15.  (There is a proposal with the Austin<br>       Group to include this lock type in the next revision of POSIX.1.)<br>       For an explanation of open file descriptions, see open(2).<br><br>       The principal difference between the two lock types is that whereas<br>       traditional record locks are associated with a process, open file<br>       description locks are associated with the open file description on<br>       which they are acquired, much like locks acquired with flock(2).<br>       Consequently (and unlike traditional advisory record locks), open<br>       file description locks are inherited across fork(2) (and clone(2)<br>       with <b>CLONE_FILES</b>), and are only automatically released on the last<br>       close of the open file description, instead of being released on any<br>       close of the file.<br><br>       Conflicting lock combinations (i.e., a read lock and a write lock or<br>       two write locks) where one lock is an open file description lock and<br>       the other is a traditional record lock conflict even when they are<br>       acquired by the same process on the same file descriptor.<br><br>       Open file description locks placed via the same open file description<br>       (i.e., via the same file descriptor, or via a duplicate of the file<br>       descriptor created by fork(2), dup(2), fcntl(2) <b>F_DUPFD</b>, and so on)<br>       are always compatible: if a new lock is placed on an already locked<br>       region, then the existing lock is converted to the new lock type.<br>       (Such conversions may result in splitting, shrinking, or coalescing<br>       with an existing lock as discussed above.)<br><br>       On the other hand, open file description locks may conflict with each<br>       other when they are acquired via different open file descriptions.<br>       Thus, the threads in a multithreaded program can use open file<br>       description locks to synchronize access to a file region by having<br>       each thread perform its own open(2) on the file and applying locks<br>       via the resulting file descriptor.<br><br>       As with traditional advisory locks, the third argument to <b>fcntl</b>(),<br>       <i>lock</i>, is a pointer to an <i>flock</i> structure.  By contrast with<br>       traditional record locks, the <i>l_pid</i> field of that structure must be<br>       set to zero when using the commands described below.<br><br>       The commands for working with open file description locks are<br>       analogous to those used with traditional locks:<br><br>       <b>F_OFD_SETLK </b>(<i>struct flock *</i>)<br>              Acquire an open file description lock (when <i>l_type</i> is <b>F_RDLCK</b><br>              or <b>F_WRLCK</b>) or release an open file description lock (when<br>              <i>l_type</i> is <b>F_UNLCK</b>) on the bytes specified by the <i>l_whence</i>,<br>              <i>l_start</i>, and <i>l_len</i> fields of <i>lock</i>.  If a conflicting lock is<br>              held by another process, this call returns -1 and sets <i>errno</i><br>              to <b>EAGAIN</b>.<br><br>       <b>F_OFD_SETLKW </b>(<i>struct flock *</i>)<br>              As for <b>F_OFD_SETLK</b>, but if a conflicting lock is held on the<br>              file, then wait for that lock to be released.  If a signal is<br>              caught while waiting, then the call is interrupted and (after<br>              the signal handler has returned) returns immediately (with<br>              return value -1 and <i>errno</i> set to <b>EINTR</b>; see signal(7)).<br><br>       <b>F_OFD_GETLK </b>(<i>struct flock *</i>)<br>              On input to this call, <i>lock</i> describes an open file description<br>              lock we would like to place on the file.  If the lock could be<br>              placed, <b>fcntl</b>() does not actually place it, but returns<br>              <b>F_UNLCK </b>in the <i>l_type</i> field of <i>lock</i> and leaves the other<br>              fields of the structure unchanged.  If one or more<br>              incompatible locks would prevent this lock being placed, then<br>              details about one of these locks are returned via <i>lock</i>, as<br>              described above for <b>F_GETLK</b>.<br><br>       In the current implementation, no deadlock detection is performed for<br>       open file description locks.  (This contrasts with process-associated<br>       record locks, for which the kernel does perform deadlock detection.)<br><br>   <b>Mandatory locking</b><br>       <i>Warning</i>: the Linux implementation of mandatory locking is unreliable.<br>       See BUGS below.<br><br>       By default, both traditional (process-associated) and open file<br>       description record locks are advisory.  Advisory locks are not<br>       enforced and are useful only between cooperating processes.<br><br>       Both lock types can also be mandatory.  Mandatory locks are enforced<br>       for all processes.  If a process tries to perform an incompatible<br>       access (e.g., read(2) or write(2)) on a file region that has an<br>       incompatible mandatory lock, then the result depends upon whether the<br>       <b>O_NONBLOCK </b>flag is enabled for its open file description.  If the<br>       <b>O_NONBLOCK </b>flag is not enabled, then the system call is blocked until<br>       the lock is removed or converted to a mode that is compatible with<br>       the access.  If the <b>O_NONBLOCK </b>flag is enabled, then the system call<br>       fails with the error <b>EAGAIN</b>.<br><br>       To make use of mandatory locks, mandatory locking must be enabled<br>       both on the filesystem that contains the file to be locked, and on<br>       the file itself.  Mandatory locking is enabled on a filesystem using<br>       the \"-o mand\" option to mount(8), or the <b>MS_MANDLOCK </b>flag for<br>       mount(2).  Mandatory locking is enabled on a file by disabling group<br>       execute permission on the file and enabling the set-group-ID<br>       permission bit (see chmod(1) and chmod(2)).<br><br>       Mandatory locking is not specified by POSIX.  Some other systems also<br>       support mandatory locking, although the details of how to enable it<br>       vary across systems.<br><br>   <b>Managing signals</b><br>       <b>F_GETOWN</b>, <b>F_SETOWN</b>, <b>F_GETOWN_EX</b>, <b>F_SETOWN_EX</b>, <b>F_GETSIG </b>and <b>F_SETSIG</b><br>       are used to manage I/O availability signals:<br><br>       <b>F_GETOWN </b>(<i>void</i>)<br>              Return (as the function result) the process ID or process<br>              group currently receiving <b>SIGIO </b>and <b>SIGURG </b>signals for events<br>              on file descriptor <i>fd</i>.  Process IDs are returned as positive<br>              values; process group IDs are returned as negative values (but<br>              see BUGS below).  <i>arg</i> is ignored.<br><br>       <b>F_SETOWN </b>(<i>int</i>)<br>              Set the process ID or process group ID that will receive <b>SIGIO</b><br>              and <b>SIGURG </b>signals for events on file descriptor <i>fd</i> to the ID<br>              given in <i>arg</i>.  A process ID is specified as a positive value;<br>              a process group ID is specified as a negative value.  Most<br>              commonly, the calling process specifies itself as the owner<br>              (that is, <i>arg</i> is specified as getpid(2)).<br><br>              If you set the <b>O_ASYNC </b>status flag on a file descriptor by<br>              using the <b>F_SETFL </b>command of <b>fcntl</b>(), a <b>SIGIO </b>signal is sent<br>              whenever input or output becomes possible on that file<br>              descriptor.  <b>F_SETSIG </b>can be used to obtain delivery of a<br>              signal other than <b>SIGIO</b>.  If this permission check fails, then<br>              the signal is silently discarded.<br><br>              Sending a signal to the owner process (group) specified by<br>              <b>F_SETOWN </b>is subject to the same permissions checks as are<br>              described for kill(2), where the sending process is the one<br>              that employs <b>F_SETOWN </b>(but see BUGS below).<br><br>              If the file descriptor <i>fd</i> refers to a socket, <b>F_SETOWN </b>also<br>              selects the recipient of <b>SIGURG </b>signals that are delivered<br>              when out-of-band data arrives on that socket.  (<b>SIGURG </b>is sent<br>              in any situation where select(2) would report the socket as<br>              having an \"exceptional condition\".)<br><br>              The following was true in 2.6.x kernels up to and including<br>              kernel 2.6.11:<br><br>                     If a nonzero value is given to <b>F_SETSIG </b>in a<br>                     multithreaded process running with a threading library<br>                     that supports thread groups (e.g., NPTL), then a<br>                     positive value given to <b>F_SETOWN </b>has a different<br>                     meaning: instead of being a process ID identifying a<br>                     whole process, it is a thread ID identifying a specific<br>                     thread within a process.  Consequently, it may be<br>                     necessary to pass <b>F_SETOWN </b>the result of gettid(2)<br>                     instead of getpid(2) to get sensible results when<br>                     <b>F_SETSIG </b>is used.  (In current Linux threading<br>                     implementations, a main thread's thread ID is the same<br>                     as its process ID.  This means that a single-threaded<br>                     program can equally use gettid(2) or getpid(2) in this<br>                     scenario.)  Note, however, that the statements in this<br>                     paragraph do not apply to the <b>SIGURG </b>signal generated<br>                     for out-of-band data on a socket: this signal is always<br>                     sent to either a process or a process group, depending<br>                     on the value given to <b>F_SETOWN</b>.<br><br>              The above behavior was accidentally dropped in Linux 2.6.12,<br>              and won't be restored.  From Linux 2.6.32 onward, use<br>              <b>F_SETOWN_EX </b>to target <b>SIGIO </b>and <b>SIGURG </b>signals at a particular<br>              thread.<br><br>       <b>F_GETOWN_EX </b>(<i>struct f_owner_ex *</i>) (since Linux 2.6.32)<br>              Return the current file descriptor owner settings as defined<br>              by a previous <b>F_SETOWN_EX </b>operation.  The information is<br>              returned in the structure pointed to by <i>arg</i>, which has the<br>              following form:<br><br>                  struct f_owner_ex {<br>                      int   type;<br>                      pid_t pid;<br>                  };<br><br>              The <i>type</i> field will have one of the values <b>F_OWNER_TID</b>,<br>              <b>F_OWNER_PID</b>, or <b>F_OWNER_PGRP</b>.  The <i>pid</i> field is a positive<br>              integer representing a thread ID, process ID, or process group<br>              ID.  See <b>F_SETOWN_EX </b>for more details.<br><br>       <b>F_SETOWN_EX </b>(<i>struct f_owner_ex *</i>) (since Linux 2.6.32)<br>              This operation performs a similar task to <b>F_SETOWN</b>.  It allows<br>              the caller to direct I/O availability signals to a specific<br>              thread, process, or process group.  The caller specifies the<br>              target of signals via <i>arg</i>, which is a pointer to a <i>f_owner_ex</i><br>              structure.  The <i>type</i> field has one of the following values,<br>              which define how <i>pid</i> is interpreted:<br><br>              <b>F_OWNER_TID</b><br>                     Send the signal to the thread whose thread ID (the<br>                     value returned by a call to clone(2) or gettid(2)) is<br>                     specified in <i>pid</i>.<br><br>              <b>F_OWNER_PID</b><br>                     Send the signal to the process whose ID is specified in<br>                     <i>pid</i>.<br><br>              <b>F_OWNER_PGRP</b><br>                     Send the signal to the process group whose ID is<br>                     specified in <i>pid</i>.  (Note that, unlike with <b>F_SETOWN</b>, a<br>                     process group ID is specified as a positive value<br>                     here.)<br><br>       <b>F_GETSIG </b>(<i>void</i>)<br>              Return (as the function result) the signal sent when input or<br>              output becomes possible.  A value of zero means <b>SIGIO </b>is sent.<br>              Any other value (including <b>SIGIO</b>) is the signal sent instead,<br>              and in this case additional info is available to the signal<br>              handler if installed with <b>SA_SIGINFO</b>.  <i>arg</i> is ignored.<br><br>       <b>F_SETSIG </b>(<i>int</i>)<br>              Set the signal sent when input or output becomes possible to<br>              the value given in <i>arg</i>.  A value of zero means to send the<br>              default <b>SIGIO </b>signal.  Any other value (including <b>SIGIO</b>) is<br>              the signal to send instead, and in this case additional info<br>              is available to the signal handler if installed with<br>              <b>SA_SIGINFO</b>.<br><br>              By using <b>F_SETSIG </b>with a nonzero value, and setting <b>SA_SIGINFO</b><br>              for the signal handler (see sigaction(2)), extra information<br>              about I/O events is passed to the handler in a <i>siginfo_t</i><br>              structure.  If the <i>si_code</i> field indicates the source is<br>              <b>SI_SIGIO</b>, the <i>si_fd</i> field gives the file descriptor associated<br>              with the event.  Otherwise, there is no indication which file<br>              descriptors are pending, and you should use the usual<br>              mechanisms (select(2), poll(2), read(2) with <b>O_NONBLOCK </b>set<br>              etc.) to determine which file descriptors are available for<br>              I/O.<br><br>              Note that the file descriptor provided in <i>si_fd</i> is the one<br>              that that was specified during the <b>F_SETSIG </b>operation.  This<br>              can lead to an unusual corner case.  If the file descriptor is<br>              duplicated (dup(2) or similar), and the original file<br>              descriptor is closed, then I/O events will continue to be<br>              generated, but the <i>si_fd</i> field will contain the number of the<br>              now closed file descriptor.<br><br>              By selecting a real time signal (value &gt;= <b>SIGRTMIN</b>), multiple<br>              I/O events may be queued using the same signal numbers.<br>              (Queuing is dependent on available memory.)  Extra information<br>              is available if <b>SA_SIGINFO </b>is set for the signal handler, as<br>              above.<br><br>              Note that Linux imposes a limit on the number of real-time<br>              signals that may be queued to a process (see getrlimit(2) and<br>              signal(7)) and if this limit is reached, then the kernel<br>              reverts to delivering <b>SIGIO</b>, and this signal is delivered to<br>              the entire process rather than to a specific thread.<br><br>       Using these mechanisms, a program can implement fully asynchronous<br>       I/O without using select(2) or poll(2) most of the time.<br><br>       The use of <b>O_ASYNC </b>is specific to BSD and Linux.  The only use of<br>       <b>F_GETOWN </b>and <b>F_SETOWN </b>specified in POSIX.1 is in conjunction with the<br>       use of the <b>SIGURG </b>signal on sockets.  (POSIX does not specify the<br>       <b>SIGIO </b>signal.)  <b>F_GETOWN_EX</b>, <b>F_SETOWN_EX</b>, <b>F_GETSIG</b>, and <b>F_SETSIG </b>are<br>       Linux-specific.  POSIX has asynchronous I/O and the <i>aio_sigevent</i><br>       structure to achieve similar things; these are also available in<br>       Linux as part of the GNU C Library (Glibc).<br><br>   <b>Leases</b><br>       <b>F_SETLEASE </b>and <b>F_GETLEASE </b>(Linux 2.4 onward) are used (respectively)<br>       to establish a new lease, and retrieve the current lease, on the open<br>       file description referred to by the file descriptor <i>fd</i>.  A file lease<br>       provides a mechanism whereby the process holding the lease (the<br>       \"lease holder\") is notified (via delivery of a signal) when a process<br>       (the \"lease breaker\") tries to open(2) or truncate(2) the file<br>       referred to by that file descriptor.<br><br>       <b>F_SETLEASE </b>(<i>int</i>)<br>              Set or remove a file lease according to which of the following<br>              values is specified in the integer <i>arg</i>:<br><br>              <b>F_RDLCK</b><br>                     Take out a read lease.  This will cause the calling<br>                     process to be notified when the file is opened for<br>                     writing or is truncated.  A read lease can be placed<br>                     only on a file descriptor that is opened read-only.<br><br>              <b>F_WRLCK</b><br>                     Take out a write lease.  This will cause the caller to<br>                     be notified when the file is opened for reading or<br>                     writing or is truncated.  A write lease may be placed<br>                     on a file only if there are no other open file<br>                     descriptors for the file.<br><br>              <b>F_UNLCK</b><br>                     Remove our lease from the file.<br><br>       Leases are associated with an open file description (see open(2)).<br>       This means that duplicate file descriptors (created by, for example,<br>       fork(2) or dup(2)) refer to the same lease, and this lease may be<br>       modified or released using any of these descriptors.  Furthermore,<br>       the lease is released by either an explicit <b>F_UNLCK </b>operation on any<br>       of these duplicate descriptors, or when all such descriptors have<br>       been closed.<br><br>       Leases may be taken out only on regular files.  An unprivileged<br>       process may take out a lease only on a file whose UID (owner) matches<br>       the filesystem UID of the process.  A process with the <b>CAP_LEASE</b><br>       capability may take out leases on arbitrary files.<br><br>       <b>F_GETLEASE </b>(<i>void</i>)<br>              Indicates what type of lease is associated with the file<br>              descriptor <i>fd</i> by returning either <b>F_RDLCK</b>, <b>F_WRLCK</b>, or<br>              <b>F_UNLCK</b>, indicating, respectively, a read lease , a write<br>              lease, or no lease.  <i>arg</i> is ignored.<br><br>       When a process (the \"lease breaker\") performs an open(2) or<br>       truncate(2) that conflicts with a lease established via <b>F_SETLEASE</b>,<br>       the system call is blocked by the kernel and the kernel notifies the<br>       lease holder by sending it a signal (<b>SIGIO </b>by default).  The lease<br>       holder should respond to receipt of this signal by doing whatever<br>       cleanup is required in preparation for the file to be accessed by<br>       another process (e.g., flushing cached buffers) and then either<br>       remove or downgrade its lease.  A lease is removed by performing an<br>       <b>F_SETLEASE </b>command specifying <i>arg</i> as <b>F_UNLCK</b>.  If the lease holder<br>       currently holds a write lease on the file, and the lease breaker is<br>       opening the file for reading, then it is sufficient for the lease<br>       holder to downgrade the lease to a read lease.  This is done by<br>       performing an <b>F_SETLEASE </b>command specifying <i>arg</i> as <b>F_RDLCK</b>.<br><br>       If the lease holder fails to downgrade or remove the lease within the<br>       number of seconds specified in <i>/proc/sys/fs/lease-break-time</i>, then<br>       the kernel forcibly removes or downgrades the lease holder's lease.<br><br>       Once a lease break has been initiated, <b>F_GETLEASE </b>returns the target<br>       lease type (either <b>F_RDLCK </b>or <b>F_UNLCK</b>, depending on what would be<br>       compatible with the lease breaker) until the lease holder voluntarily<br>       downgrades or removes the lease or the kernel forcibly does so after<br>       the lease break timer expires.<br><br>       Once the lease has been voluntarily or forcibly removed or<br>       downgraded, and assuming the lease breaker has not unblocked its<br>       system call, the kernel permits the lease breaker's system call to<br>       proceed.<br><br>       If the lease breaker's blocked open(2) or truncate(2) is interrupted<br>       by a signal handler, then the system call fails with the error <b>EINTR</b>,<br>       but the other steps still occur as described above.  If the lease<br>       breaker is killed by a signal while blocked in open(2) or<br>       truncate(2), then the other steps still occur as described above.  If<br>       the lease breaker specifies the <b>O_NONBLOCK </b>flag when calling open(2),<br>       then the call immediately fails with the error <b>EWOULDBLOCK</b>, but the<br>       other steps still occur as described above.<br><br>       The default signal used to notify the lease holder is <b>SIGIO</b>, but this<br>       can be changed using the <b>F_SETSIG </b>command to <b>fcntl</b>().  If a <b>F_SETSIG</b><br>       command is performed (even one specifying <b>SIGIO</b>), and the signal<br>       handler is established using <b>SA_SIGINFO</b>, then the handler will<br>       receive a <i>siginfo_t</i> structure as its second argument, and the <i>si_fd</i><br>       field of this argument will hold the descriptor of the leased file<br>       that has been accessed by another process.  (This is useful if the<br>       caller holds leases against multiple files.)<br><br>   <b>File and directory change notification (dnotify)</b><br>       <b>F_NOTIFY </b>(<i>int</i>)<br>              (Linux 2.4 onward) Provide notification when the directory<br>              referred to by <i>fd</i> or any of the files that it contains is<br>              changed.  The events to be notified are specified in <i>arg</i>,<br>              which is a bit mask specified by ORing together zero or more<br>              of the following bits:<br><br>              <b>DN_ACCESS   </b>A file was accessed (read(2), pread(2), readv(2),<br>                          and similar)<br>              <b>DN_MODIFY   </b>A file was modified (write(2), pwrite(2),<br>                          writev(2), truncate(2), ftruncate(2), and<br>                          similar).<br>              <b>DN_CREATE   </b>A file was created (open(2), creat(2), mknod(2),<br>                          mkdir(2), link(2), symlink(2), rename(2) into this<br>                          directory).<br>              <b>DN_DELETE   </b>A file was unlinked (unlink(2), rename(2) to<br>                          another directory, rmdir(2)).<br>              <b>DN_RENAME   </b>A file was renamed within this directory<br>                          (rename(2)).<br>              <b>DN_ATTRIB   </b>The attributes of a file were changed (chown(2),<br>                          chmod(2), utime(2), utimensat(2), and similar).<br><br>              (In order to obtain these definitions, the <b>_GNU_SOURCE </b>feature<br>              test macro must be defined before including <i>any</i> header files.)<br><br>              Directory notifications are normally \"one-shot\", and the<br>              application must reregister to receive further notifications.<br>              Alternatively, if <b>DN_MULTISHOT </b>is included in <i>arg</i>, then<br>              notification will remain in effect until explicitly removed.<br><br>              A series of <b>F_NOTIFY </b>requests is cumulative, with the events<br>              in <i>arg</i> being added to the set already monitored.  To disable<br>              notification of all events, make an <b>F_NOTIFY </b>call specifying<br>              <i>arg</i> as 0.<br><br>              Notification occurs via delivery of a signal.  The default<br>              signal is <b>SIGIO</b>, but this can be changed using the <b>F_SETSIG</b><br>              command to <b>fcntl</b>().  (Note that <b>SIGIO </b>is one of the nonqueuing<br>              standard signals; switching to the use of a real-time signal<br>              means that multiple notifications can be queued to the<br>              process.)  In the latter case, the signal handler receives a<br>              <i>siginfo_t</i> structure as its second argument (if the handler was<br>              established using <b>SA_SIGINFO</b>) and the <i>si_fd</i> field of this<br>              structure contains the file descriptor which generated the<br>              notification (useful when establishing notification on<br>              multiple directories).<br><br>              Especially when using <b>DN_MULTISHOT</b>, a real time signal should<br>              be used for notification, so that multiple notifications can<br>              be queued.<br><br>              <b>NOTE: </b>New applications should use the <i>inotify</i> interface<br>              (available since kernel 2.6.13), which provides a much<br>              superior interface for obtaining notifications of filesystem<br>              events.  See inotify(7).<br><br>   <b>Changing the capacity of a pipe</b><br>       <b>F_SETPIPE_SZ </b>(<i>int</i>; since Linux 2.6.35)<br>              Change the capacity of the pipe referred to by <i>fd</i> to be at<br>              least <i>arg</i> bytes.  An unprivileged process can adjust the pipe<br>              capacity to any value between the system page size and the<br>              limit defined in <i>/proc/sys/fs/pipe-max-size</i> (see proc(5)).<br>              Attempts to set the pipe capacity below the page size are<br>              silently rounded up to the page size.  Attempts by an<br>              unprivileged process to set the pipe capacity above the limit<br>              in <i>/proc/sys/fs/pipe-max-size</i> yield the error <b>EPERM</b>; a<br>              privileged process (<b>CAP_SYS_RESOURCE</b>) can override the limit.<br>              When allocating the buffer for the pipe, the kernel may use a<br>              capacity larger than <i>arg</i>, if that is convenient for the<br>              implementation.  The actual capacity that is set is returned<br>              as the function result.  Attempting to set the pipe capacity<br>              smaller than the amount of buffer space currently used to<br>              store data produces the error <b>EBUSY</b>.<br><br>       <b>F_GETPIPE_SZ </b>(<i>void</i>; since Linux 2.6.35)<br>              Return (as the function result) the capacity of the pipe<br>              referred to by <i>fd</i>.<br><br>   <b>File Sealing</b><br>       File seals limit the set of allowed operations on a given file.  For<br>       each seal that is set on a file, a specific set of operations will<br>       fail with <b>EPERM </b>on this file from now on.  The file is said to be<br>       sealed.  The default set of seals depends on the type of the<br>       underlying file and filesystem.  For an overview of file sealing, a<br>       discussion of its purpose, and some code examples, see<br>       memfd_create(2).<br><br>       Currently, only the <i>tmpfs</i> filesystem supports sealing.  On other<br>       filesystems, all fcntl(2) operations that operate on seals will<br>       return <b>EINVAL</b>.<br><br>       Seals are a property of an inode.  Thus, all open file descriptors<br>       referring to the same inode share the same set of seals.<br>       Furthermore, seals can never be removed, only added.<br><br>       <b>F_ADD_SEALS </b>(<i>int</i>; since Linux 3.17)<br>              Add the seals given in the bit-mask argument <i>arg</i> to the set of<br>              seals of the inode referred to by the file descriptor <i>fd</i>.<br>              Seals cannot be removed again.  Once this call succeeds, the<br>              seals are enforced by the kernel immediately.  If the current<br>              set of seals includes <b>F_SEAL_SEAL </b>(see below), then this call<br>              will be rejected with <b>EPERM</b>.  Adding a seal that is already<br>              set is a no-op, in case <b>F_SEAL_SEAL </b>is not set already.  In<br>              order to place a seal, the file descriptor <i>fd</i> must be<br>              writable.<br><br>       <b>F_GET_SEALS </b>(<i>void</i>; since Linux 3.17)<br>              Return (as the function result) the current set of seals of<br>              the inode referred to by <i>fd</i>.  If no seals are set, 0 is<br>              returned.  If the file does not support sealing, -1 is<br>              returned and <i>errno</i> is set to <b>EINVAL</b>.<br><br>       The following seals are available:<br><br>       <b>F_SEAL_SEAL</b><br>              If this seal is set, any further call to fcntl(2) with<br>              <b>F_ADD_SEALS </b>will fail with <b>EPERM</b>.  Therefore, this seal<br>              prevents any modifications to the set of seals itself.  If the<br>              initial set of seals of a file includes <b>F_SEAL_SEAL</b>, then this<br>              effectively causes the set of seals to be constant and locked.<br><br>       <b>F_SEAL_SHRINK</b><br>              If this seal is set, the file in question cannot be reduced in<br>              size.  This affects open(2) with the <b>O_TRUNC </b>flag as well as<br>              truncate(2) and ftruncate(2).  Those calls will fail with<br>              <b>EPERM </b>if you try to shrink the file in question.  Increasing<br>              the file size is still possible.<br><br>       <b>F_SEAL_GROW</b><br>              If this seal is set, the size of the file in question cannot<br>              be increased.  This affects write(2) beyond the end of the<br>              file, truncate(2), ftruncate(2), and fallocate(2).  These<br>              calls will fail with <b>EPERM </b>if you use them to increase the<br>              file size.  If you keep the size or shrink it, those calls<br>              still work as expected.<br><br>       <b>F_SEAL_WRITE</b><br>              If this seal is set, you cannot modify the contents of the<br>              file.  Note that shrinking or growing the size of the file is<br>              still possible and allowed.  Thus, this seal is normally used<br>              in combination with one of the other seals.  This seal affects<br>              write(2) and fallocate(2) (only in combination with the<br>              <b>FALLOC_FL_PUNCH_HOLE </b>flag).  Those calls will fail with <b>EPERM</b><br>              if this seal is set.  Furthermore, trying to create new<br>              shared, writable memory-mappings via mmap(2) will also fail<br>              with <b>EPERM</b>.<br><br>              Setting <b>F_SEAL_WRITE </b>via fcntl(2) with <b>F_ADD_SEALS </b>will fail<br>              with <b>EBUSY </b>if any writable, shared mapping exists.  Such<br>              mappings must be unmapped before you can add this seal.<br>              Furthermore, if there are any asynchronous I/O operations<br>              (io_submit(2)) pending on the file, all outstanding writes<br>              will be discarded.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       For a successful call, the return value depends on the operation:<br><br>       <b>F_DUPFD  </b>The new descriptor.<br><br>       <b>F_GETFD  </b>Value of file descriptor flags.<br><br>       <b>F_GETFL  </b>Value of file status flags.<br><br>       <b>F_GETLEASE</b><br>                Type of lease held on file descriptor.<br><br>       <b>F_GETOWN </b>Value of descriptor owner.<br><br>       <b>F_GETSIG </b>Value of signal sent when read or write becomes possible, or<br>                zero for traditional <b>SIGIO </b>behavior.<br><br>       <b>F_GETPIPE_SZ</b>, <b>F_SETPIPE_SZ</b><br>                The pipe capacity.<br><br>       <b>F_GET_SEALS</b><br>                A bit mask identifying the seals that have been set for the<br>                inode referred to by <i>fd</i>.<br><br>       All other commands<br>                Zero.<br><br>       On error, -1 is returned, and <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EACCES </b>or <b>EAGAIN</b><br>              Operation is prohibited by locks held by other processes.<br><br>       <b>EAGAIN </b>The operation is prohibited because the file has been memory-<br>              mapped by another process.<br><br>       <b>EBADF  </b><i>fd</i> is not an open file descriptor<br><br>       <b>EBADF  </b><i>cmd</i> is <b>F_SETLK </b>or <b>F_SETLKW </b>and the file descriptor open mode<br>              doesn't match with the type of lock requested.<br><br>       <b>EBUSY  </b><i>cmd</i> is <b>F_SETPIPE_SZ </b>and the new pipe capacity specified in <i>arg</i><br>              is smaller than the amount of buffer space currently used to<br>              store data in the pipe.<br><br>       <b>EBUSY  </b><i>cmd</i> is <b>F_ADD_SEALS</b>, <i>arg</i> includes <b>F_SEAL_WRITE</b>, and there<br>              exists a writable, shared mapping on the file referred to by<br>              <i>fd</i>.<br><br>       <b>EDEADLK</b><br>              It was detected that the specified <b>F_SETLKW </b>command would<br>              cause a deadlock.<br><br>       <b>EFAULT </b><i>lock</i> is outside your accessible address space.<br><br>       <b>EINTR  </b><i>cmd</i> is <b>F_SETLKW </b>or <b>F_OFD_SETLKW </b>and the operation was<br>              interrupted by a signal; see signal(7).<br><br>       <b>EINTR  </b><i>cmd</i> is <b>F_GETLK</b>, <b>F_SETLK</b>, <b>F_OFD_GETLK</b>, or <b>F_OFD_SETLK</b>, and the<br>              operation was interrupted by a signal before the lock was<br>              checked or acquired.  Most likely when locking a remote file<br>              (e.g., locking over NFS), but can sometimes happen locally.<br><br>       <b>EINVAL </b>The value specified in <i>cmd</i> is not recognized by this kernel.<br><br>       <b>EINVAL </b><i>cmd</i> is <b>F_ADD_SEALS </b>and <i>arg</i> includes an unrecognized sealing<br>              bit.<br><br>       <b>EINVAL </b><i>cmd</i> is <b>F_ADD_SEALS </b>or <b>F_GET_SEALS </b>and the filesystem<br>              containing the inode referred to by <i>fd</i> does not support<br>              sealing.<br><br>       <b>EINVAL </b><i>cmd</i> is <b>F_DUPFD </b>and <i>arg</i> is negative or is greater than the<br>              maximum allowable value (see the discussion of <b>RLIMIT_NOFILE</b><br>              in getrlimit(2)).<br><br>       <b>EINVAL </b><i>cmd</i> is <b>F_SETSIG </b>and <i>arg</i> is not an allowable signal number.<br><br>       <b>EINVAL </b><i>cmd</i> is <b>F_OFD_SETLK</b>, <b>F_OFD_SETLKW</b>, or <b>F_OFD_GETLK</b>, and <i>l_pid</i><br>              was not specified as zero.<br><br>       <b>EMFILE </b><i>cmd</i> is <b>F_DUPFD </b>and the process already has the maximum number<br>              of file descriptors open.<br><br>       <b>ENOLCK </b>Too many segment locks open, lock table is full, or a remote<br>              locking protocol failed (e.g., locking over NFS).<br><br>       <b>ENOTDIR</b><br>              <b>F_NOTIFY </b>was specified in <i>cmd</i>, but <i>fd</i> does not refer to a<br>              directory.<br><br>       <b>EPERM  </b>Attempted to clear the <b>O_APPEND </b>flag on a file that has the<br>              append-only attribute set.<br><br>       <b>EPERM  </b><i>cmd</i> was <b>F_ADD_SEALS</b>, but <i>fd</i> was not open for writing or the<br>              current set of seals on the file already includes <b>F_SEAL_SEAL</b>.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       SVr4, 4.3BSD, POSIX.1-2001.  Only the operations <b>F_DUPFD</b>, <b>F_GETFD</b>,<br>       <b>F_SETFD</b>, <b>F_GETFL</b>, <b>F_SETFL</b>, <b>F_GETLK</b>, <b>F_SETLK</b>, and <b>F_SETLKW </b>are<br>       specified in POSIX.1-2001.<br><br>       <b>F_GETOWN </b>and <b>F_SETOWN </b>are specified in POSIX.1-2001.  (To get their<br>       definitions, define either <b>_BSD_SOURCE</b>, or <b>_XOPEN_SOURCE </b>with the<br>       value 500 or greater, or <b>_POSIX_C_SOURCE </b>with the value 200809L or<br>       greater.)<br><br>       <b>F_DUPFD_CLOEXEC </b>is specified in POSIX.1-2008.  (To get this<br>       definition, define <b>_POSIX_C_SOURCE </b>with the value 200809L or greater,<br>       or <b>_XOPEN_SOURCE </b>with the value 700 or greater.)<br><br>       <b>F_GETOWN_EX</b>, <b>F_SETOWN_EX</b>, <b>F_SETPIPE_SZ</b>, <b>F_GETPIPE_SZ</b>, <b>F_GETSIG</b>,<br>       <b>F_SETSIG</b>, <b>F_NOTIFY</b>, <b>F_GETLEASE</b>, and <b>F_SETLEASE </b>are Linux-specific.<br>       (Define the <b>_GNU_SOURCE </b>macro to obtain these definitions.)<br><br>       <b>F_OFD_SETLK</b>, <b>F_OFD_SETLKW</b>, and <b>F_OFD_GETLK </b>are Linux-specific (and<br>       one must define <b>_GNU_SOURCE </b>to obtain their definitions), but work is<br>       being done to have them included in the next version of POSIX.1.<br><br>       <b>F_ADD_SEALS </b>and <b>F_GET_SEALS </b>are Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       The errors returned by dup2(2) are different from those returned by<br>       <b>F_DUPFD</b>.<br><br>   <b>File locking</b><br>       The original Linux <b>fcntl</b>() system call was not designed to handle<br>       large file offsets (in the <i>flock</i> structure).  Consequently, an<br>       <b>fcntl64</b>() system call was added in Linux 2.4.  The newer system call<br>       employs a different structure for file locking, <i>flock64</i>, and<br>       corresponding commands, <b>F_GETLK64</b>, <b>F_SETLK64</b>, and <b>F_SETLKW64</b>.<br>       However, these details can be ignored by applications using glibc,<br>       whose <b>fcntl</b>() wrapper function transparently employs the more recent<br>       system call where it is available.<br><br>       The errors returned by dup2(2) are different from those returned by<br>       <b>F_DUPFD</b>.<br><br>   <b>Record locks</b><br>       Since kernel 2.0, there is no interaction between the types of lock<br>       placed by flock(2) and <b>fcntl</b>().<br><br>       Several systems have more fields in <i>struct flock</i> such as, for<br>       example, <i>l_sysid</i>.  Clearly, <i>l_pid</i> alone is not going to be very<br>       useful if the process holding the lock may live on a different<br>       machine.<br><br>       The original Linux <b>fcntl</b>() system call was not designed to handle<br>       large file offsets (in the <i>flock</i> structure).  Consequently, an<br>       <b>fcntl64</b>() system call was added in Linux 2.4.  The newer system call<br>       employs a different structure for file locking, <i>flock64</i>, and<br>       corresponding commands, <b>F_GETLK64</b>, <b>F_SETLK64</b>, and <b>F_SETLKW64</b>.<br>       However, these details can be ignored by applications using glibc,<br>       whose <b>fcntl</b>() wrapper function transparently employs the more recent<br>       system call where it is available.<br><br>   <b>Record locking and NFS</b><br>       Before Linux 3.12, if an NFSv4 client loses contact with the server<br>       for a period of time (defined as more than 90 seconds with no<br>       communication), it might lose and regain a lock without ever being<br>       aware of the fact.  (The period of time after which contact is<br>       assumed lost is known as the NFSv4 leasetime.  On a Linux NFS server,<br>       this can be determined by looking at <i>/proc/fs/nfsd/nfsv4leasetime</i>,<br>       which expresses the period in seconds.  The default value for this<br>       file is 90.)  This scenario potentially risks data corruption, since<br>       another process might acquire a lock in the intervening period and<br>       perform file I/O.<br><br>       Since Linux 3.12, if an NFSv4 client loses contact with the server,<br>       any I/O to the file by a process which \"thinks\" it holds a lock will<br>       fail until that process closes and reopens the file.  A kernel<br>       parameter, <i>nfs.recover_lost_locks</i>, can be set to 1 to obtain the<br>       pre-3.12 behavior, whereby the client will attempt to recover lost<br>       locks when contact is reestablished with the server.  Because of the<br>       attendant risk of data corruption, this parameter defaults to 0<br>       (disabled).<br></pre><br><h2>BUGS  </h2><pre><br>   <b>F_SETFL</b><br>       It is not possible to use <b>F_SETFL </b>to change the state of the <b>O_DSYNC</b><br>       and <b>O_SYNC </b>flags.  Attempts to change the state of these flags are<br>       silently ignored.<br><br>   <b>F_GETOWN</b><br>       A limitation of the Linux system call conventions on some<br>       architectures (notably i386) means that if a (negative) process group<br>       ID to be returned by <b>F_GETOWN </b>falls in the range -1 to -4095, then<br>       the return value is wrongly interpreted by glibc as an error in the<br>       system call; that is, the return value of <b>fcntl</b>() will be -1, and<br>       <i>errno</i> will contain the (positive) process group ID.  The Linux-<br>       specific <b>F_GETOWN_EX </b>operation avoids this problem.  Since glibc<br>       version 2.11, glibc makes the kernel <b>F_GETOWN </b>problem invisible by<br>       implementing <b>F_GETOWN </b>using <b>F_GETOWN_EX</b>.<br><br>   <b>F_SETOWN</b><br>       In Linux 2.4 and earlier, there is bug that can occur when an<br>       unprivileged process uses <b>F_SETOWN </b>to specify the owner of a socket<br>       file descriptor as a process (group) other than the caller.  In this<br>       case, <b>fcntl</b>() can return -1 with <i>errno</i> set to <b>EPERM</b>, even when the<br>       owner process (group) is one that the caller has permission to send<br>       signals to.  Despite this error return, the file descriptor owner is<br>       set, and signals will be sent to the owner.<br><br>   <b>Deadlock detection</b><br>       The deadlock-detection algorithm employed by the kernel when dealing<br>       with <b>F_SETLKW </b>requests can yield both false negatives (failures to<br>       detect deadlocks, leaving a set of deadlocked processes blocked<br>       indefinitely) and false positives (<b>EDEADLK </b>errors when there is no<br>       deadlock).  For example, the kernel limits the lock depth of its<br>       dependency search to 10 steps, meaning that circular deadlock chains<br>       that exceed that size will not be detected.  In addition, the kernel<br>       may falsely indicate a deadlock when two or more processes created<br>       using the clone(2) <b>CLONE_FILES </b>flag place locks that appear (to the<br>       kernel) to conflict.<br><br>   <b>Mandatory locking</b><br>       The Linux implementation of mandatory locking is subject to race<br>       conditions which render it unreliable: a write(2) call that overlaps<br>       with a lock may modify data after the mandatory lock is acquired; a<br>       read(2) call that overlaps with a lock may detect changes to data<br>       that were made only after a write lock was acquired.  Similar races<br>       exist between mandatory locks and mmap(2).  It is therefore<br>       inadvisable to rely on mandatory locking.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       dup2(2), flock(2), open(2), socket(2), lockf(3), capabilities(7),<br>       feature_test_macros(7)<br><br>       <i>locks.txt</i>, <i>mandatory-locking.txt</i>, and <i>dnotify.txt</i> in the Linux kernel<br>       source directory <i>Documentation/filesystems/</i> (on older kernels, these<br>       files are directly under the <i>Documentation/</i> directory, and <i>mandatory-</i><br>       <i>locking.txt</i> is called <i>mandatory.txt</i>)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-05-07                         FCNTL(2)</span><br></pre><br>"}