{"Man page": "<pre><br><span class=\"headline\">MADVISE(2)                Linux Programmer's Manual               MADVISE(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       madvise - give advice about use of memory<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/mman.h&gt;</b><br><br>       <b>int madvise(void *</b><i>addr</i><b>, size_t </b><i>length</i><b>, int </b><i>advice</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>madvise</b>(): _BSD_SOURCE<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>madvise</b>() system call is used to give advice or directions to the<br>       kernel about the address range beginning at address <i>addr</i> and with<br>       size <i>length</i> bytes.  Initially, the system call supported a set of<br>       \"conventional\" <i>advice</i> values, which are also available on several<br>       other implementations.  (Note, though, that <b>madvise</b>() is not<br>       specified in POSIX.)  Subsequently, a number of Linux-specific <i>advice</i><br>       values have been added.<br><br>   <b>Conventional advice values</b><br>       The <i>advice</i> values listed below allow an application to tell the<br>       kernel how it expects to use some mapped or shared memory areas, so<br>       that the kernel can choose appropriate read-ahead and caching<br>       techniques.  These <i>advice</i> values do not influence the semantics of<br>       the application (except in the case of <b>MADV_DONTNEED</b>), but may<br>       influence its performance.  All of the <i>advice</i> values listed here have<br>       analogs in the POSIX-specified posix_madvise(3) function, and the<br>       values have the same meanings, with the exception of <b>MADV_DONTNEED</b>.<br><br>       The advice is indicated in the <i>advice</i> argument, which is one of the<br>       following:<br><br>       <b>MADV_NORMAL</b><br>              No special treatment.  This is the default.<br><br>       <b>MADV_RANDOM</b><br>              Expect page references in random order.  (Hence, read ahead<br>              may be less useful than normally.)<br><br>       <b>MADV_SEQUENTIAL</b><br>              Expect page references in sequential order.  (Hence, pages in<br>              the given range can be aggressively read ahead, and may be<br>              freed soon after they are accessed.)<br><br>       <b>MADV_WILLNEED</b><br>              Expect access in the near future.  (Hence, it might be a good<br>              idea to read some pages ahead.)<br><br>       <b>MADV_DONTNEED</b><br>              Do not expect access in the near future.  (For the time being,<br>              the application is finished with the given range, so the<br>              kernel can free resources associated with it.)<br><br>              After a successful <b>MADV_DONTNEED </b>operation, the semantics of<br>              memory access in the specified region are changed: subsequent<br>              accesses of pages in the range will succeed, but will result<br>              in either repopulating the memory contents from the up-to-date<br>              contents of the underlying mapped file (for shared file<br>              mappings, shared anonymous mappings, and shmem-based<br>              techniques such as System V shared memory segments) or zero-<br>              fill-on-demand pages for anonymous private mappings.<br><br>              Note that, when applied to shared mappings, <b>MADV_DONTNEED</b><br>              might not lead to immediate freeing of the pages in the range.<br>              The kernel is free to delay freeing the pages until an<br>              appropriate moment.  The resident set size (RSS) of the<br>              calling process will be immediately reduced however.<br><br>              <b>MADV_DONTNEED </b>cannot be applied to locked pages, Huge TLB<br>              pages, or <b>VM_PFNMAP </b>pages.  (Pages marked with the kernel-<br>              internal <b>VM_PFNMAP </b>flag are special memory areas that are not<br>              managed by the virtual memory subsystem.  Such pages are<br>              typically created by device drivers that map the pages into<br>              user space.)<br><br>   <b>Linux-specific advice values</b><br>       The following Linux-specific <i>advice</i> values have no counterparts in<br>       the POSIX-specified posix_madvise(3), and may or may not have<br>       counterparts in the <b>madvise</b>() interface available on other<br>       implementations.  Note that some of these operations change the<br>       semantics of memory accesses.<br><br>       <b>MADV_REMOVE </b>(since Linux 2.6.16)<br>              Free up a given range of pages and its associated backing<br>              store.  This is equivalent to punching a hole in the<br>              corresponding byte range of the backing store (see<br>              fallocate(2)).  Subsequent accesses in the specified address<br>              range will see bytes containing zero.<br><br>              The specified address range must be mapped shared and<br>              writable.  This flag cannot be applied to locked pages, Huge<br>              TLB pages, or <b>VM_PFNMAP </b>pages.<br><br>              In the initial implementation, only shmfs/tmpfs supported<br>              <b>MADV_REMOVE</b>; but since Linux 3.5, any filesystem which<br>              supports the fallocate(2) <b>FALLOC_FL_PUNCH_HOLE </b>mode also<br>              supports <b>MADV_REMOVE</b>.  Hugetlbfs will fail with the error<br>              <b>EINVAL </b>and other filesystems fail with the error <b>EOPNOTSUPP</b>.<br><br>       <b>MADV_DONTFORK </b>(since Linux 2.6.16)<br>              Do not make the pages in this range available to the child<br>              after a fork(2).  This is useful to prevent copy-on-write<br>              semantics from changing the physical location of a page if the<br>              parent writes to it after a fork(2).  (Such page relocations<br>              cause problems for hardware that DMAs into the page.)<br><br>       <b>MADV_DOFORK </b>(since Linux 2.6.16)<br>              Undo the effect of <b>MADV_DONTFORK</b>, restoring the default<br>              behavior, whereby a mapping is inherited across fork(2).<br><br>       <b>MADV_HWPOISON </b>(since Linux 2.6.32)<br>              Poison a page and handle it like a hardware memory corruption.<br>              This operation is available only for privileged<br>              (<b>CAP_SYS_ADMIN</b>) processes.  This operation may result in the<br>              calling process receiving a <b>SIGBUS </b>and the page being<br>              unmapped.<br><br>              This feature is intended for testing of memory error-handling<br>              code; it is available only if the kernel was configured with<br>              <b>CONFIG_MEMORY_FAILURE</b>.<br><br>       <b>MADV_SOFT_OFFLINE </b>(since Linux 2.6.33)<br>              Soft offline the pages in the range specified by <i>addr</i> and<br>              <i>length</i>.  The memory of each page in the specified range is<br>              preserved (i.e., when next accessed, the same content will be<br>              visible, but in a new physical page frame), and the original<br>              page is offlined (i.e., no longer used, and taken out of<br>              normal memory management).  The effect of the<br>              <b>MADV_SOFT_OFFLINE </b>operation is invisible to (i.e., does not<br>              change the semantics of) the calling process.<br><br>              This feature is intended for testing of memory error-handling<br>              code; it is available only if the kernel was configured with<br>              <b>CONFIG_MEMORY_FAILURE</b>.<br><br>       <b>MADV_MERGEABLE </b>(since Linux 2.6.32)<br>              Enable Kernel Samepage Merging (KSM) for the pages in the<br>              range specified by <i>addr</i> and <i>length</i>.  The kernel regularly<br>              scans those areas of user memory that have been marked as<br>              mergeable, looking for pages with identical content.  These<br>              are replaced by a single write-protected page (which is<br>              automatically copied if a process later wants to update the<br>              content of the page).  KSM merges only private anonymous pages<br>              (see mmap(2)).<br><br>              The KSM feature is intended for applications that generate<br>              many instances of the same data (e.g., virtualization systems<br>              such as KVM).  It can consume a lot of processing power; use<br>              with care.  See the Linux kernel source file<br>              <i>Documentation/vm/ksm.txt</i> for more details.<br><br>              The <b>MADV_MERGEABLE </b>and <b>MADV_UNMERGEABLE </b>operations are<br>              available only if the kernel was configured with <b>CONFIG_KSM</b>.<br><br>       <b>MADV_UNMERGEABLE </b>(since Linux 2.6.32)<br>              Undo the effect of an earlier <b>MADV_MERGEABLE </b>operation on the<br>              specified address range; KSM unmerges whatever pages it had<br>              merged in the address range specified by <i>addr</i> and <i>length</i>.<br><br>       <b>MADV_HUGEPAGE </b>(since Linux 2.6.38)<br>              Enable Transparent Huge Pages (THP) for pages in the range<br>              specified by <i>addr</i> and <i>length</i>.  Currently, Transparent Huge<br>              Pages work only with private anonymous pages (see mmap(2)).<br>              The kernel will regularly scan the areas marked as huge page<br>              candidates to replace them with huge pages.  The kernel will<br>              also allocate huge pages directly when the region is naturally<br>              aligned to the huge page size (see <b>posix_memalign</b>(2)).<br><br>              This feature is primarily aimed at applications that use large<br>              mappings of data and access large regions of that memory at a<br>              time (e.g., virtualization systems such as QEMU).  It can very<br>              easily waste memory (e.g., a 2MB mapping that only ever<br>              accesses 1 byte will result in 2MB of wired memory instead of<br>              one 4KB page).  See the Linux kernel source file<br>              <i>Documentation/vm/transhuge.txt</i> for more details.<br><br>              The <b>MADV_HUGEPAGE </b>and <b>MADV_NOHUGEPAGE </b>operations are available<br>              only if the kernel was configured with<br>              <b>CONFIG_TRANSPARENT_HUGEPAGE</b>.<br><br>       <b>MADV_NOHUGEPAGE </b>(since Linux 2.6.38)<br>              Ensures that memory in the address range specified by <i>addr</i> and<br>              <i>length</i> will not be collapsed into huge pages.<br><br>       <b>MADV_DONTDUMP </b>(since Linux 3.4)<br>              Exclude from a core dump those pages in the range specified by<br>              <i>addr</i> and <i>length</i>.  This is useful in applications that have<br>              large areas of memory that are known not to be useful in a<br>              core dump.  The effect of <b>MADV_DONTDUMP </b>takes precedence over<br>              the bit mask that is set via the <i>/proc/PID/coredump_filter</i><br>              file (see core(5)).<br><br>       <b>MADV_DODUMP </b>(since Linux 3.4)<br>              Undo the effect of an earlier <b>MADV_DONTDUMP</b>.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>madvise</b>() returns zero.  On error, it returns -1 and<br>       <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EACCES </b><i>advice</i> is <b>MADV_REMOVE</b>, but the specified address range is not<br>              a shared writable mapping.<br><br>       <b>EAGAIN </b>A kernel resource was temporarily unavailable.<br><br>       <b>EBADF  </b>The map exists, but the area maps something that isn't a file.<br><br>       <b>EINVAL </b><i>addr</i> is not page-aligned or <i>length</i> is negative.<br><br>       <b>EINVAL </b><i>advice</i> is not a valid.<br><br>       <b>EINVAL </b><i>advice</i> is <b>MADV_DONTNEED </b>or <b>MADV_REMOVE </b>and the specified<br>              address range includes locked, Huge TLB pages, or <b>VM_PFNMAP</b><br>              pages.<br><br>       <b>EINVAL </b><i>advice</i> is <b>MADV_MERGEABLE </b>or <b>MADV_UNMERGEABLE</b>, but the kernel<br>              was not configured with <b>CONFIG_KSM</b>.<br><br>       <b>EIO    </b>(for <b>MADV_WILLNEED</b>) Paging in this area would exceed the<br>              process's maximum resident set size.<br><br>       <b>ENOMEM </b>(for <b>MADV_WILLNEED</b>) Not enough memory: paging in failed.<br><br>       <b>ENOMEM </b>Addresses in the specified range are not currently mapped, or<br>              are outside the address space of the process.<br><br>       <b>EPERM  </b><i>advice</i> is <b>MADV_HWPOISON</b>, but the caller does not have the<br>              <b>CAP_SYS_ADMIN </b>capability.<br></pre><br><h2>VERSIONS  </h2><pre><br>       Since Linux 3.18, support for this system call is optional, depending<br>       on the setting of the <b>CONFIG_ADVISE_SYSCALLS </b>configuration option.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>madvise</b>() is not specified by any standards.  Versions of this system<br>       call, implementing a wide variety of <i>advice</i> values, exist on many<br>       other implementations.  Other implementations typically implement at<br>       least the flags listed above under <i>Conventional advice flags</i>, albeit<br>       with some variation in semantics.<br><br>       POSIX.1-2001 describes posix_madvise(3) with constants<br>       <b>POSIX_MADV_NORMAL</b>, <b>POSIX_MADV_RANDOM</b>, <b>POSIX_MADV_SEQUENTIAL</b>,<br>       <b>POSIX_MADV_WILLNEED</b>, and <b>POSIX_MADV_DONTNEED</b>, and so on, with<br>       behavior close to the similarly named flags listed above.<br>       (POSIX.1-2008 adds a further flag, <b>POSIX_MADV_NOREUSE</b>, that has no<br>       analog in madvise(2).)<br></pre><br><h2>NOTES  </h2><pre><br>   <b>Linux notes</b><br>       The Linux implementation requires that the address <i>addr</i> be page-<br>       aligned, and allows <i>length</i> to be zero.  If there are some parts of<br>       the specified address range that are not mapped, the Linux version of<br>       <b>madvise</b>() ignores them and applies the call to the rest (but returns<br>       <b>ENOMEM </b>from the system call, as it should).<br></pre><br><h2>SEE ALSO  </h2><pre><br>       getrlimit(2), mincore(2), mmap(2), mprotect(2), msync(2), munmap(2),<br>       posix_madvise(3), prctl(2), core(5)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-04-19                       MADVISE(2)</span><br></pre><br>"}