{"Man page": "<pre><br><span class=\"headline\">RECV(2)                   Linux Programmer's Manual                  RECV(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       recv, recvfrom, recvmsg - receive a message from a socket<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/types.h&gt;</b><br>       <b>#include &lt;sys/socket.h&gt;</b><br><br>       <b>ssize_t recv(int </b><i>sockfd</i><b>, void *</b><i>buf</i><b>, size_t </b><i>len</i><b>, int </b><i>flags</i><b>);</b><br><br>       <b>ssize_t recvfrom(int </b><i>sockfd</i><b>, void *</b><i>buf</i><b>, size_t </b><i>len</i><b>, int </b><i>flags</i><b>,</b><br>                        <b>struct sockaddr *</b><i>src_addr</i><b>, socklen_t *</b><i>addrlen</i><b>);</b><br><br>       <b>ssize_t recvmsg(int </b><i>sockfd</i><b>, struct msghdr *</b><i>msg</i><b>, int </b><i>flags</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>recv</b>(), <b>recvfrom</b>(), and <b>recvmsg</b>() calls are used to receive<br>       messages from a socket.  They may be used to receive data on both<br>       connectionless and connection-oriented sockets.  This page first<br>       describes common features of all three system calls, and then<br>       describes the differences between the calls.<br><br>       All three calls return the length of the message on successful<br>       completion.  If a message is too long to fit in the supplied buffer,<br>       excess bytes may be discarded depending on the type of socket the<br>       message is received from.<br><br>       If no messages are available at the socket, the receive calls wait<br>       for a message to arrive, unless the socket is nonblocking (see<br>       fcntl(2)), in which case the value -1 is returned and the external<br>       variable <i>errno</i> is set to <b>EAGAIN </b>or <b>EWOULDBLOCK</b>.  The receive calls<br>       normally return any data available, up to the requested amount,<br>       rather than waiting for receipt of the full amount requested.<br><br>       An application can use select(2), poll(2), or epoll(7) to determine<br>       when more data arrives on a socket.<br><br>   <b>The flags argument</b><br>       The <i>flags</i> argument is formed by ORing one or more of the following<br>       values:<br><br>       <b>MSG_CMSG_CLOEXEC </b>(<b>recvmsg</b>() only; since Linux 2.6.23)<br>              Set the close-on-exec flag for the file descriptor received<br>              via a UNIX domain file descriptor using the <b>SCM_RIGHTS</b><br>              operation (described in unix(7)).  This flag is useful for the<br>              same reasons as the <b>O_CLOEXEC </b>flag of open(2).<br><br>       <b>MSG_DONTWAIT </b>(since Linux 2.2)<br>              Enables nonblocking operation; if the operation would block,<br>              the call fails with the error <b>EAGAIN </b>or <b>EWOULDBLOCK</b>.  This<br>              provides similar behavior to setting the <b>O_NONBLOCK </b>flag (via<br>              the fcntl(2) <b>F_SETFL </b>operation), but differs in that<br>              <b>MSG_DONTWAIT </b>is a per-call option, whereas <b>O_NONBLOCK </b>is a<br>              setting on the open file description (see open(2)), which will<br>              affect all threads in the calling process and as well as other<br>              processes that hold file descriptors referring to the same<br>              open file description.<br><br>       <b>MSG_ERRQUEUE </b>(since Linux 2.2)<br>              This flag specifies that queued errors should be received from<br>              the socket error queue.  The error is passed in an ancillary<br>              message with a type dependent on the protocol (for IPv4<br>              <b>IP_RECVERR</b>).  The user should supply a buffer of sufficient<br>              size.  See cmsg(3) and ip(7) for more information.  The<br>              payload of the original packet that caused the error is passed<br>              as normal data via <i>msg_iovec</i>.  The original destination<br>              address of the datagram that caused the error is supplied via<br>              <i>msg_name</i>.<br><br>              For local errors, no address is passed (this can be checked<br>              with the <i>cmsg_len</i> member of the <i>cmsghdr</i>).  For error receives,<br>              the <b>MSG_ERRQUEUE </b>is set in the <i>msghdr</i>.  After an error has<br>              been passed, the pending socket error is regenerated based on<br>              the next queued error and will be passed on the next socket<br>              operation.<br><br>              The error is supplied in a <i>sock_extended_err</i> structure:<br><br>                  #define SO_EE_ORIGIN_NONE    0<br>                  #define SO_EE_ORIGIN_LOCAL   1<br>                  #define SO_EE_ORIGIN_ICMP    2<br>                  #define SO_EE_ORIGIN_ICMP6   3<br><br>                  struct sock_extended_err<br>                  {<br>                      uint32_t ee_errno;   /* error number */<br>                      uint8_t  ee_origin;  /* where the error originated */<br>                      uint8_t  ee_type;    /* type */<br>                      uint8_t  ee_code;    /* code */<br>                      uint8_t  ee_pad;     /* padding */<br>                      uint32_t ee_info;    /* additional information */<br>                      uint32_t ee_data;    /* other data */<br>                      /* More data may follow */<br>                  };<br><br>                  struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);<br><br>              <i>ee_errno</i> contains the <i>errno</i> number of the queued error.<br>              <i>ee_origin</i> is the origin code of where the error originated.<br>              The other fields are protocol-specific.  The macro<br>              <b>SOCK_EE_OFFENDER </b>returns a pointer to the address of the<br>              network object where the error originated from given a pointer<br>              to the ancillary message.  If this address is not known, the<br>              <i>sa_family</i> member of the <i>sockaddr</i> contains <b>AF_UNSPEC </b>and the<br>              other fields of the <i>sockaddr</i> are undefined.  The payload of<br>              the packet that caused the error is passed as normal data.<br><br>              For local errors, no address is passed (this can be checked<br>              with the <i>cmsg_len</i> member of the <i>cmsghdr</i>).  For error receives,<br>              the <b>MSG_ERRQUEUE </b>is set in the <i>msghdr</i>.  After an error has<br>              been passed, the pending socket error is regenerated based on<br>              the next queued error and will be passed on the next socket<br>              operation.<br><br>       <b>MSG_OOB</b><br>              This flag requests receipt of out-of-band data that would not<br>              be received in the normal data stream.  Some protocols place<br>              expedited data at the head of the normal data queue, and thus<br>              this flag cannot be used with such protocols.<br><br>       <b>MSG_PEEK</b><br>              This flag causes the receive operation to return data from the<br>              beginning of the receive queue without removing that data from<br>              the queue.  Thus, a subsequent receive call will return the<br>              same data.<br><br>       <b>MSG_TRUNC </b>(since Linux 2.2)<br>              For raw (<b>AF_PACKET</b>), Internet datagram (since Linux<br>              2.4.27/2.6.8), netlink (since Linux 2.6.22), and UNIX datagram<br>              (since Linux 3.4) sockets: return the real length of the<br>              packet or datagram, even when it was longer than the passed<br>              buffer.<br><br>              For use with Internet stream sockets, see tcp(7).<br><br>       <b>MSG_WAITALL </b>(since Linux 2.2)<br>              This flag requests that the operation block until the full<br>              request is satisfied.  However, the call may still return less<br>              data than requested if a signal is caught, an error or<br>              disconnect occurs, or the next data to be received is of a<br>              different type than that returned.<br><br>   <b>recvfrom()</b><br>       <b>recvfrom</b>() places the received message into the buffer <i>buf</i>.  The<br>       caller must specify the size of the buffer in <i>len</i>.<br><br>       If <i>src_addr</i> is not NULL, and the underlying protocol provides the<br>       source address of the message, that source address is placed in the<br>       buffer pointed to by <i>src_addr</i>.  In this case, <i>addrlen</i> is a value-<br>       result argument.  Before the call, it should be initialized to the<br>       size of the buffer associated with <i>src_addr</i>.  Upon return, <i>addrlen</i> is<br>       updated to contain the actual size of the source address.  The<br>       returned address is truncated if the buffer provided is too small; in<br>       this case, <i>addrlen</i> will return a value greater than was supplied to<br>       the call.<br><br>       If the caller is not interested in the source address, <i>src_addr</i> and<br>       <i>addrlen</i> should be specified as NULL.<br><br>   <b>recv()</b><br>       The <b>recv</b>() call is normally used only on a <i>connected</i> socket (see<br>       connect(2)).  It is equivalent to the call:<br><br>           recvfrom(fd, buf, len, flags, NULL, 0));<br><br>   <b>recvmsg()</b><br>       The <b>recvmsg</b>() call uses a <i>msghdr</i> structure to minimize the number of<br>       directly supplied arguments.  This structure is defined as follows in<br>       <i>&lt;sys/socket.h&gt;</i>:<br><br>           struct iovec {                    /* Scatter/gather array items */<br>               void  *iov_base;              /* Starting address */<br>               size_t iov_len;               /* Number of bytes to transfer */<br>           };<br><br>           struct msghdr {<br>               void         *msg_name;       /* optional address */<br>               socklen_t     msg_namelen;    /* size of address */<br>               struct iovec *msg_iov;        /* scatter/gather array */<br>               size_t        msg_iovlen;     /* # elements in msg_iov */<br>               void         *msg_control;    /* ancillary data, see below */<br>               size_t        msg_controllen; /* ancillary data buffer len */<br>               int           msg_flags;      /* flags on received message */<br>           };<br><br>       The <i>msg_name</i> field points to a caller-allocated buffer that is used<br>       to return the source address if the socket is unconnected.  The<br>       caller should set <i>msg_namelen</i> to the size of this buffer before this<br>       call; upon return from a successful call, <i>msg_namelen</i> will contain<br>       the length of the returned address.  If the application does not need<br>       to know the source address, <i>msg_name</i> can be specified as NULL.<br><br>       The fields <i>msg_iov</i> and <i>msg_iovlen</i> describe scatter-gather locations,<br>       as discussed in readv(2).<br><br>       The field <i>msg_control</i>, which has length <i>msg_controllen</i>, points to a<br>       buffer for other protocol control-related messages or miscellaneous<br>       ancillary data.  When <b>recvmsg</b>() is called, <i>msg_controllen</i> should<br>       contain the length of the available buffer in <i>msg_control</i>; upon<br>       return from a successful call it will contain the length of the<br>       control message sequence.<br><br>       The messages are of the form:<br><br>           struct cmsghdr {<br>               socklen_t     cmsg_len;     /* data byte count, including hdr */<br>               int           cmsg_level;   /* originating protocol */<br>               int           cmsg_type;    /* protocol-specific type */<br>           /* followed by<br>               unsigned char cmsg_data[]; */<br>           };<br><br>       Ancillary data should be accessed only by the macros defined in<br>       cmsg(3).<br><br>       As an example, Linux uses this ancillary data mechanism to pass<br>       extended errors, IP options, or file descriptors over UNIX domain<br>       sockets.<br><br>       The <i>msg_flags</i> field in the <i>msghdr</i> is set on return of <b>recvmsg</b>().  It<br>       can contain several flags:<br><br>       <b>MSG_EOR</b><br>              indicates end-of-record; the data returned completed a record<br>              (generally used with sockets of type <b>SOCK_SEQPACKET</b>).<br><br>       <b>MSG_TRUNC</b><br>              indicates that the trailing portion of a datagram was<br>              discarded because the datagram was larger than the buffer<br>              supplied.<br><br>       <b>MSG_CTRUNC</b><br>              indicates that some control data were discarded due to lack of<br>              space in the buffer for ancillary data.<br><br>       <b>MSG_OOB</b><br>              is returned to indicate that expedited or out-of-band data<br>              were received.<br><br>       <b>MSG_ERRQUEUE</b><br>              indicates that no data was received but an extended error from<br>              the socket error queue.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       These calls return the number of bytes received, or -1 if an error<br>       occurred.  In the event of an error, <i>errno</i> is set to indicate the<br>       error.<br><br>       When a stream socket peer has performed an orderly shutdown, the<br>       return value will be 0 (the traditional \"end-of-file\" return).<br><br>       Datagram sockets in various domains (e.g., the UNIX and Internet<br>       domains) permit zero-length datagrams.  When such a datagram is<br>       received, the return value is 0.<br><br>       The value 0 may also be returned if the requested number of bytes to<br>       receive from a stream socket was 0.<br></pre><br><h2>ERRORS  </h2><pre><br>       These are some standard errors generated by the socket layer.<br>       Additional errors may be generated and returned from the underlying<br>       protocol modules; see their manual pages.<br><br>       <b>EAGAIN </b>or <b>EWOULDBLOCK</b><br>              The socket is marked nonblocking and the receive operation<br>              would block, or a receive timeout had been set and the timeout<br>              expired before data was received.  POSIX.1 allows either error<br>              to be returned for this case, and does not require these<br>              constants to have the same value, so a portable application<br>              should check for both possibilities.<br><br>       <b>EBADF  </b>The argument <i>sockfd</i> is an invalid descriptor.<br><br>       <b>ECONNREFUSED</b><br>              A remote host refused to allow the network connection<br>              (typically because it is not running the requested service).<br><br>       <b>EFAULT </b>The receive buffer pointer(s) point outside the process's<br>              address space.<br><br>       <b>EINTR  </b>The receive was interrupted by delivery of a signal before any<br>              data were available; see signal(7).<br><br>       <b>EINVAL </b>Invalid argument passed.<br><br>       <b>ENOMEM </b>Could not allocate memory for <b>recvmsg</b>().<br><br>       <b>ENOTCONN</b><br>              The socket is associated with a connection-oriented protocol<br>              and has not been connected (see connect(2) and accept(2)).<br><br>       <b>ENOTSOCK</b><br>              The argument <i>sockfd</i> does not refer to a socket.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008, 4.4BSD (these interfaces first appeared<br>       in 4.2BSD).<br><br>       POSIX.1 describes only the <b>MSG_OOB</b>, <b>MSG_PEEK</b>, and <b>MSG_WAITALL </b>flags.<br></pre><br><h2>NOTES  </h2><pre><br>       The <i>socklen_t</i> type was invented by POSIX.  See also accept(2).<br><br>       According to POSIX.1, the <i>msg_controllen</i> field of the <i>msghdr</i><br>       structure should be typed as <i>socklen_t</i>, but glibc currently types it<br>       as <i>size_t</i>.<br><br>       See recvmmsg(2) for information about a Linux-specific system call<br>       that can be used to receive multiple datagrams in a single call.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       An example of the use of <b>recvfrom</b>() is shown in getaddrinfo(3).<br></pre><br><h2>SEE ALSO  </h2><pre><br>       fcntl(2), getsockopt(2), read(2), recvmmsg(2), select(2),<br>       shutdown(2), socket(2), cmsg(3), sockatmark(3), socket(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                          RECV(2)</span><br></pre><br>"}