{"Man page": "<pre><br><span class=\"headline\">MKDIR(2)                  Linux Programmer's Manual                 MKDIR(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       mkdir, mkdirat - create a directory<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/stat.h&gt;</b><br>       <b>#include &lt;sys/types.h&gt;</b><br><br>       <b>int mkdir(const char *</b><i>pathname</i><b>, mode_t </b><i>mode</i><b>);</b><br><br>       <b>#include &lt;fcntl.h&gt;           </b>/* Definition of AT_* constants */<br>       <b>#include &lt;sys/stat.h&gt;</b><br><br>       <b>int mkdirat(int </b><i>dirfd</i><b>, const char *</b><i>pathname</i><b>, mode_t </b><i>mode</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>mkdirat</b>():<br>           Since glibc 2.10:<br>               _XOPEN_SOURCE &gt;= 700 || _POSIX_C_SOURCE &gt;= 200809L<br>           Before glibc 2.10:<br>               _ATFILE_SOURCE<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>mkdir</b>() attempts to create a directory named <i>pathname</i>.<br><br>       The argument <i>mode</i> specifies the mode for the new directory (see<br>       stat(2)).  It is modified by the process's <i>umask</i> in the usual way: in<br>       the absence of a default ACL, the mode of the created directory is<br>       (<i>mode</i> &amp; ~<i>umask</i> &amp; 0777).  Whether other <i>mode</i> bits are honored for the<br>       created directory depends on the operating system.  For Linux, see<br>       NOTES below.<br><br>       The newly created directory will be owned by the effective user ID of<br>       the process.  If the directory containing the file has the set-group-<br>       ID bit set, or if the filesystem is mounted with BSD group semantics<br>       (<i>mount -o bsdgroups</i> or, synonymously <i>mount -o grpid</i>), the new<br>       directory will inherit the group ownership from its parent; otherwise<br>       it will be owned by the effective group ID of the process.<br><br>       If the parent directory has the set-group-ID bit set, then so will<br>       the newly created directory.<br><br>   <b>mkdirat()</b><br>       The <b>mkdirat</b>() system call operates in exactly the same way as<br>       <b>mkdir</b>(), except for the differences described here.<br><br>       If the pathname given in <i>pathname</i> is relative, then it is interpreted<br>       relative to the directory referred to by the file descriptor <i>dirfd</i><br>       (rather than relative to the current working directory of the calling<br>       process, as is done by <b>mkdir</b>() for a relative pathname).<br><br>       If <i>pathname</i> is relative and <i>dirfd</i> is the special value <b>AT_FDCWD</b>, then<br>       <i>pathname</i> is interpreted relative to the current working directory of<br>       the calling process (like <b>mkdir</b>()).<br><br>       If <i>pathname</i> is absolute, then <i>dirfd</i> is ignored.<br><br>       See openat(2) for an explanation of the need for <b>mkdirat</b>().<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       <b>mkdir</b>() and <b>mkdirat</b>() return zero on success, or -1 if an error<br>       occurred (in which case, <i>errno</i> is set appropriately).<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EACCES </b>The parent directory does not allow write permission to the<br>              process, or one of the directories in <i>pathname</i> did not allow<br>              search permission.  (See also path_resolution(7).)<br><br>       <b>EDQUOT </b>The user's quota of disk blocks or inodes on the filesystem<br>              has been exhausted.<br><br>       <b>EEXIST </b><i>pathname</i> already exists (not necessarily as a directory).<br>              This includes the case where <i>pathname</i> is a symbolic link,<br>              dangling or not.<br><br>       <b>EFAULT </b><i>pathname</i> points outside your accessible address space.<br><br>       <b>ELOOP  </b>Too many symbolic links were encountered in resolving<br>              <i>pathname</i>.<br><br>       <b>EMLINK </b>The number of links to the parent directory would exceed<br>              <b>LINK_MAX</b>.<br><br>       <b>ENAMETOOLONG</b><br>              <i>pathname</i> was too long.<br><br>       <b>ENOENT </b>A directory component in <i>pathname</i> does not exist or is a<br>              dangling symbolic link.<br><br>       <b>ENOMEM </b>Insufficient kernel memory was available.<br><br>       <b>ENOSPC </b>The device containing <i>pathname</i> has no room for the new<br>              directory.<br><br>       <b>ENOSPC </b>The new directory cannot be created because the user's disk<br>              quota is exhausted.<br><br>       <b>ENOTDIR</b><br>              A component used as a directory in <i>pathname</i> is not, in fact, a<br>              directory.<br><br>       <b>EPERM  </b>The filesystem containing <i>pathname</i> does not support the<br>              creation of directories.<br><br>       <b>EROFS  </b><i>pathname</i> refers to a file on a read-only filesystem.<br><br>       The following additional errors can occur for <b>mkdirat</b>():<br><br>       <b>EBADF  </b><i>dirfd</i> is not a valid file descriptor.<br><br>       <b>ENOTDIR</b><br>              <i>pathname</i> is relative and <i>dirfd</i> is a file descriptor referring<br>              to a file other than a directory.<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>mkdirat</b>() was added to Linux in kernel 2.6.16; library support was<br>       added to glibc in version 2.4.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>mkdir</b>(): SVr4, BSD, POSIX.1-2001, POSIX.1-2008.<br><br>       <b>mkdirat</b>(): POSIX.1-2008.<br></pre><br><h2>NOTES  </h2><pre><br>       Under Linux, apart from the permission bits, the <b>S_ISVTX </b><i>mode</i> bit is<br>       also honored.<br><br>       There are many infelicities in the protocol underlying NFS.  Some of<br>       these affect <b>mkdir</b>().<br><br>   <b>Glibc notes</b><br>       On older kernels where <b>mkdirat</b>() is unavailable, the glibc wrapper<br>       function falls back to the use of <b>mkdir</b>().  When <i>pathname</i> is a<br>       relative pathname, glibc constructs a pathname based on the symbolic<br>       link in <i>/proc/self/fd</i> that corresponds to the <i>dirfd</i> argument.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       mkdir(1), chmod(2), chown(2), mknod(2), mount(2), rmdir(2), stat(2),<br>       umask(2), unlink(2), acl(5) path_resolution(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-05-07                         MKDIR(2)</span><br></pre><br>"}