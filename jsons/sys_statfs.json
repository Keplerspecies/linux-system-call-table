{"Man page": "<pre><br><span class=\"headline\">STATFS(2)                 Linux Programmer's Manual                STATFS(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       statfs, fstatfs - get filesystem statistics<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/vfs.h&gt;    </b>/* or &lt;sys/statfs.h&gt; */<br><br>       <b>int statfs(const char *</b><i>path</i><b>, struct statfs *</b><i>buf</i><b>);</b><br>       <b>int fstatfs(int </b><i>fd</i><b>, struct statfs *</b><i>buf</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>statfs</b>() system call returns information about a mounted<br>       filesystem.  <i>path</i> is the pathname of any file within the mounted<br>       filesystem.  <i>buf</i> is a pointer to a <i>statfs</i> structure defined<br>       approximately as follows:<br><br>           struct statfs {<br>               __fsword_t f_type;    /* Type of filesystem (see below) */<br>               __fsword_t f_bsize;   /* Optimal transfer block size */<br>               fsblkcnt_t f_blocks;  /* Total data blocks in filesystem */<br>               fsblkcnt_t f_bfree;   /* Free blocks in filesystem */<br>               fsblkcnt_t f_bavail;  /* Free blocks available to<br>                                        unprivileged user */<br>               fsfilcnt_t f_files;   /* Total file nodes in filesystem */<br>               fsfilcnt_t f_ffree;   /* Free file nodes in filesystem */<br>               fsid_t     f_fsid;    /* Filesystem ID */<br>               __fsword_t f_namelen; /* Maximum length of filenames */<br>               __fsword_t f_frsize;  /* Fragment size (since Linux 2.6) */<br>               __fsword_t f_flags;   /* Mount flags of filesystem<br>                                        (since Linux 2.6.36) */<br>               __fsword_t f_spare[xxx];<br>                               /* Padding bytes reserved for future use */<br>           };<br><br>           Filesystem types:<br><br>              ADFS_SUPER_MAGIC      0xadf5<br>              AFFS_SUPER_MAGIC      0xADFF<br>              BDEVFS_MAGIC          0x62646576<br>              BEFS_SUPER_MAGIC      0x42465331<br>              BFS_MAGIC             0x1BADFACE<br>              BINFMTFS_MAGIC        0x42494e4d<br>              BTRFS_SUPER_MAGIC     0x9123683E<br>              CGROUP_SUPER_MAGIC    0x27e0eb<br>              CIFS_MAGIC_NUMBER     0xFF534D42<br>              CODA_SUPER_MAGIC      0x73757245<br>              COH_SUPER_MAGIC       0x012FF7B7<br>              CRAMFS_MAGIC          0x28cd3d45<br>              DEBUGFS_MAGIC         0x64626720<br>              DEVFS_SUPER_MAGIC     0x1373<br>              DEVPTS_SUPER_MAGIC    0x1cd1<br>              EFIVARFS_MAGIC        0xde5e81e4<br>              EFS_SUPER_MAGIC       0x00414A53<br>              EXT_SUPER_MAGIC       0x137D<br>              EXT2_OLD_SUPER_MAGIC  0xEF51<br>              EXT2_SUPER_MAGIC      0xEF53<br>              EXT3_SUPER_MAGIC      0xEF53<br>              EXT4_SUPER_MAGIC      0xEF53<br>              FUSE_SUPER_MAGIC      0x65735546<br>              FUTEXFS_SUPER_MAGIC   0xBAD1DEA<br>              HFS_SUPER_MAGIC       0x4244<br>              HOSTFS_SUPER_MAGIC    0x00c0ffee<br>              HPFS_SUPER_MAGIC      0xF995E849<br>              HUGETLBFS_MAGIC       0x958458f6<br>              ISOFS_SUPER_MAGIC     0x9660<br>              JFFS2_SUPER_MAGIC     0x72b6<br>              JFS_SUPER_MAGIC       0x3153464a<br>              MINIX_SUPER_MAGIC     0x137F /* orig. minix */<br>              MINIX_SUPER_MAGIC2    0x138F /* 30 char minix */<br>              MINIX2_SUPER_MAGIC    0x2468 /* minix V2 */<br>              MINIX2_SUPER_MAGIC2   0x2478 /* minix V2, 30 char names */<br>              MINIX3_SUPER_MAGIC    0x4d5a /* minix V3 fs, 60 char names */<br>              MQUEUE_MAGIC          0x19800202<br>              MSDOS_SUPER_MAGIC     0x4d44<br>              NCP_SUPER_MAGIC       0x564c<br>              NFS_SUPER_MAGIC       0x6969<br>              NILFS_SUPER_MAGIC     0x3434<br>              NTFS_SB_MAGIC         0x5346544e<br>              OCFS2_SUPER_MAGIC     0x7461636f<br>              OPENPROM_SUPER_MAGIC  0x9fa1<br>              PIPEFS_MAGIC          0x50495045<br>              PROC_SUPER_MAGIC      0x9fa0<br>              PSTOREFS_MAGIC        0x6165676C<br>              QNX4_SUPER_MAGIC      0x002f<br>              QNX6_SUPER_MAGIC      0x68191122<br>              RAMFS_MAGIC           0x858458f6<br>              REISERFS_SUPER_MAGIC  0x52654973<br>              ROMFS_MAGIC           0x7275<br>              SELINUX_MAGIC         0xf97cff8c<br>              SMACK_MAGIC           0x43415d53<br>              SMB_SUPER_MAGIC       0x517B<br>              SOCKFS_MAGIC          0x534F434B<br>              SQUASHFS_MAGIC        0x73717368<br>              SYSFS_MAGIC           0x62656572<br>              SYSV2_SUPER_MAGIC     0x012FF7B6<br>              SYSV4_SUPER_MAGIC     0x012FF7B5<br>              TMPFS_MAGIC           0x01021994<br>              UDF_SUPER_MAGIC       0x15013346<br>              UFS_MAGIC             0x00011954<br>              USBDEVICE_SUPER_MAGIC 0x9fa2<br>              V9FS_MAGIC            0x01021997<br>              VXFS_SUPER_MAGIC      0xa501FCF5<br>              XENFS_SUPER_MAGIC     0xabba1974<br>              XENIX_SUPER_MAGIC     0x012FF7B4<br>              XFS_SUPER_MAGIC       0x58465342<br>              _XIAFS_SUPER_MAGIC    0x012FD16D<br><br>       Most of these MAGIC constants are defined in<br>       <i>/usr/include/linux/magic.h</i>, and some are hardcoded in kernel sources.<br><br>       The <i>f_flags</i> is a bit mask indicating mount options for the file<br>       system.  It contains zero or more of the following bits:<br><br>       <b>ST_MANDLOCK</b><br>              Mandatory locking is permitted on the filesystem (see<br>              fcntl(2)).<br><br>       <b>ST_NOATIME</b><br>              Do not update access times; see mount(2).<br><br>       <b>ST_NODEV</b><br>              Disallow access to device special files on this filesystem.<br><br>       <b>ST_NODIRATIME</b><br>              Do not update directory access times; see mount(2).<br><br>       <b>ST_NOEXEC</b><br>              Execution of programs is disallowed on this filesystem.<br><br>       <b>ST_NOSUID</b><br>              The set-user-ID and set-group-ID bits are ignored by exec(3)<br>              for executable files on this filesystem<br><br>       <b>ST_RDONLY</b><br>              This filesystem is mounted read-only.<br><br>       <b>ST_RELATIME</b><br>              Update atime relative to mtime/ctime; see mount(2).<br><br>       <b>ST_SYNCHRONOUS</b><br>              Writes are synched to the filesystem immediately (see the<br>              description of <b>O_SYNC </b>in open(2)).<br><br>       Nobody knows what <i>f_fsid</i> is supposed to contain (but see below).<br><br>       Fields that are undefined for a particular filesystem are set to 0.<br><br>       <b>fstatfs</b>() returns the same information about an open file referenced<br>       by descriptor <i>fd</i>.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, zero is returned.  On error, -1 is returned, and <i>errno</i> is<br>       set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EACCES </b>(<b>statfs</b>()) Search permission is denied for a component of the<br>              path prefix of <i>path</i>.  (See also path_resolution(7).)<br><br>       <b>EBADF  </b>(<b>fstatfs</b>()) <i>fd</i> is not a valid open file descriptor.<br><br>       <b>EFAULT </b><i>buf</i> or <i>path</i> points to an invalid address.<br><br>       <b>EINTR  </b>This call was interrupted by a signal.<br><br>       <b>EIO    </b>An I/O error occurred while reading from the filesystem.<br><br>       <b>ELOOP  </b>(<b>statfs</b>()) Too many symbolic links were encountered in<br>              translating <i>path</i>.<br><br>       <b>ENAMETOOLONG</b><br>              (<b>statfs</b>()) <i>path</i> is too long.<br><br>       <b>ENOENT </b>(<b>statfs</b>()) The file referred to by <i>path</i> does not exist.<br><br>       <b>ENOMEM </b>Insufficient kernel memory was available.<br><br>       <b>ENOSYS </b>The filesystem does not support this call.<br><br>       <b>ENOTDIR</b><br>              (<b>statfs</b>()) A component of the path prefix of <i>path</i> is not a<br>              directory.<br><br>       <b>EOVERFLOW</b><br>              Some values were too large to be represented in the returned<br>              struct.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       Linux-specific.  The Linux <b>statfs</b>() was inspired by the 4.4BSD one<br>       (but they do not use the same structure).<br></pre><br><h2>NOTES  </h2><pre><br>       The <i>__fsword_t</i> type used for various fields in the <i>statfs</i> structure<br>       definition is a glibc internal type, not intended for public use.<br>       This leaves the programmer in a bit of a conundrum when trying to<br>       copy or compare these fields to local variables in a program.  Using<br>       <i>unsigned int</i> for such variables suffices on most systems.<br><br>       The original Linux <b>statfs</b>() and <b>fstatfs</b>() system calls were not<br>       designed with extremely large file sizes in mind.  Subsequently,<br>       Linux 2.6 added new <b>statfs64</b>() and <b>fstatfs64</b>() system calls that<br>       employ a new structure, <i>statfs64</i>.  The new structure contains the<br>       same fields as the original <i>statfs</i> structure, but the sizes of<br>       various fields are increased, to accommodate large file sizes.  The<br>       glibc <b>statfs</b>() and <b>fstatfs</b>() wrapper functions transparently deal<br>       with the kernel differences.<br><br>       Some systems have only <i>&lt;sys/vfs.h&gt;</i>, other systems also have<br>       <i>&lt;sys/statfs.h&gt;</i>, where the former includes the latter.  So it seems<br>       including the former is the best choice.<br><br>       LSB has deprecated the library calls <b>statfs</b>() and <b>fstatfs</b>() and tells<br>       us to use statvfs(2) and fstatvfs(2) instead.<br><br>   <b>The f_fsid field</b><br>       Solaris, Irix and POSIX have a system call statvfs(2) that returns a<br>       <i>struct statvfs</i> (defined in <i>&lt;sys/statvfs.h&gt;</i>) containing an <i>unsigned</i><br>       <i>long f_fsid</i>.  Linux, SunOS, HP-UX, 4.4BSD have a system call <b>statfs</b>()<br>       that returns a <i>struct statfs</i> (defined in <i>&lt;sys/vfs.h&gt;</i>) containing a<br>       <i>fsid_t f_fsid</i>, where <i>fsid_t</i> is defined as <i>struct { int val[2]; }</i>.<br>       The same holds for FreeBSD, except that it uses the include file<br>       <i>&lt;sys/mount.h&gt;</i>.<br><br>       The general idea is that <i>f_fsid</i> contains some random stuff such that<br>       the pair (<i>f_fsid</i>,<i>ino</i>) uniquely determines a file.  Some operating<br>       systems use (a variation on) the device number, or the device number<br>       combined with the filesystem type.  Several operating systems<br>       restrict giving out the <i>f_fsid</i> field to the superuser only (and zero<br>       it for unprivileged users), because this field is used in the<br>       filehandle of the filesystem when NFS-exported, and giving it out is<br>       a security concern.<br><br>       Under some operating systems, the <i>fsid</i> can be used as the second<br>       argument to the sysfs(2) system call.<br></pre><br><h2>BUGS  </h2><pre><br>       From Linux 2.6.38 up to and including Linux 3.1, <b>fstatfs</b>() failed<br>       with the error <b>ENOSYS </b>for file descriptors created by pipe(2).<br></pre><br><h2>SEE ALSO  </h2><pre><br>       stat(2), statvfs(2), path_resolution(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-02-21                        STATFS(2)</span><br></pre><br>"}