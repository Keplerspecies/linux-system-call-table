{"Man page": "<pre><br><span class=\"headline\">GETRANDOM(2)              Linux Programmer's Manual             GETRANDOM(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       getrandom - obtain a series of random bytes<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;linux/random.h&gt;</b><br><br>       <b>int getrandom(void *</b><i>buf</i><b>, size_t </b><i>buflen</i><b>, unsigned int </b><i>flags</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>getrandom</b>() system call fills the buffer pointed to by <i>buf</i> with<br>       up to <i>buflen</i> random bytes.  These bytes can be used to seed user-<br>       space random number generators or for cryptographic purposes.<br><br>       <b>getrandom</b>() relies on entropy gathered from device drivers and other<br>       sources of environmental noise.  Unnecessarily reading large<br>       quantities of data will have a negative impact on other users of the<br>       <i>/dev/random</i> and <i>/dev/urandom</i> devices.  Therefore, <b>getrandom</b>() should<br>       not be used for Monte Carlo simulations or other programs/algorithms<br>       which are doing probabilistic sampling.<br><br>       By default, <b>getrandom</b>() draws entropy from the <i>/dev/urandom</i> pool.<br>       This behavior can be changed via the <i>flags</i> argument.  If the<br>       <i>/dev/urandom</i> pool has been initialized, reads of up to 256 bytes will<br>       always return as many bytes as requested and will not be interrupted<br>       by signals.  No such guarantees apply for larger buffer sizes.  For<br>       example, if the call is interrupted by a signal handler, it may<br>       return a partially filled buffer, or fail with the error <b>EINTR</b>.  If<br>       the pool has not yet been initialized, then the call blocks, unless<br>       <b>GRND_RANDOM </b>is specified in <i>flags</i>.<br><br>       The <i>flags</i> argument is a bit mask that can contain zero or more of the<br>       following values ORed together:<br><br>       <b>GRND_RANDOM</b><br>              If this bit is set, then random bytes are drawn from the<br>              <i>/dev/random</i> pool instead of the <i>/dev/urandom</i> pool.  The<br>              <i>/dev/random</i> pool is limited based on the entropy that can be<br>              obtained from environmental noise.  If the number of available<br>              bytes in <i>/dev/random</i> is less than requested in <i>buflen</i>, the<br>              call returns just the available random bytes.  If no random<br>              bytes are available, the behavior depends on the presence of<br>              <b>GRND_NONBLOCK </b>in the <i>flags</i> argument.<br><br>       <b>GRND_NONBLOCK</b><br>              By default, when reading from <i>/dev/random</i>, <b>getrandom</b>() blocks<br>              if no random bytes are available, and when reading from<br>              <i>/dev/urandom</i>, it blocks if the entropy pool has not yet been<br>              initialized.  If the <b>GRND_NONBLOCK </b>flag is set, then<br>              <b>getrandom</b>() does not block in these cases, but instead<br>              immediately returns -1 with <i>errno</i> set to <b>EAGAIN</b>.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>getrandom</b>() returns the number of bytes that were copied<br>       to the buffer <i>buf</i>.  This may be less than the number of bytes<br>       requested via <i>buflen</i> if <b>GRND_RANDOM </b>was specified in <i>flags</i> and<br>       insufficient entropy was present in the <i>/dev/random</i> pool, or if the<br>       system call was interrupted by a signal.<br><br>       On error, -1 is returned, and <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EINVAL </b>An invalid flag was specified in <i>flags</i>.<br><br>       <b>EFAULT </b>The address referred to by <i>buf</i> is outside the accessible<br>              address space.<br><br>       <b>EAGAIN </b>The requested entropy was not available, and <b>getrandom</b>() would<br>              have blocked if the <b>GRND_NONBLOCK </b>flag was not set.<br><br>       <b>EINTR  </b>The call was interrupted by a signal handler; see the<br>              description of how interrupted read(2) calls on \"slow\" devices<br>              are handled with and without the <b>SA_RESTART </b>flag in the<br>              signal(7) man page.<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>getrandom</b>() was introduced in version 3.17 of the Linux kernel.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       This system call is Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>   <b>Maximum number of bytes returned</b><br>       As of Linux 3.19 the following limits apply:<br><br>       *  When reading from <i>/dev/urandom</i>, a maximum of 33554431 bytes is<br>          returned by a single call to <b>getrandom</b>() on a system where <i>int</i> has<br>          a size of 32 bits.<br><br>       *  When reading from <i>/dev/random</i>, a maximum of 512 bytes is returned.<br><br>   <b>Initialization of the entropy pool</b><br>       The kernel collects bits of entropy from environment.  When a<br>       sufficient number of random bits has been collected, the <i>/dev/urandom</i><br>       entropy pool is considered to be initialized.  This state is normally<br>       reached early in the system bootstrap phase.<br><br>   <b>Interruption by a signal handler</b><br>       When reading from <i>/dev/urandom</i> (<b>GRND_RANDOM </b>is not set), <b>getrandom</b>()<br>       will block until the entropy pool has been initialized (unless the<br>       <b>GRND_NONBLOCK </b>flag was specified).  If a request is made to read a<br>       large number (more than 256) of bytes, <b>getrandom</b>() will block until<br>       those bytes have been generated and transferred from kernel memory to<br>       <i>buf</i>.  When reading from <i>/dev/random</i> (<b>GRND_RANDOM </b>is set), <b>getrandom</b>()<br>       will block until some random bytes become available (unless the<br>       <b>GRND_NONBLOCK </b>flag was specified).<br><br>       The behavior when a call to <b>getrandom</b>() that is blocked while reading<br>       from <i>/dev/urandom</i> is interrupted by a signal handler depends on the<br>       initialization state of the entropy buffer and on the request size,<br>       <i>buflen</i>.  If the entropy is not yet initialized, then the call will<br>       fail with the <b>EINTR </b>error.  If the entropy pool has been initialized<br>       and the request size is large (<i>buflen</i> &gt; 256), the call either<br>       succeeds, returning a partially filled buffer, or fails with the<br>       error <b>EINTR.  </b>If the entropy pool has been initialized and the<br>       request size is small (<i>buflen</i> &lt;= 256), then <b>getrandom</b>() will not fail<br>       with <b>EINTR</b>.  Instead, it will return all of the bytes that have been<br>       requested.<br><br>       When reading from <i>/dev/random</i>, blocking requests of any size can be<br>       interrupted by a signal (the call fails with the error <b>EINTR</b>).<br><br>       Calling <b>getrandom</b>() to read <i>/dev/urandom</i> for small values (&lt;= 256) of<br>       <i>buflen</i> is the preferred mode of usage.<br><br>       The special treatment of small values of <i>buflen</i> was designed for<br>       compatibility with OpenBSD's <b>getentropy</b>() system call.<br><br>       The user of <b>getrandom</b>() <i>must</i> always check the return value, to<br>       determine whether either an error occurred or fewer bytes than<br>       requested were returned.  In the case where <b>GRND_RANDOM </b>is not<br>       specified and <i>buflen</i> is less than or equal to 256, a return of fewer<br>       bytes than requested should never happen, but the careful programmer<br>       will check for this anyway!<br><br>   <b>Choice of random device</b><br>       Unless you are doing long-term key generation (and perhaps not even<br>       then), you probably shouldn't be using <b>GRND_RANDOM.  </b>The<br>       cryptographic algorithms used for <i>/dev/urandom</i> are quite<br>       conservative, and so should be sufficient for all purposes.  The<br>       disadvantage of <b>GRND_RANDOM </b>is that it can block.  Furthermore,<br>       dealing with the partially fulfilled <b>getrandom</b>() requests that can<br>       occur when using <b>GRND_RANDOM </b>increases code complexity.<br><br>   <b>Emulating OpenBSD's getentropy()</b><br>       The <b>getentropy</b>() system call in OpenBSD can be emulated using the<br>       following function:<br><br>           int<br>           getentropy(void *buf, size_t buflen)<br>           {<br>               int ret;<br><br>               if (buflen &gt; 256)<br>                   goto failure;<br>               ret = getrandom(buf, buflen, 0);<br>               if (ret &lt; 0)<br>                   return ret;<br>               if (ret == buflen)<br>                   return 0;<br>           failure:<br>               errno = EIO;<br>               return -1;<br>           }<br></pre><br><h2>BUGS  </h2><pre><br>       As of Linux 3.19, the following bug exists:<br><br>       *  Depending on CPU load, <b>getrandom</b>() does not react to interrupts<br>          before reading all bytes requested.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       random(4), urandom(4), signal(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-01-22                     GETRANDOM(2)</span><br></pre><br>"}