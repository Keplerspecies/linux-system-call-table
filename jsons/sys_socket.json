{"Man page": "<pre><br><span class=\"headline\">SOCKET(2)                 Linux Programmer's Manual                SOCKET(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       socket - create an endpoint for communication<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/types.h&gt;          </b>/* See NOTES */<br>       <b>#include &lt;sys/socket.h&gt;</b><br><br>       <b>int socket(int </b><i>domain</i><b>, int </b><i>type</i><b>, int </b><i>protocol</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>socket</b>() creates an endpoint for communication and returns a<br>       descriptor.<br><br>       The <i>domain</i> argument specifies a communication domain; this selects<br>       the protocol family which will be used for communication.  These<br>       families are defined in <i>&lt;sys/socket.h&gt;</i>.  The currently understood<br>       formats include:<br><br>       Name                Purpose                          Man page<br>       <b>AF_UNIX</b>, <b>AF_LOCAL   </b>Local communication              unix(7)<br>       <b>AF_INET             </b>IPv4 Internet protocols          ip(7)<br>       <b>AF_INET6            </b>IPv6 Internet protocols          ipv6(7)<br>       <b>AF_IPX              </b>IPX - Novell protocols<br>       <b>AF_NETLINK          </b>Kernel user interface device     netlink(7)<br>       <b>AF_X25              </b>ITU-T X.25 / ISO-8208 protocol   x25(7)<br>       <b>AF_AX25             </b>Amateur radio AX.25 protocol<br>       <b>AF_ATMPVC           </b>Access to raw ATM PVCs<br>       <b>AF_APPLETALK        </b>AppleTalk                        ddp(7)<br>       <b>AF_PACKET           </b>Low level packet interface       packet(7)<br>       <b>AF_ALG              </b>Interface to kernel crypto API<br><br>       The socket has the indicated <i>type</i>, which specifies the communication<br>       semantics.  Currently defined types are:<br><br>       <b>SOCK_STREAM     </b>Provides sequenced, reliable, two-way, connection-<br>                       based byte streams.  An out-of-band data transmission<br>                       mechanism may be supported.<br><br>       <b>SOCK_DGRAM      </b>Supports datagrams (connectionless, unreliable<br>                       messages of a fixed maximum length).<br><br>       <b>SOCK_SEQPACKET  </b>Provides a sequenced, reliable, two-way connection-<br>                       based data transmission path for datagrams of fixed<br>                       maximum length; a consumer is required to read an<br>                       entire packet with each input system call.<br><br>       <b>SOCK_RAW        </b>Provides raw network protocol access.<br><br>       <b>SOCK_RDM        </b>Provides a reliable datagram layer that does not<br>                       guarantee ordering.<br><br>       <b>SOCK_PACKET     </b>Obsolete and should not be used in new programs; see<br>                       packet(7).<br><br>       Some socket types may not be implemented by all protocol families.<br><br>       Since Linux 2.6.27, the <i>type</i> argument serves a second purpose: in<br>       addition to specifying a socket type, it may include the bitwise OR<br>       of any of the following values, to modify the behavior of <b>socket</b>():<br><br>       <b>SOCK_NONBLOCK   </b>Set the <b>O_NONBLOCK </b>file status flag on the new open<br>                       file description.  Using this flag saves extra calls<br>                       to fcntl(2) to achieve the same result.<br><br>       <b>SOCK_CLOEXEC    </b>Set the close-on-exec (<b>FD_CLOEXEC</b>) flag on the new<br>                       file descriptor.  See the description of the<br>                       <b>O_CLOEXEC </b>flag in open(2) for reasons why this may be<br>                       useful.<br><br>       The <i>protocol</i> specifies a particular protocol to be used with the<br>       socket.  Normally only a single protocol exists to support a<br>       particular socket type within a given protocol family, in which case<br>       <i>protocol</i> can be specified as 0.  However, it is possible that many<br>       protocols may exist, in which case a particular protocol must be<br>       specified in this manner.  The protocol number to use is specific to<br>       the &#8220;communication domain&#8221; in which communication is to take place;<br>       see protocols(5).  See getprotoent(3) on how to map protocol name<br>       strings to protocol numbers.<br><br>       Sockets of type <b>SOCK_STREAM </b>are full-duplex byte streams.  They do<br>       not preserve record boundaries.  A stream socket must be in a<br>       <i>connected</i> state before any data may be sent or received on it.  A<br>       connection to another socket is created with a connect(2) call.  Once<br>       connected, data may be transferred using read(2) and write(2) calls<br>       or some variant of the send(2) and recv(2) calls.  When a session has<br>       been completed a close(2) may be performed.  Out-of-band data may<br>       also be transmitted as described in send(2) and received as described<br>       in recv(2).<br><br>       The communications protocols which implement a <b>SOCK_STREAM </b>ensure<br>       that data is not lost or duplicated.  If a piece of data for which<br>       the peer protocol has buffer space cannot be successfully transmitted<br>       within a reasonable length of time, then the connection is considered<br>       to be dead.  When <b>SO_KEEPALIVE </b>is enabled on the socket the protocol<br>       checks in a protocol-specific manner if the other end is still alive.<br>       A <b>SIGPIPE </b>signal is raised if a process sends or receives on a broken<br>       stream; this causes naive processes, which do not handle the signal,<br>       to exit.  <b>SOCK_SEQPACKET </b>sockets employ the same system calls as<br>       <b>SOCK_STREAM </b>sockets.  The only difference is that read(2) calls will<br>       return only the amount of data requested, and any data remaining in<br>       the arriving packet will be discarded.  Also all message boundaries<br>       in incoming datagrams are preserved.<br><br>       <b>SOCK_DGRAM </b>and <b>SOCK_RAW </b>sockets allow sending of datagrams to<br>       correspondents named in sendto(2) calls.  Datagrams are generally<br>       received with recvfrom(2), which returns the next datagram along with<br>       the address of its sender.<br><br>       <b>SOCK_PACKET </b>is an obsolete socket type to receive raw packets<br>       directly from the device driver.  Use packet(7) instead.<br><br>       An fcntl(2) <b>F_SETOWN </b>operation can be used to specify a process or<br>       process group to receive a <b>SIGURG </b>signal when the out-of-band data<br>       arrives or <b>SIGPIPE </b>signal when a <b>SOCK_STREAM </b>connection breaks<br>       unexpectedly.  This operation may also be used to set the process or<br>       process group that receives the I/O and asynchronous notification of<br>       I/O events via <b>SIGIO</b>.  Using <b>F_SETOWN </b>is equivalent to an ioctl(2)<br>       call with the <b>FIOSETOWN </b>or <b>SIOCSPGRP </b>argument.<br><br>       When the network signals an error condition to the protocol module<br>       (e.g., using a ICMP message for IP) the pending error flag is set for<br>       the socket.  The next operation on this socket will return the error<br>       code of the pending error.  For some protocols it is possible to<br>       enable a per-socket error queue to retrieve detailed information<br>       about the error; see <b>IP_RECVERR </b>in ip(7).<br><br>       The operation of sockets is controlled by socket level <i>options</i>.<br>       These options are defined in <i>&lt;sys/socket.h&gt;</i>.  The functions<br>       setsockopt(2) and getsockopt(2) are used to set and get options,<br>       respectively.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, a file descriptor for the new socket is returned.  On<br>       error, -1 is returned, and <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EACCES </b>Permission to create a socket of the specified type and/or<br>              protocol is denied.<br><br>       <b>EAFNOSUPPORT</b><br>              The implementation does not support the specified address<br>              family.<br><br>       <b>EINVAL </b>Unknown protocol, or protocol family not available.<br><br>       <b>EINVAL </b>Invalid flags in <i>type</i>.<br><br>       <b>EMFILE </b>Process file table overflow.<br><br>       <b>ENFILE </b>The system limit on the total number of open files has been<br>              reached.<br><br>       <b>ENOBUFS </b>or <b>ENOMEM</b><br>              Insufficient memory is available.  The socket cannot be<br>              created until sufficient resources are freed.<br><br>       <b>EPROTONOSUPPORT</b><br>              The protocol type or the specified protocol is not supported<br>              within this domain.<br><br>       Other errors may be generated by the underlying protocol modules.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008, 4.4BSD.<br><br>       The <b>SOCK_NONBLOCK </b>and <b>SOCK_CLOEXEC </b>flags are Linux-specific.<br><br>       <b>socket</b>() appeared in 4.2BSD.  It is generally portable to/from non-<br>       BSD systems supporting clones of the BSD socket layer (including<br>       System V variants).<br></pre><br><h2>NOTES  </h2><pre><br>       POSIX.1 does not require the inclusion of <i>&lt;sys/types.h&gt;</i>, and this<br>       header file is not required on Linux.  However, some historical (BSD)<br>       implementations required this header file, and portable applications<br>       are probably wise to include it.<br><br>       The manifest constants used under 4.x BSD for protocol families are<br>       <b>PF_UNIX</b>, <b>PF_INET</b>, and so on, while <b>AF_UNIX</b>, <b>AF_INET</b>, and so on are<br>       used for address families.  However, already the BSD man page<br>       promises: \"The protocol family generally is the same as the address<br>       family\", and subsequent standards use AF_* everywhere.<br><br>       The <b>AF_ALG </b>protocol type was added in Linux 2.6.38.  More information<br>       on this interface is provided with the kernel HTML documentation at<br>       <i>https://www.kernel.org/doc/htmldocs/crypto-API/User.html </i>.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       An example of the use of <b>socket</b>() is shown in getaddrinfo(3).<br></pre><br><h2>SEE ALSO  </h2><pre><br>       accept(2), bind(2), close(2), connect(2), fcntl(2), getpeername(2),<br>       getsockname(2), getsockopt(2), ioctl(2), listen(2), read(2), recv(2),<br>       select(2), send(2), shutdown(2), socketpair(2), write(2),<br>       getprotoent(3), ip(7), socket(7), tcp(7), udp(7), unix(7)<br><br>       &#8220;An Introductory 4.3BSD Interprocess Communication Tutorial&#8221; and &#8220;BSD<br>       Interprocess Communication Tutorial&#8221;, reprinted in <i>UNIX Programmer's</i><br>       <i>Supplementary Documents Volume 1.</i><br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                        SOCKET(2)</span><br></pre><br>"}