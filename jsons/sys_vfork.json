{"Man page": "<pre><br><span class=\"headline\">VFORK(2)                  Linux Programmer's Manual                 VFORK(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       vfork - create a child process and block parent<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/types.h&gt;</b><br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>pid_t vfork(void);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>vfork</b>():<br>           Since glibc 2.12:<br>               _BSD_SOURCE ||<br>                   (_XOPEN_SOURCE &gt;= 500 ||<br>                       _XOPEN_SOURCE &amp;&amp; _XOPEN_SOURCE_EXTENDED) &amp;&amp;<br>                   !(_POSIX_C_SOURCE &gt;= 200809L || _XOPEN_SOURCE &gt;= 700)<br>           Before glibc 2.12:<br>               _BSD_SOURCE || _XOPEN_SOURCE &gt;= 500 ||<br>               _XOPEN_SOURCE &amp;&amp; _XOPEN_SOURCE_EXTENDED<br></pre><br><h2>DESCRIPTION  </h2><pre><br>   <b>Standard description</b><br>       (From POSIX.1) The <b>vfork</b>() function has the same effect as fork(2),<br>       except that the behavior is undefined if the process created by<br>       <b>vfork</b>() either modifies any data other than a variable of type <i>pid_t</i><br>       used to store the return value from <b>vfork</b>(), or returns from the<br>       function in which <b>vfork</b>() was called, or calls any other function<br>       before successfully calling _exit(2) or one of the exec(3) family of<br>       functions.<br><br>   <b>Linux description</b><br>       <b>vfork</b>(), just like fork(2), creates a child process of the calling<br>       process.  For details and return value and errors, see fork(2).<br><br>       <b>vfork</b>() is a special case of clone(2).  It is used to create new<br>       processes without copying the page tables of the parent process.  It<br>       may be useful in performance-sensitive applications where a child is<br>       created which then immediately issues an execve(2).<br><br>       <b>vfork</b>() differs from fork(2) in that the calling thread is suspended<br>       until the child terminates (either normally, by calling _exit(2), or<br>       abnormally, after delivery of a fatal signal), or it makes a call to<br>       execve(2).  Until that point, the child shares all memory with its<br>       parent, including the stack.  The child must not return from the<br>       current function or call exit(3), but may call _exit(2).<br><br>       As with fork(2), the child process created by <b>vfork</b>() inherits copies<br>       of various of the caller's process attributes (e.g., file<br>       descriptors, signal dispositions, and current working directory); the<br>       <b>vfork</b>() call differs only in the treatment of the virtual address<br>       space, as described above.<br><br>       Signals sent to the parent arrive after the child releases the<br>       parent's memory (i.e., after the child terminates or calls<br>       execve(2)).<br><br>   <b>Historic description</b><br>       Under Linux, fork(2) is implemented using copy-on-write pages, so the<br>       only penalty incurred by fork(2) is the time and memory required to<br>       duplicate the parent's page tables, and to create a unique task<br>       structure for the child.  However, in the bad old days a fork(2)<br>       would require making a complete copy of the caller's data space,<br>       often needlessly, since usually immediately afterward an exec(3) is<br>       done.  Thus, for greater efficiency, BSD introduced the <b>vfork</b>()<br>       system call, which did not fully copy the address space of the parent<br>       process, but borrowed the parent's memory and thread of control until<br>       a call to execve(2) or an exit occurred.  The parent process was<br>       suspended while the child was using its resources.  The use of<br>       <b>vfork</b>() was tricky: for example, not modifying data in the parent<br>       process depended on knowing which variables were held in a register.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       4.3BSD; POSIX.1-2001 (but marked OBSOLETE).  POSIX.1-2008 removes the<br>       specification of <b>vfork</b>().<br><br>       The requirements put on <b>vfork</b>() by the standards are weaker than<br>       those put on fork(2), so an implementation where the two are<br>       synonymous is compliant.  In particular, the programmer cannot rely<br>       on the parent remaining blocked until the child either terminates or<br>       calls execve(2), and cannot rely on any specific behavior with<br>       respect to shared memory.<br></pre><br><h2>NOTES  </h2><pre><br>       Some consider the semantics of <b>vfork</b>() to be an architectural<br>       blemish, and the 4.2BSD man page stated: \"This system call will be<br>       eliminated when proper system sharing mechanisms are implemented.<br>       Users should not depend on the memory sharing semantics of <b>vfork</b>() as<br>       it will, in that case, be made synonymous to fork(2).\"  However, even<br>       though modern memory management hardware has decreased the<br>       performance difference between fork(2) and <b>vfork</b>(), there are various<br>       reasons why Linux and other systems have retained <b>vfork</b>():<br><br>       *  Some performance-critical applications require the small<br>          performance advantage conferred by <b>vfork</b>().<br><br>       *  <b>vfork</b>() can be implemented on systems that lack a memory-<br>          management unit (MMU), but fork(2) can't be implemented on such<br>          systems.  (POSIX.1-2008 removed <b>vfork</b>() from the standard; the<br>          POSIX rationale for the <b>posix_spawn</b>(3) function notes that that<br>          function, which provides functionality equivalent to<br>          fork(2)+exec(3), is designed to be implementable on systems that<br>          lack an MMU.)<br><br>   <b>Linux notes</b><br>       Fork handlers established using <b>pthread_atfork</b>(3) are not called when<br>       a multithreaded program employing the NPTL threading library calls<br>       <b>vfork</b>().  Fork handlers are called in this case in a program using<br>       the LinuxThreads threading library.  (See pthreads(7) for a<br>       description of Linux threading libraries.)<br><br>       A call to <b>vfork</b>() is equivalent to calling clone(2) with <i>flags</i><br>       specified as:<br><br>            CLONE_VM | CLONE_VFORK | SIGCHLD<br><br>   <b>History</b><br>       The <b>vfork</b>() system call appeared in 3.0BSD.  In 4.4BSD it was made<br>       synonymous to fork(2) but NetBSD introduced it again, cf.  <br>       &#10216;http://www.netbsd.org/Documentation/kernel/vfork.html&#10217;.  In Linux, it<br>       has been equivalent to fork(2) until 2.2.0-pre6 or so.  Since<br>       2.2.0-pre9 (on i386, somewhat later on other architectures) it is an<br>       independent system call.  Support was added in glibc 2.0.112.<br></pre><br><h2>BUGS  </h2><pre><br>       Details of the signal handling are obscure and differ between<br>       systems.  The BSD man page states: \"To avoid a possible deadlock<br>       situation, processes that are children in the middle of a <b>vfork</b>() are<br>       never sent <b>SIGTTOU </b>or <b>SIGTTIN </b>signals; rather, output or <i>ioctl</i>s are<br>       allowed and input attempts result in an end-of-file indication.\"<br></pre><br><h2>SEE ALSO  </h2><pre><br>       clone(2), execve(2), fork(2), unshare(2), wait(2)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2012-08-05                         VFORK(2)</span><br></pre><br>"}