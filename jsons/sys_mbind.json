{"Man page": "<pre><br><span class=\"headline\">MBIND(2)                  Linux Programmer's Manual                 MBIND(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       mbind - set memory policy for a memory range<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;numaif.h&gt;</b><br><br>       <b>long mbind(void *</b><i>addr</i><b>, unsigned long </b><i>len</i><b>, int </b><i>mode</i><b>,</b><br>                  <b>const unsigned long *</b><i>nodemask</i><b>, unsigned long </b><i>maxnode</i><b>,</b><br>                  <b>unsigned </b><i>flags</i><b>);</b><br><br>       Link with <i>-lnuma</i>.<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>mbind</b>() sets the NUMA memory policy, which consists of a policy mode<br>       and zero or more nodes, for the memory range starting with <i>addr</i> and<br>       continuing for <i>len</i> bytes.  The memory policy defines from which node<br>       memory is allocated.<br><br>       If the memory range specified by the <i>addr</i> and <i>len</i> arguments includes<br>       an \"anonymous\" region of memory&#8212;that is a region of memory created<br>       using the mmap(2) system call with the <b>MAP_ANONYMOUS</b>&#8212;or a memory-<br>       mapped file, mapped using the mmap(2) system call with the<br>       <b>MAP_PRIVATE </b>flag, pages will be allocated only according to the<br>       specified policy when the application writes [stores] to the page.<br>       For anonymous regions, an initial read access will use a shared page<br>       in the kernel containing all zeros.  For a file mapped with<br>       <b>MAP_PRIVATE</b>, an initial read access will allocate pages according to<br>       the process policy of the process that causes the page to be<br>       allocated.  This may not be the process that called <b>mbind</b>().<br><br>       The specified policy will be ignored for any <b>MAP_SHARED </b>mappings in<br>       the specified memory range.  Rather the pages will be allocated<br>       according to the process policy of the process that caused the page<br>       to be allocated.  Again, this may not be the process that called<br>       <b>mbind</b>().<br><br>       If the specified memory range includes a shared memory region created<br>       using the shmget(2) system call and attached using the shmat(2)<br>       system call, pages allocated for the anonymous or shared memory<br>       region will be allocated according to the policy specified,<br>       regardless which process attached to the shared memory segment causes<br>       the allocation.  If, however, the shared memory region was created<br>       with the <b>SHM_HUGETLB </b>flag, the huge pages will be allocated according<br>       to the policy specified only if the page allocation is caused by the<br>       process that calls <b>mbind</b>() for that region.<br><br>       By default, <b>mbind</b>() has an effect only for new allocations; if the<br>       pages inside the range have been already touched before setting the<br>       policy, then the policy has no effect.  This default behavior may be<br>       overridden by the <b>MPOL_MF_MOVE </b>and <b>MPOL_MF_MOVE_ALL </b>flags described<br>       below.<br><br>       The <i>mode</i> argument must specify one of <b>MPOL_DEFAULT</b>, <b>MPOL_BIND</b>,<br>       <b>MPOL_INTERLEAVE</b>, or <b>MPOL_PREFERRED</b>.  All policy modes except<br>       <b>MPOL_DEFAULT </b>require the caller to specify via the <i>nodemask</i> argument,<br>       the node or nodes to which the mode applies.<br><br>       The <i>mode</i> argument may also include an optional <i>mode flag</i> .  The<br>       supported <i>mode flags</i> are:<br><br>       <b>MPOL_F_STATIC_NODES </b>(since Linux-2.6.26)<br>              A nonempty <i>nodemask</i> specifies physical node ids.  Linux does<br>              not remap the <i>nodemask</i> when the process moves to a different<br>              cpuset context, nor when the set of nodes allowed by the<br>              process's current cpuset context changes.<br><br>       <b>MPOL_F_RELATIVE_NODES </b>(since Linux-2.6.26)<br>              A nonempty <i>nodemask</i> specifies node ids that are relative to<br>              the set of node ids allowed by the process's current cpuset.<br><br>       <i>nodemask</i> points to a bit mask of nodes containing up to <i>maxnode</i> bits.<br>       The bit mask size is rounded to the next multiple of <i>sizeof(unsigned</i><br>       <i>long)</i>, but the kernel will use bits only up to <i>maxnode</i>.  A NULL value<br>       of <i>nodemask</i> or a <i>maxnode</i> value of zero specifies the empty set of<br>       nodes.  If the value of <i>maxnode</i> is zero, the <i>nodemask</i> argument is<br>       ignored.  Where a <i>nodemask</i> is required, it must contain at least one<br>       node that is on-line, allowed by the process's current cpuset context<br>       [unless the <b>MPOL_F_STATIC_NODES </b>mode flag is specified], and contains<br>       memory.<br><br>       The <b>MPOL_DEFAULT </b>mode requests that any nondefault policy be removed,<br>       restoring default behavior.  When applied to a range of memory via<br>       <b>mbind</b>(), this means to use the process policy, which may have been<br>       set with set_mempolicy(2).  If the mode of the process policy is also<br>       <b>MPOL_DEFAULT</b>, the system-wide default policy will be used.  The<br>       system-wide default policy allocates pages on the node of the CPU<br>       that triggers the allocation.  For <b>MPOL_DEFAULT</b>, the <i>nodemask</i> and<br>       <i>maxnode</i> arguments must be specify the empty set of nodes.<br><br>       The <b>MPOL_BIND </b>mode specifies a strict policy that restricts memory<br>       allocation to the nodes specified in <i>nodemask</i>.  If <i>nodemask</i> specifies<br>       more than one node, page allocations will come from the node with the<br>       lowest numeric node ID first, until that node contains no free<br>       memory.  Allocations will then come from the node with the next<br>       highest node ID specified in <i>nodemask</i> and so forth, until none of the<br>       specified nodes contain free memory.  Pages will not be allocated<br>       from any node not specified in the <i>nodemask</i>.<br><br>       The <b>MPOL_INTERLEAVE </b>mode specifies that page allocations be<br>       interleaved across the set of nodes specified in <i>nodemask</i>.  This<br>       optimizes for bandwidth instead of latency by spreading out pages and<br>       memory accesses to those pages across multiple nodes.  To be<br>       effective the memory area should be fairly large, at least 1MB or<br>       bigger with a fairly uniform access pattern.  Accesses to a single<br>       page of the area will still be limited to the memory bandwidth of a<br>       single node.<br><br>       <b>MPOL_PREFERRED </b>sets the preferred node for allocation.  The kernel<br>       will try to allocate pages from this node first and fall back to<br>       other nodes if the preferred nodes is low on free memory.  If<br>       <i>nodemask</i> specifies more than one node ID, the first node in the mask<br>       will be selected as the preferred node.  If the <i>nodemask</i> and <i>maxnode</i><br>       arguments specify the empty set, then the memory is allocated on the<br>       node of the CPU that triggered the allocation.  This is the only way<br>       to specify \"local allocation\" for a range of memory via <b>mbind</b>().<br><br>       If <b>MPOL_MF_STRICT </b>is passed in <i>flags</i> and <i>mode</i> is not <b>MPOL_DEFAULT</b>,<br>       then the call will fail with the error <b>EIO </b>if the existing pages in<br>       the memory range don't follow the policy.<br><br>       If <b>MPOL_MF_MOVE </b>is specified in <i>flags</i>, then the kernel will attempt<br>       to move all the existing pages in the memory range so that they<br>       follow the policy.  Pages that are shared with other processes will<br>       not be moved.  If <b>MPOL_MF_STRICT </b>is also specified, then the call<br>       will fail with the error <b>EIO </b>if some pages could not be moved.<br><br>       If <b>MPOL_MF_MOVE_ALL </b>is passed in <i>flags</i>, then the kernel will attempt<br>       to move all existing pages in the memory range regardless of whether<br>       other processes use the pages.  The calling process must be<br>       privileged (<b>CAP_SYS_NICE</b>) to use this flag.  If <b>MPOL_MF_STRICT </b>is<br>       also specified, then the call will fail with the error <b>EIO </b>if some<br>       pages could not be moved.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>mbind</b>() returns 0; on error, -1 is returned and <i>errno</i> is<br>       set to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EFAULT </b>Part or all of the memory range specified by <i>nodemask</i> and<br>              <i>maxnode</i> points outside your accessible address space.  Or,<br>              there was an unmapped hole in the specified memory range<br>              specified by <i>addr</i> and <i>len</i>.<br><br>       <b>EINVAL </b>An invalid value was specified for <i>flags</i> or <i>mode</i>; or <i>addr +</i><br>              <i>len</i> was less than <i>addr</i>; or <i>addr</i> is not a multiple of the<br>              system page size.  Or, <i>mode</i> is <b>MPOL_DEFAULT </b>and <i>nodemask</i><br>              specified a nonempty set; or <i>mode</i> is <b>MPOL_BIND </b>or<br>              <b>MPOL_INTERLEAVE </b>and <i>nodemask</i> is empty.  Or, <i>maxnode</i> exceeds a<br>              kernel-imposed limit.  Or, <i>nodemask</i> specifies one or more node<br>              IDs that are greater than the maximum supported node ID.  Or,<br>              none of the node IDs specified by <i>nodemask</i> are on-line and<br>              allowed by the process's current cpuset context, or none of<br>              the specified nodes contain memory.  Or, the <i>mode</i> argument<br>              specified both <b>MPOL_F_STATIC_NODES </b>and <b>MPOL_F_RELATIVE_NODES</b>.<br><br>       <b>EIO    MPOL_MF_STRICT </b>was specified and an existing page was already<br>              on a node that does not follow the policy; or <b>MPOL_MF_MOVE </b>or<br>              <b>MPOL_MF_MOVE_ALL </b>was specified and the kernel was unable to<br>              move all existing pages in the range.<br><br>       <b>ENOMEM </b>Insufficient kernel memory was available.<br><br>       <b>EPERM  </b>The <i>flags</i> argument included the <b>MPOL_MF_MOVE_ALL </b>flag and the<br>              caller does not have the <b>CAP_SYS_NICE </b>privilege.<br></pre><br><h2>VERSIONS  </h2><pre><br>       The <b>mbind</b>() system call was added to the Linux kernel in version<br>       2.6.7.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       This system call is Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       For information on library support, see numa(7).<br><br>       NUMA policy is not supported on a memory-mapped file range that was<br>       mapped with the <b>MAP_SHARED </b>flag.<br><br>       The <b>MPOL_DEFAULT </b>mode can have different effects for <b>mbind</b>() and<br>       set_mempolicy(2).  When <b>MPOL_DEFAULT </b>is specified for<br>       set_mempolicy(2), the process's policy reverts to system default<br>       policy or local allocation.  When <b>MPOL_DEFAULT </b>is specified for a<br>       range of memory using <b>mbind</b>(), any pages subsequently allocated for<br>       that range will use the process's policy, as set by set_mempolicy(2).<br>       This effectively removes the explicit policy from the specified<br>       range, \"falling back\" to a possibly nondefault policy.  To select<br>       explicit \"local allocation\" for a memory range, specify a <i>mode</i> of<br>       <b>MPOL_PREFERRED </b>with an empty set of nodes.  This method will work for<br>       set_mempolicy(2), as well.<br><br>       Support for huge page policy was added with 2.6.16.  For interleave<br>       policy to be effective on huge page mappings the policied memory<br>       needs to be tens of megabytes or larger.<br><br>       <b>MPOL_MF_STRICT </b>is ignored on huge page mappings.<br><br>       <b>MPOL_MF_MOVE </b>and <b>MPOL_MF_MOVE_ALL </b>are available only on Linux 2.6.16<br>       and later.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       get_mempolicy(2), getcpu(2), mmap(2), set_mempolicy(2), shmat(2),<br>       shmget(2), numa(3), cpuset(7), numa(7), numactl(8)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-01-22                         MBIND(2)</span><br></pre><br>"}