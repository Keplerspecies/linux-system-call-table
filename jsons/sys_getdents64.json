{"Man page": "<pre><br><span class=\"headline\">GETDENTS(2)               Linux Programmer's Manual              GETDENTS(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       getdents, getdents64 - get directory entries<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>int getdents(unsigned int </b><i>fd</i><b>, struct linux_dirent *</b><i>dirp</i><b>,</b><br>                    <b>unsigned int </b><i>count</i><b>);</b><br>       <b>int getdents64(unsigned int </b><i>fd</i><b>, struct linux_dirent64 *</b><i>dirp</i><b>,</b><br>                    <b>unsigned int </b><i>count</i><b>);</b><br><br>       <i>Note</i>: There are no glibc wrappers for these system calls; see NOTES.<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       These are not the interfaces you are interested in.  Look at<br>       readdir(3) for the POSIX-conforming C library interface.  This page<br>       documents the bare kernel system call interfaces.<br><br>   <b>getdents()</b><br>       The system call <b>getdents</b>() reads several <i>linux_dirent</i> structures from<br>       the directory referred to by the open file descriptor <i>fd</i> into the<br>       buffer pointed to by <i>dirp</i>.  The argument <i>count</i> specifies the size of<br>       that buffer.<br><br>       The <i>linux_dirent</i> structure is declared as follows:<br><br>           struct linux_dirent {<br>               unsigned long  d_ino;     /* Inode number */<br>               unsigned long  d_off;     /* Offset to next <i>linux_dirent</i> */<br>               unsigned short d_reclen;  /* Length of this <i>linux_dirent</i> */<br>               char           d_name[];  /* Filename (null-terminated) */<br>                                 /* length is actually (d_reclen - 2 -<br>                                    offsetof(struct linux_dirent, d_name)) */<br>               /*<br>               char           pad;       // Zero padding byte<br>               char           d_type;    // File type (only since Linux<br>                                         // 2.6.4); offset is (d_reclen - 1)<br>               */<br>           }<br><br>       <i>d_ino</i> is an inode number.  <i>d_off</i> is the distance from the start of<br>       the directory to the start of the next <i>linux_dirent</i>.  <i>d_reclen</i> is the<br>       size of this entire <i>linux_dirent</i>.  <i>d_name</i> is a null-terminated<br>       filename.<br><br>       <i>d_type</i> is a byte at the end of the structure that indicates the file<br>       type.  It contains one of the following values (defined in<br>       <i>&lt;dirent.h&gt;</i>):<br><br>       <b>DT_BLK      </b>This is a block device.<br><br>       <b>DT_CHR      </b>This is a character device.<br><br>       <b>DT_DIR      </b>This is a directory.<br><br>       <b>DT_FIFO     </b>This is a named pipe (FIFO).<br><br>       <b>DT_LNK      </b>This is a symbolic link.<br><br>       <b>DT_REG      </b>This is a regular file.<br><br>       <b>DT_SOCK     </b>This is a UNIX domain socket.<br><br>       <b>DT_UNKNOWN  </b>The file type is unknown.<br><br>       The <i>d_type</i> field is implemented since Linux 2.6.4.  It occupies a<br>       space that was previously a zero-filled padding byte in the<br>       <i>linux_dirent</i> structure.  Thus, on kernels up to and including 2.6.3,<br>       attempting to access this field always provides the value 0<br>       (<b>DT_UNKNOWN</b>).<br><br>       Currently, only some filesystems (among them: Btrfs, ext2, ext3, and<br>       ext4) have full support for returning the file type in <i>d_type</i>.  All<br>       applications must properly handle a return of <b>DT_UNKNOWN</b>.<br><br>   <b>getdents64()</b><br>       The original Linux <b>getdents</b>() system call did not handle large<br>       filesystems and large file offsets.  Consequently, Linux 2.4 added<br>       <b>getdents64</b>(), with wider types for the <i>d_ino</i> and <i>d_off</i> fields.  In<br>       addition, <b>getdents64</b>() supports an explicit <i>d_type</i> field.<br><br>       The <b>getdents64</b>() system call is like <b>getdents</b>(), except that its<br>       second argument is a pointer to a buffer containing structures of the<br>       following type:<br><br>           struct linux_dirent64 {<br>               ino64_t        d_ino;    /* 64-bit inode number */<br>               off64_t        d_off;    /* 64-bit offset to next structure */<br>               unsigned short d_reclen; /* Size of this dirent */<br>               unsigned char  d_type;   /* File type */<br>               char           d_name[]; /* Filename (null-terminated) */<br>           };<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, the number of bytes read is returned.  On end of<br>       directory, 0 is returned.  On error, -1 is returned, and <i>errno</i> is set<br>       appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EBADF  </b>Invalid file descriptor <i>fd</i>.<br><br>       <b>EFAULT </b>Argument points outside the calling process's address space.<br><br>       <b>EINVAL </b>Result buffer is too small.<br><br>       <b>ENOENT </b>No such directory.<br><br>       <b>ENOTDIR</b><br>              File descriptor does not refer to a directory.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       SVr4.<br></pre><br><h2>NOTES  </h2><pre><br>       Glibc does not provide a wrapper for these system calls; call them<br>       using syscall(2).  You will need to define the <i>linux_dirent</i> or<br>       <i>linux_dirent64</i> structure yourself.  However, you probably want to use<br>       readdir(3) instead.<br><br>       These calls supersede readdir(2).<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The program below demonstrates the use of <b>getdents</b>().  The following<br>       output shows an example of what we see when running this program on<br>       an ext2 directory:<br><br>           $ <b>./a.out /testfs/</b><br>           --------------- nread=120 ---------------<br>           inode#    file type  d_reclen  d_off   d_name<br>                  2  directory    16         12  .<br>                  2  directory    16         24  ..<br>                 11  directory    24         44  lost+found<br>                 12  regular      16         56  a<br>             228929  directory    16         68  sub<br>              16353  directory    16         80  sub2<br>             130817  directory    16       4096  sub3<br><br>   <b>Program source</b><br><br>       #define _GNU_SOURCE<br>       #include &lt;dirent.h&gt;     /* Defines DT_* constants */<br>       #include &lt;fcntl.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;unistd.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;sys/stat.h&gt;<br>       #include &lt;sys/syscall.h&gt;<br><br>       #define handle_error(msg) \\<br>               do { perror(msg); exit(EXIT_FAILURE); } while (0)<br><br>       struct linux_dirent {<br>           long           d_ino;<br>           off_t          d_off;<br>           unsigned short d_reclen;<br>           char           d_name[];<br>       };<br><br>       #define BUF_SIZE 1024<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           int fd, nread;<br>           char buf[BUF_SIZE];<br>           struct linux_dirent *d;<br>           int bpos;<br>           char d_type;<br><br>           fd = open(argc &gt; 1 ? argv[1] : \".\", O_RDONLY | O_DIRECTORY);<br>           if (fd == -1)<br>               handle_error(\"open\");<br><br>           for ( ; ; ) {<br>               nread = syscall(SYS_getdents, fd, buf, BUF_SIZE);<br>               if (nread == -1)<br>                   handle_error(\"getdents\");<br><br>               if (nread == 0)<br>                   break;<br><br>               printf(\"--------------- nread=%d ---------------\\n\", nread);<br>               printf(\"inode#    file type  d_reclen  d_off   d_name\\n\");<br>               for (bpos = 0; bpos &lt; nread;) {<br>                   d = (struct linux_dirent *) (buf + bpos);<br>                   printf(\"%8ld  \", d-&gt;d_ino);<br>                   d_type = *(buf + bpos + d-&gt;d_reclen - 1);<br>                   printf(\"%-10s \", (d_type == DT_REG) ?  \"regular\" :<br>                                    (d_type == DT_DIR) ?  \"directory\" :<br>                                    (d_type == DT_FIFO) ? \"FIFO\" :<br>                                    (d_type == DT_SOCK) ? \"socket\" :<br>                                    (d_type == DT_LNK) ?  \"symlink\" :<br>                                    (d_type == DT_BLK) ?  \"block dev\" :<br>                                    (d_type == DT_CHR) ?  \"char dev\" : \"???\");<br>                   printf(\"%4d %10lld  %s\\n\", d-&gt;d_reclen,<br>                           (long long) d-&gt;d_off, d-&gt;d_name);<br>                   bpos += d-&gt;d_reclen;<br>               }<br>           }<br><br>           exit(EXIT_SUCCESS);<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       readdir(2), readdir(3)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-04-12                      GETDENTS(2)</span><br></pre><br>"}