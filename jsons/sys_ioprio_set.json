{"Man page": "<pre><br><span class=\"headline\">IOPRIO_SET(2)             Linux Programmer's Manual            IOPRIO_SET(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       ioprio_get, ioprio_set - get/set I/O scheduling class and priority<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>int ioprio_get(int </b><i>which</i><b>, int </b><i>who</i><b>);</b><br>       <b>int ioprio_set(int </b><i>which</i><b>, int </b><i>who</i><b>, int </b><i>ioprio</i><b>);</b><br><br>       <i>Note</i>: There are no glibc wrappers for these system calls; see NOTES.<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>ioprio_get</b>() and <b>ioprio_set</b>() system calls respectively get and<br>       set the I/O scheduling class and priority of one or more threads.<br><br>       The <i>which</i> and <i>who</i> arguments identify the thread(s) on which the<br>       system calls operate.  The <i>which</i> argument determines how <i>who</i> is<br>       interpreted, and has one of the following values:<br><br>       <b>IOPRIO_WHO_PROCESS</b><br>              <i>who</i> is a process ID or thread ID identifying a single process<br>              or thread.  If <i>who</i> is 0, then operate on the calling thread.<br><br>       <b>IOPRIO_WHO_PGRP</b><br>              <i>who</i> is a process group ID identifying all the members of a<br>              process group.  If <i>who</i> is 0, then operate on the process group<br>              of which the caller is a member.<br><br>       <b>IOPRIO_WHO_USER</b><br>              <i>who</i> is a user ID identifying all of the processes that have a<br>              matching real UID.<br><br>       If <i>which</i> is specified as <b>IOPRIO_WHO_PGRP </b>or <b>IOPRIO_WHO_USER </b>when<br>       calling <b>ioprio_get</b>(), and more than one process matches <i>who</i>, then the<br>       returned priority will be the highest one found among all of the<br>       matching processes.  One priority is said to be higher than another<br>       one if it belongs to a higher priority class (<b>IOPRIO_CLASS_RT </b>is the<br>       highest priority class; <b>IOPRIO_CLASS_IDLE </b>is the lowest) or if it<br>       belongs to the same priority class as the other process but has a<br>       higher priority level (a lower priority number means a higher<br>       priority level).<br><br>       The <i>ioprio</i> argument given to <b>ioprio_set</b>() is a bit mask that<br>       specifies both the scheduling class and the priority to be assigned<br>       to the target process(es).  The following macros are used for<br>       assembling and dissecting <i>ioprio</i> values:<br><br>       <b>IOPRIO_PRIO_VALUE(</b><i>class</i><b>, </b><i>data</i><b>)</b><br>              Given a scheduling <i>class</i> and priority (<i>data</i>), this macro<br>              combines the two values to produce an <i>ioprio</i> value, which is<br>              returned as the result of the macro.<br><br>       <b>IOPRIO_PRIO_CLASS(</b><i>mask</i><b>)</b><br>              Given <i>mask</i> (an <i>ioprio</i> value), this macro returns its I/O class<br>              component, that is, one of the values <b>IOPRIO_CLASS_RT</b>,<br>              <b>IOPRIO_CLASS_BE</b>, or <b>IOPRIO_CLASS_IDLE</b>.<br><br>       <b>IOPRIO_PRIO_DATA(</b><i>mask</i><b>)</b><br>              Given <i>mask</i> (an <i>ioprio</i> value), this macro returns its priority<br>              (<i>data</i>) component.<br><br>       See the NOTES section for more information on scheduling classes and<br>       priorities, as well as the meaning of specifying <i>ioprio</i> as 0.<br><br>       I/O priorities are supported for reads and for synchronous (<b>O_DIRECT</b>,<br>       <b>O_SYNC</b>) writes.  I/O priorities are not supported for asynchronous<br>       writes because they are issued outside the context of the program<br>       dirtying the memory, and thus program-specific priorities do not<br>       apply.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>ioprio_get</b>() returns the <i>ioprio</i> value of the process with<br>       highest I/O priority of any of the processes that match the criteria<br>       specified in <i>which</i> and <i>who</i>.  On error, -1 is returned, and <i>errno</i> is<br>       set to indicate the error.<br><br>       On success, <b>ioprio_set</b>() returns 0.  On error, -1 is returned, and<br>       <i>errno</i> is set to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EINVAL </b>Invalid value for <i>which</i> or <i>ioprio</i>.  Refer to the NOTES section<br>              for available scheduler classes and priority levels for<br>              <i>ioprio</i>.<br><br>       <b>EPERM  </b>The calling process does not have the privilege needed to<br>              assign this <i>ioprio</i> to the specified process(es).  See the<br>              NOTES section for more information on required privileges for<br>              <b>ioprio_set</b>().<br><br>       <b>ESRCH  </b>No process(es) could be found that matched the specification<br>              in <i>which</i> and <i>who</i>.<br></pre><br><h2>VERSIONS  </h2><pre><br>       These system calls have been available on Linux since kernel 2.6.13.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       These system calls are Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       Glibc does not provide a wrapper for these system calls; call them<br>       using syscall(2).<br><br>       Two or more processes or threads can share an I/O context.  This will<br>       be the case when clone(2) was called with the <b>CLONE_IO </b>flag.<br>       However, by default, the distinct threads of a process will <b>not </b>share<br>       the same I/O context.  This means that if you want to change the I/O<br>       priority of all threads in a process, you may need to call<br>       <b>ioprio_set</b>() on each of the threads.  The thread ID that you would<br>       need for this operation is the one that is returned by gettid(2) or<br>       clone(2).<br><br>       These system calls have an effect only when used in conjunction with<br>       an I/O scheduler that supports I/O priorities.  As at kernel 2.6.17<br>       the only such scheduler is the Completely Fair Queuing (CFQ) I/O<br>       scheduler.<br><br>       If no I/O scheduler has been set for a thread, then by default the<br>       I/O priority will follow the CPU nice value (setpriority(2)).  In<br>       Linux kernels before version 2.6.24, once an I/O priority had been<br>       set using <b>ioprio_set</b>(), there was no way to reset the I/O scheduling<br>       behavior to the default.  Since Linux 2.6.24, specifying <i>ioprio</i> as 0<br>       can be used to reset to the default I/O scheduling behavior.<br><br>   <b>Selecting an I/O scheduler</b><br>       I/O schedulers are selected on a per-device basis via the special<br>       file <i>/sys/block/&lt;device&gt;/queue/scheduler</i>.<br><br>       One can view the current I/O scheduler via the <i>/sys</i> filesystem.  For<br>       example, the following command displays a list of all schedulers<br>       currently loaded in the kernel:<br><br>              $ <b>cat /sys/block/sda/queue/scheduler</b><br>              noop anticipatory deadline [cfq]<br><br>       The scheduler surrounded by brackets is the one actually in use for<br>       the device (<i>sda</i> in the example).  Setting another scheduler is done<br>       by writing the name of the new scheduler to this file.  For example,<br>       the following command will set the scheduler for the <i>sda</i> device to<br>       <i>cfq</i>:<br><br>              $ <b>su</b><br>              Password:<br>              # <b>echo cfq &gt; /sys/block/sda/queue/scheduler</b><br><br>   <b>The Completely Fair Queuing (CFQ) I/O scheduler</b><br>       Since version 3 (also known as CFQ Time Sliced), CFQ implements I/O<br>       nice levels similar to those of CPU scheduling.  These nice levels<br>       are grouped into three scheduling classes, each one containing one or<br>       more priority levels:<br><br>       <b>IOPRIO_CLASS_RT </b>(1)<br>              This is the real-time I/O class.  This scheduling class is<br>              given higher priority than any other class: processes from<br>              this class are given first access to the disk every time.<br>              Thus, this I/O class needs to be used with some care: one I/O<br>              real-time process can starve the entire system.  Within the<br>              real-time class, there are 8 levels of class data (priority)<br>              that determine exactly how much time this process needs the<br>              disk for on each service.  The highest real-time priority<br>              level is 0; the lowest is 7.  In the future, this might change<br>              to be more directly mappable to performance, by passing in a<br>              desired data rate instead.<br><br>       <b>IOPRIO_CLASS_BE </b>(2)<br>              This is the best-effort scheduling class, which is the default<br>              for any process that hasn't set a specific I/O priority.  The<br>              class data (priority) determines how much I/O bandwidth the<br>              process will get.  Best-effort priority levels are analogous<br>              to CPU nice values (see getpriority(2)).  The priority level<br>              determines a priority relative to other processes in the best-<br>              effort scheduling class.  Priority levels range from 0<br>              (highest) to 7 (lowest).<br><br>       <b>IOPRIO_CLASS_IDLE </b>(3)<br>              This is the idle scheduling class.  Processes running at this<br>              level get I/O time only when no-one else needs the disk.  The<br>              idle class has no class data.  Attention is required when<br>              assigning this priority class to a process, since it may<br>              become starved if higher priority processes are constantly<br>              accessing the disk.<br><br>       Refer to the kernel source file <i>Documentation/block/ioprio.txt</i> for<br>       more information on the CFQ I/O Scheduler and an example program.<br><br>   <b>Required permissions to set I/O priorities</b><br>       Permission to change a process's priority is granted or denied based<br>       on two criteria:<br><br>       <b>Process ownership</b><br>              An unprivileged process may set the I/O priority only for a<br>              process whose real UID matches the real or effective UID of<br>              the calling process.  A process which has the <b>CAP_SYS_NICE</b><br>              capability can change the priority of any process.<br><br>       <b>What is the desired priority</b><br>              Attempts to set very high priorities (<b>IOPRIO_CLASS_RT</b>) require<br>              the <b>CAP_SYS_ADMIN </b>capability.  Kernel versions up to 2.6.24<br>              also required <b>CAP_SYS_ADMIN </b>to set a very low priority<br>              (<b>IOPRIO_CLASS_IDLE</b>), but since Linux 2.6.25, this is no longer<br>              required.<br><br>       A call to <b>ioprio_set</b>() must follow both rules, or the call will fail<br>       with the error <b>EPERM</b>.<br></pre><br><h2>BUGS  </h2><pre><br>       Glibc does not yet provide a suitable header file defining the<br>       function prototypes and macros described on this page.  Suitable<br>       definitions can be found in <i>linux/ioprio.h</i>.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       ionice(1), getpriority(2), open(2), capabilities(7)<br><br>       <i>Documentation/block/ioprio.txt</i> in the Linux kernel source tree<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                    IOPRIO_SET(2)</span><br></pre><br>"}