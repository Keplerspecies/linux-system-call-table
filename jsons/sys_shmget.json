{"Man page": "<pre><br><span class=\"headline\">SHMGET(2)                 Linux Programmer's Manual                SHMGET(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       shmget - allocates a System V shared memory segment<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/ipc.h&gt;</b><br>       <b>#include &lt;sys/shm.h&gt;</b><br><br>       <b>int shmget(key_t </b><i>key</i><b>, size_t </b><i>size</i><b>, int </b><i>shmflg</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>shmget</b>() returns the identifier of the System V shared memory segment<br>       associated with the value of the argument <i>key</i>.  A new shared memory<br>       segment, with size equal to the value of <i>size</i> rounded up to a<br>       multiple of <b>PAGE_SIZE</b>, is created if <i>key</i> has the value <b>IPC_PRIVATE </b>or<br>       <i>key</i> isn't <b>IPC_PRIVATE</b>, no shared memory segment corresponding to <i>key</i><br>       exists, and <b>IPC_CREAT </b>is specified in <i>shmflg</i>.<br><br>       If <i>shmflg</i> specifies both <b>IPC_CREAT </b>and <b>IPC_EXCL </b>and a shared memory<br>       segment already exists for <i>key</i>, then <b>shmget</b>() fails with <i>errno</i> set to<br>       <b>EEXIST</b>.  (This is analogous to the effect of the combination <b>O_CREAT</b><br>       <b>| O_EXCL </b>for open(2).)<br><br>       The value <i>shmflg</i> is composed of:<br><br>       <b>IPC_CREAT   </b>Create a new segment.  If this flag is not used, then<br>                   <b>shmget</b>() will find the segment associated with <i>key</i> and<br>                   check to see if the user has permission to access the<br>                   segment.<br><br>       <b>IPC_EXCL    </b>This flag is used with <b>IPC_CREAT </b>to ensure that this call<br>                   creates the segment.  If the segment already exists, the<br>                   call fails.<br><br>       <b>SHM_HUGETLB </b>(since Linux 2.6)<br>                   Allocate the segment using \"huge pages.\"  See the Linux<br>                   kernel source file <i>Documentation/vm/hugetlbpage.txt</i> for<br>                   further information.<br><br>       <b>SHM_HUGE_2MB</b>, <b>SHM_HUGE_1GB </b>(since Linux 3.8)<br>                   Used in conjunction with <b>SHM_HUGETLB </b>to select<br>                   alternative hugetlb page sizes (respectively, 2 MB and 1<br>                   GB) on systems that support multiple hugetlb page sizes.<br><br>                   More generally, the desired huge page size can be<br>                   configured by encoding the base-2 logarithm of the<br>                   desired page size in the six bits at the offset<br>                   <b>SHM_HUGE_SHIFT</b>.  Thus, the above two constants are<br>                   defined as:<br><br>                       #define SHM_HUGE_2MB    (21 &lt;&lt; SHM_HUGE_SHIFT)<br>                       #define SHM_HUGE_1GB    (30 &lt;&lt; SHM_HUGE_SHIFT)<br><br>                   For some additional details, see the discussion of the<br>                   similarly named constants in mmap(2).<br><br>       <b>SHM_NORESERVE </b>(since Linux 2.6.15)<br>                   This flag serves the same purpose as the mmap(2)<br>                   <b>MAP_NORESERVE </b>flag.  Do not reserve swap space for this<br>                   segment.  When swap space is reserved, one has the<br>                   guarantee that it is possible to modify the segment.<br>                   When swap space is not reserved one might get <b>SIGSEGV</b><br>                   upon a write if no physical memory is available.  See<br>                   also the discussion of the file<br>                   <i>/proc/sys/vm/overcommit_memory</i> in proc(5).<br><br>       In addition to the above flags, the least significant 9 bits of<br>       <i>shmflg</i> specify the permissions granted to the owner, group, and<br>       others.  These bits have the same format, and the same meaning, as<br>       the <i>mode</i> argument of open(2).  Presently, execute permissions are not<br>       used by the system.<br><br>       When a new shared memory segment is created, its contents are<br>       initialized to zero values, and its associated data structure,<br>       <i>shmid_ds</i> (see shmctl(2)), is initialized as follows:<br><br>              <i>shm_perm.cuid</i> and <i>shm_perm.uid</i> are set to the effective user<br>              ID of the calling process.<br><br>              <i>shm_perm.cgid</i> and <i>shm_perm.gid</i> are set to the effective group<br>              ID of the calling process.<br><br>              The least significant 9 bits of <i>shm_perm.mode</i> are set to the<br>              least significant 9 bit of <i>shmflg</i>.<br><br>              <i>shm_segsz</i> is set to the value of <i>size</i>.<br><br>              <i>shm_lpid</i>, <i>shm_nattch</i>, <i>shm_atime</i>, and <i>shm_dtime</i> are set to 0.<br><br>              <i>shm_ctime</i> is set to the current time.<br><br>       If the shared memory segment already exists, the permissions are<br>       verified, and a check is made to see if it is marked for destruction.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, a valid shared memory identifier is returned.  On error,<br>       -1 is returned, and <i>errno</i> is set to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       On failure, <i>errno</i> is set to one of the following:<br><br>       <b>EACCES </b>The user does not have permission to access the shared memory<br>              segment, and does not have the <b>CAP_IPC_OWNER </b>capability.<br><br>       <b>EEXIST IPC_CREAT </b>and <b>IPC_EXCL </b>were specified in <i>shmflg</i>, but a shared<br>              memory segment already exists for <i>key</i>.<br><br>       <b>EINVAL </b>A new segment was to be created and <i>size</i> is less than <b>SHMMIN</b><br>              or greater than <b>SHMMAX</b>.<br><br>       <b>EINVAL </b>A segment for the given <i>key</i> exists, but <i>size</i> is greater than<br>              the size of that segment.<br><br>       <b>ENFILE </b>The system limit on the total number of open files has been<br>              reached.<br><br>       <b>ENOENT </b>No segment exists for the given <i>key</i>, and <b>IPC_CREAT </b>was not<br>              specified.<br><br>       <b>ENOMEM </b>No memory could be allocated for segment overhead.<br><br>       <b>ENOSPC </b>All possible shared memory IDs have been taken (<b>SHMMNI</b>), or<br>              allocating a segment of the requested <i>size</i> would cause the<br>              system to exceed the system-wide limit on shared memory<br>              (<b>SHMALL</b>).<br><br>       <b>EPERM  </b>The <b>SHM_HUGETLB </b>flag was specified, but the caller was not<br>              privileged (did not have the <b>CAP_IPC_LOCK </b>capability).<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008, SVr4.<br><br>       <b>SHM_HUGETLB </b>and <b>SHM_NORESERVE </b>are Linux extensions.<br></pre><br><h2>NOTES  </h2><pre><br>       The inclusion of <i>&lt;sys/types.h&gt;</i> and <i>&lt;sys/ipc.h&gt;</i> isn't required on<br>       Linux or by any version of POSIX.  However, some old implementations<br>       required the inclusion of these header files, and the SVID also<br>       documented their inclusion.  Applications intended to be portable to<br>       such old systems may need to include these header files.<br><br>       <b>IPC_PRIVATE </b>isn't a flag field but a <i>key_t</i> type.  If this special<br>       value is used for <i>key</i>, the system call ignores all but the least<br>       significant 9 bits of <i>shmflg</i> and creates a new shared memory segment.<br><br>   <b>Shared memory limits</b><br>       The following limits on shared memory segment resources affect the<br>       <b>shmget</b>() call:<br><br>       <b>SHMALL </b>System-wide limit on the total amount of shared memory,<br>              measured in units of the system page size.<br><br>              On Linux, this limit can be read and modified via<br>              <i>/proc/sys/kernel/shmall</i>.  Since Linux 3.16, the default value<br>              for this limit is:<br><br>                  ULONG_MAX - 2^24<br><br>              The effect of this value (which is suitable for both 32-bit<br>              and 64-bit systems) is to impose no limitation on allocations.<br>              This value, rather than <b>ULONG_MAX</b>, was chosen as the default<br>              to prevent some cases where historical applications simply<br>              raised the existing limit without first checking its current<br>              value.  Such applications would cause the value to overflow if<br>              the limit was set at <b>ULONG_MAX</b>.<br><br>              From Linux 2.4 up to Linux 3.15, the default value for this<br>              limit was:<br><br>                  SHMMAX / PAGE_SIZE * (SHMMNI / 16)<br><br>              If <b>SHMMAX </b>and <b>SHMMNI </b>were not modified, then multiplying the<br>              result of this formula by the page size (to get a value in<br>              bytes) yielded a value of 8 GB as the limit on the total<br>              memory used by all shared memory segments.<br><br>       <b>SHMMAX </b>Maximum size in bytes for a shared memory segment.<br><br>              On Linux, this limit can be read and modified via<br>              <i>/proc/sys/kernel/shmmax</i>.  Since Linux 3.16, the default value<br>              for this limit is:<br><br>                  ULONG_MAX - 2^24<br><br>              The effect of this value (which is suitable for both 32-bit<br>              and 64-bit systems) is to impose no limitation on allocations.<br>              See the description of <b>SHMALL </b>for a discussion of why this<br>              default value (rather than <b>ULONG_MAX</b>) is used.<br><br>              From Linux 2.2 up to Linux 3.15, the default value of this<br>              limit was 0x2000000 (32MB).<br><br>              Because it is not possible to map just part of a shared memory<br>              segment, the amount of virtual memory places another limit on<br>              the maximum size of a usable segment: for example, on i386 the<br>              largest segments that can be mapped have a size of around 2.8<br>              GB, and on x86_64 the limit is around 127 TB.<br><br>       <b>SHMMIN </b>Minimum size in bytes for a shared memory segment:<br>              implementation dependent (currently 1 byte, though <b>PAGE_SIZE</b><br>              is the effective minimum size).<br><br>       <b>SHMMNI </b>System-wide limit on the number of shared memory segments.  In<br>              Linux 2.2, the default value for this limit was 128; since<br>              Linux 2.4, the default value is 4096.<br><br>              On Linux, this limit can be read and modified via<br>              <i>/proc/sys/kernel/shmmni</i>.<br><br>       The implementation has no specific limits for the per-process maximum<br>       number of shared memory segments (<b>SHMSEG</b>).<br><br>   <b>Linux notes</b><br>       Until version 2.3.30, Linux would return <b>EIDRM </b>for a <b>shmget</b>() on a<br>       shared memory segment scheduled for deletion.<br></pre><br><h2>BUGS  </h2><pre><br>       The name choice <b>IPC_PRIVATE </b>was perhaps unfortunate, <b>IPC_NEW </b>would<br>       more clearly show its function.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       memfd_create(2), shmat(2), shmctl(2), shmdt(2), ftok(3),<br>       capabilities(7), shm_overview(7), svipc(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-08-08                        SHMGET(2)</span><br></pre><br>"}