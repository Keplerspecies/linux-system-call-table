{"Man page": "<pre><br><span class=\"headline\">MREMAP(2)                 Linux Programmer's Manual                MREMAP(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       mremap - remap a virtual memory address<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#define _GNU_SOURCE         </b>/* See feature_test_macros(7) */<br>       <b>#include &lt;sys/mman.h&gt;</b><br><br>       <b>void *mremap(void *</b><i>old_address</i><b>, size_t </b><i>old_size</i><b>,</b><br>                    <b>size_t </b><i>new_size</i><b>, int </b><i>flags</i><b>, ... /* void *</b><i>new_address</i> <b>*/);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>mremap</b>() expands (or shrinks) an existing memory mapping, potentially<br>       moving it at the same time (controlled by the <i>flags</i> argument and the<br>       available virtual address space).<br><br>       <i>old_address</i> is the old address of the virtual memory block that you<br>       want to expand (or shrink).  Note that <i>old_address</i> has to be page<br>       aligned.  <i>old_size</i> is the old size of the virtual memory block.<br>       <i>new_size</i> is the requested size of the virtual memory block after the<br>       resize.  An optional fifth argument, <i>new_address</i>, may be provided;<br>       see the description of <b>MREMAP_FIXED </b>below.<br><br>       In Linux the memory is divided into pages.  A user process has (one<br>       or) several linear virtual memory segments.  Each virtual memory<br>       segment has one or more mappings to real memory pages (in the page<br>       table).  Each virtual memory segment has its own protection (access<br>       rights), which may cause a segmentation violation if the memory is<br>       accessed incorrectly (e.g., writing to a read-only segment).<br>       Accessing virtual memory outside of the segments will also cause a<br>       segmentation violation.<br><br>       <b>mremap</b>() uses the Linux page table scheme.  <b>mremap</b>() changes the<br>       mapping between virtual addresses and memory pages.  This can be used<br>       to implement a very efficient realloc(3).<br><br>       The <i>flags</i> bit-mask argument may be 0, or include the following flag:<br><br>       <b>MREMAP_MAYMOVE</b><br>              By default, if there is not sufficient space to expand a<br>              mapping at its current location, then <b>mremap</b>() fails.  If this<br>              flag is specified, then the kernel is permitted to relocate<br>              the mapping to a new virtual address, if necessary.  If the<br>              mapping is relocated, then absolute pointers into the old<br>              mapping location become invalid (offsets relative to the<br>              starting address of the mapping should be employed).<br><br>       <b>MREMAP_FIXED </b>(since Linux 2.3.31)<br>              This flag serves a similar purpose to the <b>MAP_FIXED </b>flag of<br>              mmap(2).  If this flag is specified, then <b>mremap</b>() accepts a<br>              fifth argument, <i>void *new_address</i>, which specifies a page-<br>              aligned address to which the mapping must be moved.  Any<br>              previous mapping at the address range specified by <i>new_address</i><br>              and <i>new_size</i> is unmapped.  If <b>MREMAP_FIXED </b>is specified, then<br>              <b>MREMAP_MAYMOVE </b>must also be specified.<br><br>       If the memory segment specified by <i>old_address</i> and <i>old_size</i> is locked<br>       (using mlock(2) or similar), then this lock is maintained when the<br>       segment is resized and/or relocated.  As a consequence, the amount of<br>       memory locked by the process may change.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success <b>mremap</b>() returns a pointer to the new virtual memory area.<br>       On error, the value <b>MAP_FAILED </b>(that is, <i>(void *) -1</i>) is returned,<br>       and <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EAGAIN </b>The caller tried to expand a memory segment that is locked,<br>              but this was not possible without exceeding the <b>RLIMIT_MEMLOCK</b><br>              resource limit.<br><br>       <b>EFAULT </b>\"Segmentation fault.\" Some address in the range <i>old_address</i> to<br>              <i>old_address</i>+<i>old_size</i> is an invalid virtual memory address for<br>              this process.  You can also get <b>EFAULT </b>even if there exist<br>              mappings that cover the whole address space requested, but<br>              those mappings are of different types.<br><br>       <b>EINVAL </b>An invalid argument was given.  Possible causes are:<br>              <i>old_address</i> was not page aligned; a value other than<br>              <b>MREMAP_MAYMOVE </b>or <b>MREMAP_FIXED </b>was specified in <i>flags</i>;<br>              <i>new_size</i> was zero; <i>new_size</i> or <i>new_address</i> was invalid; or the<br>              new address range specified by <i>new_address</i> and <i>new_size</i><br>              overlapped the old address range specified by <i>old_address</i> and<br>              <i>old_size</i>; or <b>MREMAP_FIXED </b>was specified without also<br>              specifying <b>MREMAP_MAYMOVE</b>.<br><br>       <b>ENOMEM </b>The memory area cannot be expanded at the current virtual<br>              address, and the <b>MREMAP_MAYMOVE </b>flag is not set in <i>flags</i>.  Or,<br>              there is not enough (virtual) memory available.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       This call is Linux-specific, and should not be used in programs<br>       intended to be portable.<br></pre><br><h2>NOTES  </h2><pre><br>       Prior to version 2.4, glibc did not expose the definition of<br>       <b>MREMAP_FIXED</b>, and the prototype for <b>mremap</b>() did not allow for the<br>       <i>new_address</i> argument.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       brk(2), getpagesize(2), getrlimit(2), mlock(2), mmap(2), sbrk(2),<br>       malloc(3), realloc(3)<br><br>       Your favorite text book on operating systems for more information on<br>       paged memory (e.g., <i>Modern Operating Systems</i> by Andrew S. Tanenbaum,<br>       <i>Inside Linux</i> by Randolf Bentson, <i>The Design of the UNIX Operating</i><br>       <i>System</i> by Maurice J. Bach)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2010-06-10                        MREMAP(2)</span><br></pre><br>"}