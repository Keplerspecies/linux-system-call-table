{"Man page": "<pre><br><span class=\"headline\">SELECT(2)                 Linux Programmer's Manual                SELECT(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       select,  pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O<br>       multiplexing<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       /* According to POSIX.1-2001, POSIX.1-2008 */<br>       <b>#include &lt;sys/select.h&gt;</b><br><br>       /* According to earlier standards */<br>       <b>#include &lt;sys/time.h&gt;</b><br>       <b>#include &lt;sys/types.h&gt;</b><br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>int select(int </b><i>nfds</i><b>, fd_set *</b><i>readfds</i><b>, fd_set *</b><i>writefds</i><b>,</b><br>                  <b>fd_set *</b><i>exceptfds</i><b>, struct timeval *</b><i>timeout</i><b>);</b><br><br>       <b>void FD_CLR(int </b><i>fd</i><b>, fd_set *</b><i>set</i><b>);</b><br>       <b>int  FD_ISSET(int </b><i>fd</i><b>, fd_set *</b><i>set</i><b>);</b><br>       <b>void FD_SET(int </b><i>fd</i><b>, fd_set *</b><i>set</i><b>);</b><br>       <b>void FD_ZERO(fd_set *</b><i>set</i><b>);</b><br><br>       <b>#include &lt;sys/select.h&gt;</b><br><br>       <b>int pselect(int </b><i>nfds</i><b>, fd_set *</b><i>readfds</i><b>, fd_set *</b><i>writefds</i><b>,</b><br>                   <b>fd_set *</b><i>exceptfds</i><b>, const struct timespec *</b><i>timeout</i><b>,</b><br>                   <b>const sigset_t *</b><i>sigmask</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>pselect</b>(): _POSIX_C_SOURCE &gt;= 200112L || _XOPEN_SOURCE &gt;= 600<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>select</b>() and <b>pselect</b>() allow a program to monitor multiple file<br>       descriptors, waiting until one or more of the file descriptors become<br>       \"ready\" for some class of I/O operation (e.g., input possible).  A<br>       file descriptor is considered ready if it is possible to perform a<br>       corresponding I/O operation (e.g., read(2) without blocking, or a<br>       sufficiently small write(2)).<br><br>       The operation of <b>select</b>() and <b>pselect</b>() is identical, other than<br>       these three differences:<br><br>       (i)    <b>select</b>() uses a timeout that is a <i>struct timeval</i> (with seconds<br>              and microseconds), while <b>pselect</b>() uses a <i>struct timespec</i><br>              (with seconds and nanoseconds).<br><br>       (ii)   <b>select</b>() may update the <i>timeout</i> argument to indicate how much<br>              time was left.  <b>pselect</b>() does not change this argument.<br><br>       (iii)  <b>select</b>() has no <i>sigmask</i> argument, and behaves as <b>pselect</b>()<br>              called with NULL <i>sigmask</i>.<br><br>       Three independent sets of file descriptors are watched.  Those listed<br>       in <i>readfds</i> will be watched to see if characters become available for<br>       reading (more precisely, to see if a read will not block; in<br>       particular, a file descriptor is also ready on end-of-file), those in<br>       <i>writefds</i> will be watched to see if space is available for write<br>       (though a large write may still block), and those in <i>exceptfds</i> will<br>       be watched for exceptions.  On exit, the sets are modified in place<br>       to indicate which file descriptors actually changed status.  Each of<br>       the three file descriptor sets may be specified as NULL if no file<br>       descriptors are to be watched for the corresponding class of events.<br><br>       Four macros are provided to manipulate the sets.  <b>FD_ZERO</b>() clears a<br>       set.  <b>FD_SET</b>() and <b>FD_CLR</b>() respectively add and remove a given file<br>       descriptor from a set.  <b>FD_ISSET</b>() tests to see if a file descriptor<br>       is part of the set; this is useful after <b>select</b>() returns.<br><br>       <i>nfds</i> is the highest-numbered file descriptor in any of the three<br>       sets, plus 1.<br><br>       The <i>timeout</i> argument specifies the interval that <b>select</b>() should<br>       block waiting for a file descriptor to become ready.  The call will<br>       block until either:<br><br>       *  a file descriptor becomes ready;<br><br>       *  the call is interrupted by a signal handler; or<br><br>       *  the timeout expires.<br><br>       Note that the <i>timeout</i> interval will be rounded up to the system clock<br>       granularity, and kernel scheduling delays mean that the blocking<br>       interval may overrun by a small amount.  If both fields of the<br>       <i>timeval</i> structure are zero, then <b>select</b>() returns immediately.  (This<br>       is useful for polling.)  If <i>timeout</i> is NULL (no timeout), <b>select</b>()<br>       can block indefinitely.<br><br>       <i>sigmask</i> is a pointer to a signal mask (see sigprocmask(2)); if it is<br>       not NULL, then <b>pselect</b>() first replaces the current signal mask by<br>       the one pointed to by <i>sigmask</i>, then does the \"select\" function, and<br>       then restores the original signal mask.<br><br>       Other than the difference in the precision of the <i>timeout</i> argument,<br>       the following <b>pselect</b>() call:<br><br>           ready = pselect(nfds, &amp;readfds, &amp;writefds, &amp;exceptfds,<br>                           timeout, &amp;sigmask);<br><br>       is equivalent to <i>atomically</i> executing the following calls:<br><br>           sigset_t origmask;<br><br>           pthread_sigmask(SIG_SETMASK, &amp;sigmask, &amp;origmask);<br>           ready = select(nfds, &amp;readfds, &amp;writefds, &amp;exceptfds, timeout);<br>           pthread_sigmask(SIG_SETMASK, &amp;origmask, NULL);<br><br>       The reason that <b>pselect</b>() is needed is that if one wants to wait for<br>       either a signal or for a file descriptor to become ready, then an<br>       atomic test is needed to prevent race conditions.  (Suppose the<br>       signal handler sets a global flag and returns.  Then a test of this<br>       global flag followed by a call of <b>select</b>() could hang indefinitely if<br>       the signal arrived just after the test but just before the call.  By<br>       contrast, <b>pselect</b>() allows one to first block signals, handle the<br>       signals that have come in, then call <b>pselect</b>() with the desired<br>       <i>sigmask</i>, avoiding the race.)<br><br>   <b>The timeout</b><br>       The time structures involved are defined in <i>&lt;sys/time.h&gt;</i> and look<br>       like<br><br>           struct timeval {<br>               long    tv_sec;         /* seconds */<br>               long    tv_usec;        /* microseconds */<br>           };<br><br>       and<br><br>           struct timespec {<br>               long    tv_sec;         /* seconds */<br>               long    tv_nsec;        /* nanoseconds */<br>           };<br><br>       (However, see below on the POSIX.1 versions.)<br><br>       Some code calls <b>select</b>() with all three sets empty, <i>nfds</i> zero, and a<br>       non-NULL <i>timeout</i> as a fairly portable way to sleep with subsecond<br>       precision.<br><br>       On Linux, <b>select</b>() modifies <i>timeout</i> to reflect the amount of time not<br>       slept; most other implementations do not do this.  (POSIX.1 permits<br>       either behavior.)  This causes problems both when Linux code which<br>       reads <i>timeout</i> is ported to other operating systems, and when code is<br>       ported to Linux that reuses a <i>struct timeval</i> for multiple <b>select</b>()s<br>       in a loop without reinitializing it.  Consider <i>timeout</i> to be<br>       undefined after <b>select</b>() returns.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>select</b>() and <b>pselect</b>() return the number of file<br>       descriptors contained in the three returned descriptor sets (that is,<br>       the total number of bits that are set in <i>readfds</i>, <i>writefds</i>,<br>       <i>exceptfds</i>) which may be zero if the timeout expires before anything<br>       interesting happens.  On error, -1 is returned, and <i>errno</i> is set to<br>       indicate the error; the file descriptor sets are unmodified, and<br>       <i>timeout</i> becomes undefined.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EBADF  </b>An invalid file descriptor was given in one of the sets.<br>              (Perhaps a file descriptor that was already closed, or one on<br>              which an error has occurred.)<br><br>       <b>EINTR  </b>A signal was caught; see signal(7).<br><br>       <b>EINVAL </b><i>nfds</i> is negative or exceeds the <b>RLIMIT_NOFILE </b>resource limit<br>              (see getrlimit(2)).<br><br>       <b>EINVAL </b>the value contained within <i>timeout</i> is invalid.<br><br>       <b>ENOMEM </b>unable to allocate memory for internal tables.<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>pselect</b>() was added to Linux in kernel 2.6.16.  Prior to this,<br>       <b>pselect</b>() was emulated in glibc (but see BUGS).<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>select</b>() conforms to POSIX.1-2001, POSIX.1-2008, and 4.4BSD (<b>select</b>()<br>       first appeared in 4.2BSD).  Generally portable to/from non-BSD<br>       systems supporting clones of the BSD socket layer (including System V<br>       variants).  However, note that the System V variant typically sets<br>       the timeout variable before exit, but the BSD variant does not.<br><br>       <b>pselect</b>() is defined in POSIX.1g, and in POSIX.1-2001 and<br>       POSIX.1-2008.<br></pre><br><h2>NOTES  </h2><pre><br>       An <i>fd_set</i> is a fixed size buffer.  Executing <b>FD_CLR</b>() or <b>FD_SET</b>()<br>       with a value of <i>fd</i> that is negative or is equal to or larger than<br>       <b>FD_SETSIZE </b>will result in undefined behavior.  Moreover, POSIX<br>       requires <i>fd</i> to be a valid file descriptor.<br><br>       Concerning the types involved, the classical situation is that the<br>       two fields of a <i>timeval</i> structure are typed as <i>long</i> (as shown above),<br>       and the structure is defined in <i>&lt;sys/time.h&gt;</i>.  The POSIX.1 situation<br>       is<br><br>           struct timeval {<br>               time_t         tv_sec;     /* seconds */<br>               suseconds_t    tv_usec;    /* microseconds */<br>           };<br><br>       where the structure is defined in <i>&lt;sys/select.h&gt;</i> and the data types<br>       <i>time_t</i> and <i>suseconds_t</i> are defined in <i>&lt;sys/types.h&gt;</i>.<br><br>       Concerning prototypes, the classical situation is that one should<br>       include <i>&lt;time.h&gt;</i> for <b>select</b>().  The POSIX.1 situation is that one<br>       should include <i>&lt;sys/select.h&gt;</i> for <b>select</b>() and <b>pselect</b>().<br><br>       Under glibc 2.0, <i>&lt;sys/select.h&gt;</i> gives the wrong prototype for<br>       <b>pselect</b>().  Under glibc 2.1 to 2.2.1, it gives <b>pselect</b>() when<br>       <b>_GNU_SOURCE </b>is defined.  Since glibc 2.2.2, the requirements are as<br>       shown in the SYNOPSIS.<br><br>   <b>Multithreaded applications</b><br>       If a file descriptor being monitored by <b>select</b>() is closed in another<br>       thread, the result is unspecified.  On some UNIX systems, <b>select</b>()<br>       unblocks and returns, with an indication that the file descriptor is<br>       ready (a subsequent I/O operation will likely fail with an error,<br>       unless another the file descriptor reopened between the time <b>select</b>()<br>       returned and the I/O operations was performed).  On Linux (and some<br>       other systems), closing the file descriptor in another thread has no<br>       effect on <b>select</b>().  In summary, any application that relies on a<br>       particular behavior in this scenario must be considered buggy.<br><br>   <b>C library/kernel differences</b><br>       The <b>pselect</b>() interface described in this page is implemented by<br>       glibc.  The underlying Linux system call is named <b>pselect6</b>().  This<br>       system call has somewhat different behavior from the glibc wrapper<br>       function.<br><br>       The Linux <b>pselect6</b>() system call modifies its <i>timeout</i> argument.<br>       However, the glibc wrapper function hides this behavior by using a<br>       local variable for the timeout argument that is passed to the system<br>       call.  Thus, the glibc <b>pselect</b>() function does not modify its <i>timeout</i><br>       argument; this is the behavior required by POSIX.1-2001.<br><br>       The final argument of the <b>pselect6</b>() system call is not a <i>sigset_t *</i><br>       pointer, but is instead a structure of the form:<br><br>           struct {<br>               const sigset_t *ss;     /* Pointer to signal set */<br>               size_t          ss_len; /* Size (in bytes) of object pointed<br>                                          to by 'ss' */<br>           };<br><br>       This allows the system call to obtain both a pointer to the signal<br>       set and its size, while allowing for the fact that most architectures<br>       support a maximum of 6 arguments to a system call.<br></pre><br><h2>BUGS  </h2><pre><br>       Glibc 2.0 provided a version of <b>pselect</b>() that did not take a <i>sigmask</i><br>       argument.<br><br>       Starting with version 2.1, glibc provided an emulation of <b>pselect</b>()<br>       that was implemented using sigprocmask(2) and <b>select</b>().  This<br>       implementation remained vulnerable to the very race condition that<br>       <b>pselect</b>() was designed to prevent.  Modern versions of glibc use the<br>       (race-free) <b>pselect</b>() system call on kernels where it is provided.<br><br>       On systems that lack <b>pselect</b>(), reliable (and more portable) signal<br>       trapping can be achieved using the self-pipe trick.  In this<br>       technique, a signal handler writes a byte to a pipe whose other end<br>       is monitored by <b>select</b>() in the main program.  (To avoid possibly<br>       blocking when writing to a pipe that may be full or reading from a<br>       pipe that may be empty, nonblocking I/O is used when reading from and<br>       writing to the pipe.)<br><br>       Under Linux, <b>select</b>() may report a socket file descriptor as \"ready<br>       for reading\", while nevertheless a subsequent read blocks.  This<br>       could for example happen when data has arrived but upon examination<br>       has wrong checksum and is discarded.  There may be other<br>       circumstances in which a file descriptor is spuriously reported as<br>       ready.  Thus it may be safer to use <b>O_NONBLOCK </b>on sockets that should<br>       not block.<br><br>       On Linux, <b>select</b>() also modifies <i>timeout</i> if the call is interrupted<br>       by a signal handler (i.e., the <b>EINTR </b>error return).  This is not<br>       permitted by POSIX.1.  The Linux <b>pselect</b>() system call has the same<br>       behavior, but the glibc wrapper hides this behavior by internally<br>       copying the <i>timeout</i> to a local variable and passing that variable to<br>       the system call.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       #include &lt;stdio.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;sys/time.h&gt;<br>       #include &lt;sys/types.h&gt;<br>       #include &lt;unistd.h&gt;<br><br>       int<br>       main(void)<br>       {<br>           fd_set rfds;<br>           struct timeval tv;<br>           int retval;<br><br>           /* Watch stdin (fd 0) to see when it has input. */<br>           FD_ZERO(&amp;rfds);<br>           FD_SET(0, &amp;rfds);<br><br>           /* Wait up to five seconds. */<br>           tv.tv_sec = 5;<br>           tv.tv_usec = 0;<br><br>           retval = select(1, &amp;rfds, NULL, NULL, &amp;tv);<br>           /* Don't rely on the value of tv now! */<br><br>           if (retval == -1)<br>               perror(\"select()\");<br>           else if (retval)<br>               printf(\"Data is available now.\\n\");<br>               /* FD_ISSET(0, &amp;rfds) will be true. */<br>           else<br>               printf(\"No data within five seconds.\\n\");<br><br>           exit(EXIT_SUCCESS);<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       accept(2), connect(2), poll(2), read(2), recv(2), restart_syscall(2),<br>       send(2), sigprocmask(2), write(2), epoll(7), time(7)<br><br>       For a tutorial with discussion and examples, see select_tut(2).<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                        SELECT(2)</span><br></pre><br>"}