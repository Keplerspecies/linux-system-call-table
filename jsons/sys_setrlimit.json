{"Man page": "<pre><br><span class=\"headline\">GETRLIMIT(2)              Linux Programmer's Manual             GETRLIMIT(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       getrlimit, setrlimit, prlimit - get/set resource limits<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/time.h&gt;</b><br>       <b>#include &lt;sys/resource.h&gt;</b><br><br>       <b>int getrlimit(int </b><i>resource</i><b>, struct rlimit *</b><i>rlim</i><b>);</b><br>       <b>int setrlimit(int </b><i>resource</i><b>, const struct rlimit *</b><i>rlim</i><b>);</b><br><br>       <b>int prlimit(pid_t </b><i>pid</i><b>, int </b><i>resource</i><b>, const struct rlimit *</b><i>new_limit</i><b>,</b><br>                   <b>struct rlimit *</b><i>old_limit</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>prlimit</b>(): _GNU_SOURCE<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>getrlimit</b>() and <b>setrlimit</b>() system calls get and set resource<br>       limits respectively.  Each resource has an associated soft and hard<br>       limit, as defined by the <i>rlimit</i> structure:<br><br>           struct rlimit {<br>               rlim_t rlim_cur;  /* Soft limit */<br>               rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */<br>           };<br><br>       The soft limit is the value that the kernel enforces for the<br>       corresponding resource.  The hard limit acts as a ceiling for the<br>       soft limit: an unprivileged process may set only its soft limit to a<br>       value in the range from 0 up to the hard limit, and (irreversibly)<br>       lower its hard limit.  A privileged process (under Linux: one with<br>       the <b>CAP_SYS_RESOURCE </b>capability) may make arbitrary changes to either<br>       limit value.<br><br>       The value <b>RLIM_INFINITY </b>denotes no limit on a resource (both in the<br>       structure returned by <b>getrlimit</b>() and in the structure passed to<br>       <b>setrlimit</b>()).<br><br>       The <i>resource</i> argument must be one of:<br><br>       <b>RLIMIT_AS</b><br>              The maximum size of the process's virtual memory (address<br>              space) in bytes.  This limit affects calls to brk(2), mmap(2),<br>              and mremap(2), which fail with the error <b>ENOMEM </b>upon exceeding<br>              this limit.  Also automatic stack expansion will fail (and<br>              generate a <b>SIGSEGV </b>that kills the process if no alternate<br>              stack has been made available via sigaltstack(2)).  Since the<br>              value is a <i>long</i>, on machines with a 32-bit <i>long</i> either this<br>              limit is at most 2 GiB, or this resource is unlimited.<br><br>       <b>RLIMIT_CORE</b><br>              Maximum size of a <i>core</i> file (see core(5)).  When 0 no core<br>              dump files are created.  When nonzero, larger dumps are<br>              truncated to this size.<br><br>       <b>RLIMIT_CPU</b><br>              CPU time limit in seconds.  When the process reaches the soft<br>              limit, it is sent a <b>SIGXCPU </b>signal.  The default action for<br>              this signal is to terminate the process.  However, the signal<br>              can be caught, and the handler can return control to the main<br>              program.  If the process continues to consume CPU time, it<br>              will be sent <b>SIGXCPU </b>once per second until the hard limit is<br>              reached, at which time it is sent <b>SIGKILL</b>.  (This latter point<br>              describes Linux behavior.  Implementations vary in how they<br>              treat processes which continue to consume CPU time after<br>              reaching the soft limit.  Portable applications that need to<br>              catch this signal should perform an orderly termination upon<br>              first receipt of <b>SIGXCPU</b>.)<br><br>       <b>RLIMIT_DATA</b><br>              The maximum size of the process's data segment (initialized<br>              data, uninitialized data, and heap).  This limit affects calls<br>              to brk(2) and sbrk(2), which fail with the error <b>ENOMEM </b>upon<br>              encountering the soft limit of this resource.<br><br>       <b>RLIMIT_FSIZE</b><br>              The maximum size of files that the process may create.<br>              Attempts to extend a file beyond this limit result in delivery<br>              of a <b>SIGXFSZ </b>signal.  By default, this signal terminates a<br>              process, but a process can catch this signal instead, in which<br>              case the relevant system call (e.g., write(2), truncate(2))<br>              fails with the error <b>EFBIG</b>.<br><br>       <b>RLIMIT_LOCKS </b>(Early Linux 2.4 only)<br>              A limit on the combined number of flock(2) locks and fcntl(2)<br>              leases that this process may establish.<br><br>       <b>RLIMIT_MEMLOCK</b><br>              The maximum number of bytes of memory that may be locked into<br>              RAM.  In effect this limit is rounded down to the nearest<br>              multiple of the system page size.  This limit affects mlock(2)<br>              and mlockall(2) and the mmap(2) <b>MAP_LOCKED </b>operation.  Since<br>              Linux 2.6.9 it also affects the shmctl(2) <b>SHM_LOCK </b>operation,<br>              where it sets a maximum on the total bytes in shared memory<br>              segments (see shmget(2)) that may be locked by the real user<br>              ID of the calling process.  The shmctl(2) <b>SHM_LOCK </b>locks are<br>              accounted for separately from the per-process memory locks<br>              established by mlock(2), mlockall(2), and mmap(2) <b>MAP_LOCKED</b>;<br>              a process can lock bytes up to this limit in each of these two<br>              categories.  In Linux kernels before 2.6.9, this limit<br>              controlled the amount of memory that could be locked by a<br>              privileged process.  Since Linux 2.6.9, no limits are placed<br>              on the amount of memory that a privileged process may lock,<br>              and this limit instead governs the amount of memory that an<br>              unprivileged process may lock.<br><br>       <b>RLIMIT_MSGQUEUE </b>(since Linux 2.6.8)<br>              Specifies the limit on the number of bytes that can be<br>              allocated for POSIX message queues for the real user ID of the<br>              calling process.  This limit is enforced for mq_open(3).  Each<br>              message queue that the user creates counts (until it is<br>              removed) against this limit according to the formula:<br><br>                  Since Linux 3.5:<br>                      bytes = attr.mq_maxmsg * sizeof(struct msg_msg) +<br>                              min(attr.mq_maxmsg, MQ_PRIO_MAX) *<br>                                    sizeof(struct posix_msg_tree_node)+<br>                                              /* For overhead */<br>                              attr.mq_maxmsg * attr.mq_msgsize;<br>                                              /* For message data */<br><br>                  Linux 3.4 and earlier:<br>                      bytes = attr.mq_maxmsg * sizeof(struct msg_msg *) +<br>                                              /* For overhead */<br>                              attr.mq_maxmsg * attr.mq_msgsize;<br>                                              /* For message data */<br><br>              where <i>attr</i> is the <i>mq_attr</i> structure specified as the fourth<br>              argument to mq_open(3), and the <i>msg_msg</i> and<br>              <i>posix_msg_tree_node</i> structures are kernel-internal structures.<br><br>              The \"overhead\" addend in the formula accounts for overhead<br>              bytes required by the implementation and ensures that the user<br>              cannot create an unlimited number of zero-length messages<br>              (such messages nevertheless each consume some system memory<br>              for bookkeeping overhead).<br><br>       <b>RLIMIT_NICE </b>(since Linux 2.6.12, but see BUGS below)<br>              Specifies a ceiling to which the process's nice value can be<br>              raised using setpriority(2) or nice(2).  The actual ceiling<br>              for the nice value is calculated as <i>20 - rlim_cur</i>.  (This<br>              strangeness occurs because negative numbers cannot be<br>              specified as resource limit values, since they typically have<br>              special meanings.  For example, <b>RLIM_INFINITY </b>typically is the<br>              same as -1.)<br><br>       <b>RLIMIT_NOFILE</b><br>              Specifies a value one greater than the maximum file descriptor<br>              number that can be opened by this process.  Attempts (open(2),<br>              pipe(2), dup(2), etc.)  to exceed this limit yield the error<br>              <b>EMFILE</b>.  (Historically, this limit was named <b>RLIMIT_OFILE </b>on<br>              BSD.)<br><br>       <b>RLIMIT_NPROC</b><br>              The maximum number of processes (or, more precisely on Linux,<br>              threads) that can be created for the real user ID of the<br>              calling process.  Upon encountering this limit, fork(2) fails<br>              with the error <b>EAGAIN</b>.  This limit is not enforced for<br>              processes that have either the <b>CAP_SYS_ADMIN </b>or the<br>              <b>CAP_SYS_RESOURCE </b>capability.<br><br>       <b>RLIMIT_RSS</b><br>              Specifies the limit (in pages) of the process's resident set<br>              (the number of virtual pages resident in RAM).  This limit has<br>              effect only in Linux 2.4.x, x &lt; 30, and there affects only<br>              calls to madvise(2) specifying <b>MADV_WILLNEED</b>.<br><br>       <b>RLIMIT_RTPRIO </b>(since Linux 2.6.12, but see BUGS)<br>              Specifies a ceiling on the real-time priority that may be set<br>              for this process using sched_setscheduler(2) and<br>              sched_setparam(2).<br><br>       <b>RLIMIT_RTTIME </b>(since Linux 2.6.25)<br>              Specifies a limit (in microseconds) on the amount of CPU time<br>              that a process scheduled under a real-time scheduling policy<br>              may consume without making a blocking system call.  For the<br>              purpose of this limit, each time a process makes a blocking<br>              system call, the count of its consumed CPU time is reset to<br>              zero.  The CPU time count is not reset if the process<br>              continues trying to use the CPU but is preempted, its time<br>              slice expires, or it calls sched_yield(2).<br><br>              Upon reaching the soft limit, the process is sent a <b>SIGXCPU</b><br>              signal.  If the process catches or ignores this signal and<br>              continues consuming CPU time, then <b>SIGXCPU </b>will be generated<br>              once each second until the hard limit is reached, at which<br>              point the process is sent a <b>SIGKILL </b>signal.<br><br>              The intended use of this limit is to stop a runaway real-time<br>              process from locking up the system.<br><br>       <b>RLIMIT_SIGPENDING </b>(since Linux 2.6.8)<br>              Specifies the limit on the number of signals that may be<br>              queued for the real user ID of the calling process.  Both<br>              standard and real-time signals are counted for the purpose of<br>              checking this limit.  However, the limit is enforced only for<br>              sigqueue(3); it is always possible to use kill(2) to queue one<br>              instance of any of the signals that are not already queued to<br>              the process.<br><br>       <b>RLIMIT_STACK</b><br>              The maximum size of the process stack, in bytes.  Upon<br>              reaching this limit, a <b>SIGSEGV </b>signal is generated.  To handle<br>              this signal, a process must employ an alternate signal stack<br>              (sigaltstack(2)).<br><br>              Since Linux 2.6.23, this limit also determines the amount of<br>              space used for the process's command-line arguments and<br>              environment variables; for details, see execve(2).<br><br>   <b>prlimit()</b><br>       The Linux-specific <b>prlimit</b>() system call combines and extends the<br>       functionality of <b>setrlimit</b>() and <b>getrlimit</b>().  It can be used to both<br>       set and get the resource limits of an arbitrary process.<br><br>       The <i>resource</i> argument has the same meaning as for <b>setrlimit</b>() and<br>       <b>getrlimit</b>().<br><br>       If the <i>new_limit</i> argument is a not NULL, then the <i>rlimit</i> structure to<br>       which it points is used to set new values for the soft and hard<br>       limits for <i>resource</i>.  If the <i>old_limit</i> argument is a not NULL, then a<br>       successful call to <b>prlimit</b>() places the previous soft and hard limits<br>       for <i>resource</i> in the <i>rlimit</i> structure pointed to by <i>old_limit</i>.<br><br>       The <i>pid</i> argument specifies the ID of the process on which the call is<br>       to operate.  If <i>pid</i> is 0, then the call applies to the calling<br>       process.  To set or get the resources of a process other than itself,<br>       the caller must have the <b>CAP_SYS_RESOURCE </b>capability, or the real,<br>       effective, and saved set user IDs of the target process must match<br>       the real user ID of the caller <i>and</i> the real, effective, and saved set<br>       group IDs of the target process must match the real group ID of the<br>       caller.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, these system calls return 0.  On error, -1 is returned,<br>       and <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EFAULT </b>A pointer argument points to a location outside the accessible<br>              address space.<br><br>       <b>EINVAL </b>The value specified in <i>resource</i> is not valid; or, for<br>              <b>setrlimit</b>() or <b>prlimit</b>(): <i>rlim-&gt;rlim_cur</i> was greater than<br>              <i>rlim-&gt;rlim_max</i>.<br><br>       <b>EPERM  </b>An unprivileged process tried to raise the hard limit; the<br>              <b>CAP_SYS_RESOURCE </b>capability is required to do this.<br><br>       <b>EPERM  </b>The caller tried to increase the hard <b>RLIMIT_NOFILE </b>limit<br>              above the maximum defined by <i>/proc/sys/fs/nr_open</i> (see<br>              proc(5))<br><br>       <b>EPERM  </b>(<b>prlimit</b>()) The calling process did not have permission to set<br>              limits for the process specified by <i>pid</i>.<br><br>       <b>ESRCH  </b>Could not find a process with the ID specified in <i>pid</i>.<br></pre><br><h2>VERSIONS  </h2><pre><br>       The <b>prlimit</b>() system call is available since Linux 2.6.36.  Library<br>       support is available since glibc 2.13.<br></pre><br><h2>ATTRIBUTES  </h2><pre><br>       For an explanation of the terms used in this section, see<br>       attributes(7).<br><br>       &#9484;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9516;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9516;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9488;<br>       &#9474;<b>Interface                           </b>&#9474; <b>Attribute     </b>&#9474; <b>Value   </b>&#9474;<br>       &#9500;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9532;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9508;<br>       &#9474;<b>getrlimit</b>(), <b>setrlimit</b>(), <b>prlimit</b>() &#9474; Thread safety &#9474; MT-Safe &#9474;<br>       &#9492;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9524;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9524;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9472;&#9496;<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>getrlimit</b>(), <b>setrlimit</b>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.<br>       <b>prlimit</b>(): Linux-specific.<br><br>       <b>RLIMIT_MEMLOCK </b>and <b>RLIMIT_NPROC </b>derive from BSD and are not specified<br>       in POSIX.1; they are present on the BSDs and Linux, but on few other<br>       implementations.  <b>RLIMIT_RSS </b>derives from BSD and is not specified in<br>       POSIX.1; it is nevertheless present on most implementations.<br>       <b>RLIMIT_MSGQUEUE</b>, <b>RLIMIT_NICE</b>, <b>RLIMIT_RTPRIO</b>, <b>RLIMIT_RTTIME</b>, and<br>       <b>RLIMIT_SIGPENDING </b>are Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       A child process created via fork(2) inherits its parent's resource<br>       limits.  Resource limits are preserved across execve(2).<br><br>       Lowering the soft limit for a resource below the process's current<br>       consumption of that resource will succeed (but will prevent the<br>       process from further increasing its consumption of the resource).<br><br>       One can set the resource limits of the shell using the built-in<br>       <i>ulimit</i> command (<i>limit</i> in <b>csh</b>(1)).  The shell's resource limits are<br>       inherited by the processes that it creates to execute commands.<br><br>       Since Linux 2.6.24, the resource limits of any process can be<br>       inspected via <i>/proc/[pid]/limits</i>; see proc(5).<br><br>       Ancient systems provided a <b>vlimit</b>() function with a similar purpose<br>       to <b>setrlimit</b>().  For backward compatibility, glibc also provides<br>       <b>vlimit</b>().  All new applications should be written using <b>setrlimit</b>().<br><br>   <b>C library/ kernel ABI differences</b><br>       Since version 2.13, the glibc <b>getrlimit</b>() and <b>setrlimit</b>() wrapper<br>       functions no longer invoke the corresponding system calls, but<br>       instead employ <b>prlimit</b>(), for the reasons described in BUGS.<br><br>       The name of the glibc wrapper function is <b>prlimit</b>(); the underlying<br>       system call is call prlimit64 ().<br></pre><br><h2>BUGS  </h2><pre><br>       In older Linux kernels, the <b>SIGXCPU </b>and <b>SIGKILL </b>signals delivered<br>       when a process encountered the soft and hard <b>RLIMIT_CPU </b>limits were<br>       delivered one (CPU) second later than they should have been.  This<br>       was fixed in kernel 2.6.8.<br><br>       In 2.6.x kernels before 2.6.17, a <b>RLIMIT_CPU </b>limit of 0 is wrongly<br>       treated as \"no limit\" (like <b>RLIM_INFINITY</b>).  Since Linux 2.6.17,<br>       setting a limit of 0 does have an effect, but is actually treated as<br>       a limit of 1 second.<br><br>       A kernel bug means that <b>RLIMIT_RTPRIO </b>does not work in kernel 2.6.12;<br>       the problem is fixed in kernel 2.6.13.<br><br>       In kernel 2.6.12, there was an off-by-one mismatch between the<br>       priority ranges returned by getpriority(2) and <b>RLIMIT_NICE</b>.  This had<br>       the effect that the actual ceiling for the nice value was calculated<br>       as <i>19 - rlim_cur</i>.  This was fixed in kernel 2.6.13.<br><br>       Since Linux 2.6.12, if a process reaches its soft <b>RLIMIT_CPU </b>limit<br>       and has a handler installed for <b>SIGXCPU</b>, then, in addition to<br>       invoking the signal handler, the kernel increases the soft limit by<br>       one second.  This behavior repeats if the process continues to<br>       consume CPU time, until the hard limit is reached, at which point the<br>       process is killed.  Other implementations do not change the<br>       <b>RLIMIT_CPU </b>soft limit in this manner, and the Linux behavior is<br>       probably not standards conformant; portable applications should avoid<br>       relying on this Linux-specific behavior.  The Linux-specific<br>       <b>RLIMIT_RTTIME </b>limit exhibits the same behavior when the soft limit is<br>       encountered.<br><br>       Kernels before 2.4.22 did not diagnose the error <b>EINVAL </b>for<br>       <b>setrlimit</b>() when <i>rlim-&gt;rlim_cur</i> was greater than <i>rlim-&gt;rlim_max</i>.<br><br>   <b>Representation of \"large\" resource limit values on 32-bit platforms</b><br>       The glibc <b>getrlimit</b>() and <b>setrlimit</b>() wrapper functions use a 64-bit<br>       <i>rlim_t</i> data type, even on 32-bit platforms.  However, the <i>rlim_t</i> data<br>       type used in the <b>getrlimit</b>() and <b>setrlimit</b>() system calls is a<br>       (32-bit) <i>unsigned long</i>.  Furthermore, in Linux versions before<br>       2.6.36, the kernel represents resource limits on 32-bit platforms as<br>       <i>unsigned long</i>.  However, a 32-bit data type is not wide enough.  The<br>       most pertinent limit here is <b>RLIMIT_FSIZE</b>, which specifies the<br>       maximum size to which a file can grow: to be useful, this limit must<br>       be represented using a type that is as wide as the type used to<br>       represent file offsets&#8212;that is, as wide as a 64-bit <b>off_t </b>(assuming a<br>       program compiled with <i>_FILE_OFFSET_BITS=64</i>).<br><br>       To work around this kernel limitation, if a program tried to set a<br>       resource limit to a value larger than can be represented in a 32-bit<br>       <i>unsigned long</i>, then the glibc <b>setrlimit</b>() wrapper function silently<br>       converted the limit value to <b>RLIM_INFINITY</b>.  In other words, the<br>       requested resource limit setting was silently ignored.<br><br>       This problem was addressed in Linux 2.6.36 with two principal<br>       changes:<br><br>       *  the addition of a new kernel representation of resource limits<br>          that uses 64 bits, even on 32-bit platforms;<br><br>       *  the addition of the <b>prlimit</b>() system call, which employs 64-bit<br>          values for its resource limit arguments.<br><br>       Since version 2.13, glibc works around the limitations of the<br>       <b>getrlimit</b>() and <b>setrlimit</b>() system calls by implementing <b>setrlimit</b>()<br>       and <b>getrlimit</b>() as wrapper functions that call <b>prlimit</b>().<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The program below demonstrates the use of <b>prlimit</b>().<br><br>       #define _GNU_SOURCE<br>       #define _FILE_OFFSET_BITS 64<br>       #include &lt;stdio.h&gt;<br>       #include &lt;time.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;unistd.h&gt;<br>       #include &lt;sys/resource.h&gt;<br><br>       #define errExit(msg)                                do { perror(msg); exit(EXIT_FAILURE); \\<br>                               } while (0)<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           struct rlimit old, new;<br>           struct rlimit *newp;<br>           pid_t pid;<br><br>           if (!(argc == 2 || argc == 4)) {<br>               fprintf(stderr, \"Usage: %s &lt;pid&gt; [&lt;new-soft-limit&gt; \"<br>                       \"&lt;new-hard-limit&gt;]\\n\", argv[0]);<br>               exit(EXIT_FAILURE);<br>           }<br><br>           pid = atoi(argv[1]);        /* PID of target process */<br><br>           newp = NULL;<br>           if (argc == 4) {<br>               new.rlim_cur = atoi(argv[2]);<br>               new.rlim_max = atoi(argv[3]);<br>               newp = &amp;new;<br>           }<br><br>           /* Set CPU time limit of target process; retrieve and display<br>              previous limit */<br><br>           if (prlimit(pid, RLIMIT_CPU, newp, &amp;old) == -1)<br>               errExit(\"prlimit-1\");<br>           printf(\"Previous limits: soft=%lld; hard=%lld\\n\",<br>                   (long long) old.rlim_cur, (long long) old.rlim_max);<br><br>           /* Retrieve and display new CPU time limit */<br><br>           if (prlimit(pid, RLIMIT_CPU, NULL, &amp;old) == -1)<br>               errExit(\"prlimit-2\");<br>           printf(\"New limits: soft=%lld; hard=%lld\\n\",<br>                   (long long) old.rlim_cur, (long long) old.rlim_max);<br><br>           exit(EXIT_FAILURE);<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       prlimit(1), dup(2), fcntl(2), fork(2), getrusage(2), mlock(2),<br>       mmap(2), open(2), quotactl(2), sbrk(2), shmctl(2), malloc(3),<br>       sigqueue(3), ulimit(3), core(5), capabilities(7), signal(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                     GETRLIMIT(2)</span><br></pre><br>"}