{"Man page": "<pre><br><span class=\"headline\">EXECVE(2)                 Linux Programmer's Manual                EXECVE(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       execve - execute program<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>int execve(const char *</b><i>filename</i><b>, char *const </b><i>argv</i><b>[],</b><br>                  <b>char *const </b><i>envp</i><b>[]);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>execve</b>() executes the program pointed to by <i>filename</i>.  <i>filename</i> must<br>       be either a binary executable, or a script starting with a line of<br>       the form:<br><br>           <b>#! </b><i>interpreter</i> [optional-arg]<br><br>       For details of the latter case, see \"Interpreter scripts\" below.<br><br>       <i>argv</i> is an array of argument strings passed to the new program.  By<br>       convention, the first of these strings should contain the filename<br>       associated with the file being executed.  <i>envp</i> is an array of<br>       strings, conventionally of the form <b>key=value</b>, which are passed as<br>       environment to the new program.  Both <i>argv</i> and <i>envp</i> must be<br>       terminated by a null pointer.  The argument vector and environment<br>       can be accessed by the called program's main function, when it is<br>       defined as:<br><br>           int main(int argc, char *argv[], char *envp[])<br><br>       <b>execve</b>() does not return on success, and the text, data, bss, and<br>       stack of the calling process are overwritten by that of the program<br>       loaded.<br><br>       If the current program is being ptraced, a <b>SIGTRAP </b>is sent to it<br>       after a successful <b>execve</b>().<br><br>       If the set-user-ID bit is set on the program file pointed to by<br>       <i>filename</i>, and the underlying filesystem is not mounted <i>nosuid</i> (the<br>       <b>MS_NOSUID </b>flag for mount(2)), and the calling process is not being<br>       ptraced, then the effective user ID of the calling process is changed<br>       to that of the owner of the program file.  Similarly, when the set-<br>       group-ID bit of the program file is set the effective group ID of the<br>       calling process is set to the group of the program file.<br><br>       The effective user ID of the process is copied to the saved set-user-<br>       ID; similarly, the effective group ID is copied to the saved set-<br>       group-ID.  This copying takes place after any effective ID changes<br>       that occur because of the set-user-ID and set-group-ID mode bits.<br><br>       If the executable is an a.out dynamically linked binary executable<br>       containing shared-library stubs, the Linux dynamic linker ld.so(8) is<br>       called at the start of execution to bring needed shared objects into<br>       memory and link the executable with them.<br><br>       If the executable is a dynamically linked ELF executable, the<br>       interpreter named in the PT_INTERP segment is used to load the needed<br>       shared objects.  This interpreter is typically <i>/lib/ld-linux.so.2</i> for<br>       binaries linked with glibc.<br><br>       All process attributes are preserved during an <b>execve</b>(), except the<br>       following:<br><br>       *  The dispositions of any signals that are being caught are reset to<br>          the default (signal(7)).<br><br>       *  Any alternate signal stack is not preserved (sigaltstack(2)).<br><br>       *  Memory mappings are not preserved (mmap(2)).<br><br>       *  Attached System V shared memory segments are detached (shmat(2)).<br><br>       *  POSIX shared memory regions are unmapped (shm_open(3)).<br><br>       *  Open POSIX message queue descriptors are closed (mq_overview(7)).<br><br>       *  Any open POSIX named semaphores are closed (sem_overview(7)).<br><br>       *  POSIX timers are not preserved (timer_create(2)).<br><br>       *  Any open directory streams are closed (opendir(3)).<br><br>       *  Memory locks are not preserved (mlock(2), mlockall(2)).<br><br>       *  Exit handlers are not preserved (atexit(3), on_exit(3)).<br><br>       *  The floating-point environment is reset to the default (see<br>          fenv(3)).<br><br>       The process attributes in the preceding list are all specified in<br>       POSIX.1.  The following Linux-specific process attributes are also<br>       not preserved during an <b>execve</b>():<br><br>       *  The prctl(2) <b>PR_SET_DUMPABLE </b>flag is set, unless a set-user-ID or<br>          set-group ID program is being executed, in which case it is<br>          cleared.<br><br>       *  The prctl(2) <b>PR_SET_KEEPCAPS </b>flag is cleared.<br><br>       *  (Since Linux 2.4.36 / 2.6.23) If a set-user-ID or set-group-ID<br>          program is being executed, then the parent death signal set by<br>          prctl(2) <b>PR_SET_PDEATHSIG </b>flag is cleared.<br><br>       *  The process name, as set by prctl(2) <b>PR_SET_NAME </b>(and displayed by<br>          <i>ps -o comm</i>), is reset to the name of the new executable file.<br><br>       *  The <b>SECBIT_KEEP_CAPS </b><i>securebits</i> flag is cleared.  See<br>          capabilities(7).<br><br>       *  The termination signal is reset to <b>SIGCHLD </b>(see clone(2)).<br><br>       *  The file descriptor table is unshared, undoing the effect of the<br>          <b>CLONE_FILES </b>flag of clone(2).<br><br>       Note the following further points:<br><br>       *  All threads other than the calling thread are destroyed during an<br>          <b>execve</b>().  Mutexes, condition variables, and other pthreads<br>          objects are not preserved.<br><br>       *  The equivalent of <i>setlocale(LC_ALL, \"C\")</i> is executed at program<br>          start-up.<br><br>       *  POSIX.1 specifies that the dispositions of any signals that are<br>          ignored or set to the default are left unchanged.  POSIX.1<br>          specifies one exception: if <b>SIGCHLD </b>is being ignored, then an<br>          implementation may leave the disposition unchanged or reset it to<br>          the default; Linux does the former.<br><br>       *  Any outstanding asynchronous I/O operations are canceled<br>          (aio_read(3), aio_write(3)).<br><br>       *  For the handling of capabilities during <b>execve</b>(), see<br>          capabilities(7).<br><br>       *  By default, file descriptors remain open across an <b>execve</b>().  File<br>          descriptors that are marked close-on-exec are closed; see the<br>          description of <b>FD_CLOEXEC </b>in fcntl(2).  (If a file descriptor is<br>          closed, this will cause the release of all record locks obtained<br>          on the underlying file by this process.  See fcntl(2) for<br>          details.)  POSIX.1 says that if file descriptors 0, 1, and 2 would<br>          otherwise be closed after a successful <b>execve</b>(), and the process<br>          would gain privilege because the set-user_ID or set-group_ID mode<br>          bit was set on the executed file, then the system may open an<br>          unspecified file for each of these file descriptors.  As a general<br>          principle, no portable program, whether privileged or not, can<br>          assume that these three file descriptors will remain closed across<br>          an <b>execve</b>().<br><br>   <b>Interpreter scripts</b><br>       An interpreter script is a text file that has execute permission<br>       enabled and whose first line is of the form:<br><br>           <b>#! </b><i>interpreter</i> [optional-arg]<br><br>       The <i>interpreter</i> must be a valid pathname for an executable which is<br>       not itself a script.  If the <i>filename</i> argument of <b>execve</b>() specifies<br>       an interpreter script, then <i>interpreter</i> will be invoked with the<br>       following arguments:<br><br>           <i>interpreter</i> [optional-arg] <i>filename</i> arg...<br><br>       where <i>arg...</i>  is the series of words pointed to by the <i>argv</i> argument<br>       of <b>execve</b>(), starting at <i>argv</i>[1].<br><br>       For portable use, <i>optional-arg</i> should either be absent, or be<br>       specified as a single word (i.e., it should not contain white space);<br>       see NOTES below.<br><br>   <b>Limits on size of arguments and environment</b><br>       Most UNIX implementations impose some limit on the total size of the<br>       command-line argument (<i>argv</i>) and environment (<i>envp</i>) strings that may<br>       be passed to a new program.  POSIX.1 allows an implementation to<br>       advertise this limit using the <b>ARG_MAX </b>constant (either defined in<br>       <i>&lt;limits.h&gt;</i> or available at run time using the call<br>       <i>sysconf(_SC_ARG_MAX)</i>).<br><br>       On Linux prior to kernel 2.6.23, the memory used to store the<br>       environment and argument strings was limited to 32 pages (defined by<br>       the kernel constant <b>MAX_ARG_PAGES</b>).  On architectures with a 4-kB<br>       page size, this yields a maximum size of 128 kB.<br><br>       On kernel 2.6.23 and later, most architectures support a size limit<br>       derived from the soft <b>RLIMIT_STACK </b>resource limit (see getrlimit(2))<br>       that is in force at the time of the <b>execve</b>() call.  (Architectures<br>       with no memory management unit are excepted: they maintain the limit<br>       that was in effect before kernel 2.6.23.)  This change allows<br>       programs to have a much larger argument and/or environment list.  For<br>       these architectures, the total size is limited to 1/4 of the allowed<br>       stack size.  (Imposing the 1/4-limit ensures that the new program<br>       always has some stack space.)  Since Linux 2.6.25, the kernel places<br>       a floor of 32 pages on this size limit, so that, even when<br>       <b>RLIMIT_STACK </b>is set very low, applications are guaranteed to have at<br>       least as much argument and environment space as was provided by Linux<br>       2.6.23 and earlier.  (This guarantee was not provided in Linux 2.6.23<br>       and 2.6.24.)  Additionally, the limit per string is 32 pages (the<br>       kernel constant <b>MAX_ARG_STRLEN</b>), and the maximum number of strings is<br>       0x7FFFFFFF.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>execve</b>() does not return, on error -1 is returned, and<br>       <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>E2BIG  </b>The total number of bytes in the environment (<i>envp</i>) and<br>              argument list (<i>argv</i>) is too large.<br><br>       <b>EACCES </b>Search permission is denied on a component of the path prefix<br>              of <i>filename</i> or the name of a script interpreter.  (See also<br>              path_resolution(7).)<br><br>       <b>EACCES </b>The file or a script interpreter is not a regular file.<br><br>       <b>EACCES </b>Execute permission is denied for the file or a script or ELF<br>              interpreter.<br><br>       <b>EACCES </b>The filesystem is mounted <i>noexec</i>.<br><br>       <b>EAGAIN </b>(since Linux 3.1)<br>              Having changed its real UID using one of the <b>set*uid</b>() calls,<br>              the caller was&#8212;and is now still&#8212;above its <b>RLIMIT_NPROC</b><br>              resource limit (see setrlimit(2)).  For a more detailed<br>              explanation of this error, see NOTES.<br><br>       <b>EFAULT </b><i>filename</i> or one of the pointers in the vectors <i>argv</i> or <i>envp</i><br>              points outside your accessible address space.<br><br>       <b>EINVAL </b>An ELF executable had more than one PT_INTERP segment (i.e.,<br>              tried to name more than one interpreter).<br><br>       <b>EIO    </b>An I/O error occurred.<br><br>       <b>EISDIR </b>An ELF interpreter was a directory.<br><br>       <b>ELIBBAD</b><br>              An ELF interpreter was not in a recognized format.<br><br>       <b>ELOOP  </b>Too many symbolic links were encountered in resolving <i>filename</i><br>              or the name of a script or ELF interpreter.<br><br>       <b>EMFILE </b>The process has the maximum number of files open.<br><br>       <b>ENAMETOOLONG</b><br>              <i>filename</i> is too long.<br><br>       <b>ENFILE </b>The system limit on the total number of open files has been<br>              reached.<br><br>       <b>ENOENT </b>The file <i>filename</i> or a script or ELF interpreter does not<br>              exist, or a shared library needed for file or interpreter<br>              cannot be found.<br><br>       <b>ENOEXEC</b><br>              An executable is not in a recognized format, is for the wrong<br>              architecture, or has some other format error that means it<br>              cannot be executed.<br><br>       <b>ENOMEM </b>Insufficient kernel memory was available.<br><br>       <b>ENOTDIR</b><br>              A component of the path prefix of <i>filename</i> or a script or ELF<br>              interpreter is not a directory.<br><br>       <b>EPERM  </b>The filesystem is mounted <i>nosuid</i>, the user is not the<br>              superuser, and the file has the set-user-ID or set-group-ID<br>              bit set.<br><br>       <b>EPERM  </b>The process is being traced, the user is not the superuser and<br>              the file has the set-user-ID or set-group-ID bit set.<br><br>       <b>ETXTBSY</b><br>              Executable was open for writing by one or more processes.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008, SVr4, 4.3BSD.  POSIX does not document<br>       the #! behavior, but it exists (with some variations) on other UNIX<br>       systems.<br></pre><br><h2>NOTES  </h2><pre><br>       Set-user-ID and set-group-ID processes can not be ptrace(2)d.<br><br>       The result of mounting a filesystem <i>nosuid</i> varies across Linux kernel<br>       versions: some will refuse execution of set-user-ID and set-group-ID<br>       executables when this would give the user powers she did not have<br>       already (and return <b>EPERM</b>), some will just ignore the set-user-ID and<br>       set-group-ID bits and <b>exec</b>() successfully.<br><br>       On Linux, <i>argv</i> and <i>envp</i> can be specified as NULL.  In both cases,<br>       this has the same effect as specifying the argument as a pointer to a<br>       list containing a single null pointer.  <b>Do not take advantage of this</b><br>       <b>nonstandard and nonportable misfeature!  </b>On many other UNIX systems,<br>       specifying <i>argv</i> as NULL will result in an error (<b>EFAULT</b>).  <i>Some</i> other<br>       UNIX systems treat the <i>envp==NULL</i> case the same as Linux.<br><br>       POSIX.1 says that values returned by sysconf(3) should be invariant<br>       over the lifetime of a process.  However, since Linux 2.6.23, if the<br>       <b>RLIMIT_STACK </b>resource limit changes, then the value reported by<br>       <b>_SC_ARG_MAX </b>will also change, to reflect the fact that the limit on<br>       space for holding command-line arguments and environment variables<br>       has changed.<br><br>       In most cases where <b>execve</b>() fails, control returns to the original<br>       executable image, and the caller of <b>execve</b>() can then handle the<br>       error.  However, in (rare) cases (typically caused by resource<br>       exhaustion), failure may occur past the point of no return: the<br>       original executable image has been torn down, but the new image could<br>       not be completely built.  In such cases, the kernel kills the process<br>       with a <b>SIGKILL </b>signal.<br><br>   <b>Interpreter scripts</b><br>       A maximum line length of 127 characters is allowed for the first line<br>       in an interpreter scripts.<br><br>       The semantics of the <i>optional-arg</i> argument of an interpreter script<br>       vary across implementations.  On Linux, the entire string following<br>       the <i>interpreter</i> name is passed as a single argument to the<br>       interpreter, and this string can include white space.  However,<br>       behavior differs on some other systems.  Some systems use the first<br>       white space to terminate <i>optional-arg</i>.  On some systems, an<br>       interpreter script can have multiple arguments, and white spaces in<br>       <i>optional-arg</i> are used to delimit the arguments.<br><br>       Linux ignores the set-user-ID and set-group-ID bits on scripts.<br><br>   <b>execve() and EAGAIN</b><br>       A more detailed explanation of the <b>EAGAIN </b>error that can occur (since<br>       Linux 3.1) when calling <b>execve</b>() is as follows.<br><br>       The <b>EAGAIN </b>error can occur when a <i>preceding</i> call to setuid(2),<br>       setreuid(2), or setresuid(2) caused the real user ID of the process<br>       to change, and that change caused the process to exceed its<br>       <b>RLIMIT_NPROC </b>resource limit (i.e., the number of processes belonging<br>       to the new real UID exceeds the resource limit).  From Linux 2.6.0 to<br>       3.0, this caused the <b>set*uid</b>() call to fail.  (Prior to 2.6, the<br>       resource limit was not imposed on processes that changed their user<br>       IDs.)<br><br>       Since Linux 3.1, the scenario just described no longer causes the<br>       <b>set*uid</b>() call to fail, because it too often led to security holes<br>       where buggy applications didn't check the return status and assumed<br>       that&#8212;if the caller had root privileges&#8212;the call would always succeed.<br>       Instead, the <b>set*uid</b>() calls now successfully change the real UID,<br>       but the kernel sets an internal flag, named <b>PF_NPROC_EXCEEDED</b>, to<br>       note that the <b>RLIMIT_NPROC </b>resource limit has been exceeded.  If the<br>       <b>PF_NPROC_EXCEEDED </b>flag is set and the resource limit is still<br>       exceeded at the time of a subsequent <b>execve</b>() call, that call fails<br>       with the error <b>EAGAIN</b>.  This kernel logic ensures that the<br>       <b>RLIMIT_NPROC </b>resource limit is still enforced for the common<br>       privileged daemon workflow&#8212;namely, fork(2) + <b>set*uid</b>() + <b>execve</b>().<br><br>       If the resource limit was not still exceeded at the time of the<br>       <b>execve</b>() call (because other processes belonging to this real UID<br>       terminated between the <b>set*uid</b>() call and the <b>execve</b>() call), then<br>       the <b>execve</b>() call succeeds and the kernel clears the<br>       <b>PF_NPROC_EXCEEDED </b>process flag.  The flag is also cleared if a<br>       subsequent call to fork(2) by this process succeeds.<br><br>   <b>Historical</b><br>       With UNIX V6, the argument list of an <b>exec</b>() call was ended by 0,<br>       while the argument list of <i>main</i> was ended by -1.  Thus, this argument<br>       list was not directly usable in a further <b>exec</b>() call.  Since<br>       UNIX V7, both are NULL.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The following program is designed to be execed by the second program<br>       below.  It just echoes its command-line arguments, one per line.<br><br>           /* myecho.c */<br><br>           #include &lt;stdio.h&gt;<br>           #include &lt;stdlib.h&gt;<br><br>           int<br>           main(int argc, char *argv[])<br>           {<br>               int j;<br><br>               for (j = 0; j &lt; argc; j++)<br>                   printf(\"argv[%d]: %s\\n\", j, argv[j]);<br><br>               exit(EXIT_SUCCESS);<br>           }<br><br>       This program can be used to exec the program named in its command-<br>       line argument:<br><br>           /* execve.c */<br><br>           #include &lt;stdio.h&gt;<br>           #include &lt;stdlib.h&gt;<br>           #include &lt;unistd.h&gt;<br><br>           int<br>           main(int argc, char *argv[])<br>           {<br>               char *newargv[] = { NULL, \"hello\", \"world\", NULL };<br>               char *newenviron[] = { NULL };<br><br>               if (argc != 2) {<br>                   fprintf(stderr, \"Usage: %s &lt;file-to-exec&gt;\\n\", argv[0]);<br>                   exit(EXIT_FAILURE);<br>               }<br><br>               newargv[0] = argv[1];<br><br>               execve(argv[1], newargv, newenviron);<br>               perror(\"execve\");   /* execve() returns only on error */<br>               exit(EXIT_FAILURE);<br>           }<br><br>       We can use the second program to exec the first as follows:<br><br>           $ <b>cc myecho.c -o myecho</b><br>           $ <b>cc execve.c -o execve</b><br>           $ <b>./execve ./myecho</b><br>           argv[0]: ./myecho<br>           argv[1]: hello<br>           argv[2]: world<br><br>       We can also use these programs to demonstrate the use of a script<br>       interpreter.  To do this we create a script whose \"interpreter\" is<br>       our <i>myecho</i> program:<br><br>           $ <b>cat &gt; script</b><br>           <b>#!./myecho script-arg</b><br>           <b>^D</b><br>           $ <b>chmod +x script</b><br><br>       We can then use our program to exec the script:<br><br>           $ <b>./execve ./script</b><br>           argv[0]: ./myecho<br>           argv[1]: script-arg<br>           argv[2]: ./script<br>           argv[3]: hello<br>           argv[4]: world<br></pre><br><h2>SEE ALSO  </h2><pre><br>       chmod(2), execveat(2), fork(2), ptrace(2), execl(3), fexecve(3),<br>       getopt(3), credentials(7), environ(7), path_resolution(7), ld.so(8)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-08-08                        EXECVE(2)</span><br></pre><br>"}