{"Man page": "<pre><br><span class=\"headline\">WAIT(2)                   Linux Programmer's Manual                  WAIT(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       wait, waitpid, waitid - wait for process to change state<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/types.h&gt;</b><br>       <b>#include &lt;sys/wait.h&gt;</b><br><br>       <b>pid_t wait(int *</b><i>status</i><b>);</b><br><br>       <b>pid_t waitpid(pid_t </b><i>pid</i><b>, int *</b><i>status</i><b>, int </b><i>options</i><b>);</b><br><br>       <b>int waitid(idtype_t </b><i>idtype</i><b>, id_t </b><i>id</i><b>, siginfo_t *</b><i>infop</i><b>, int </b><i>options</i><b>);</b><br>                       /* This is the glibc and POSIX interface; see<br>                          NOTES for information on the raw system call. */<br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>waitid</b>():<br>           _SVID_SOURCE || _XOPEN_SOURCE &gt;= 500 ||<br>           _XOPEN_SOURCE &amp;&amp; _XOPEN_SOURCE_EXTENDED<br>           || /* Since glibc 2.12: */ _POSIX_C_SOURCE &gt;= 200809L<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       All of these system calls are used to wait for state changes in a<br>       child of the calling process, and obtain information about the child<br>       whose state has changed.  A state change is considered to be: the<br>       child terminated; the child was stopped by a signal; or the child was<br>       resumed by a signal.  In the case of a terminated child, performing a<br>       wait allows the system to release the resources associated with the<br>       child; if a wait is not performed, then the terminated child remains<br>       in a \"zombie\" state (see NOTES below).<br><br>       If a child has already changed state, then these calls return<br>       immediately.  Otherwise, they block until either a child changes<br>       state or a signal handler interrupts the call (assuming that system<br>       calls are not automatically restarted using the <b>SA_RESTART </b>flag of<br>       sigaction(2)).  In the remainder of this page, a child whose state<br>       has changed and which has not yet been waited upon by one of these<br>       system calls is termed <i>waitable</i>.<br><br>   <b>wait() and waitpid()</b><br>       The <b>wait</b>() system call suspends execution of the calling process<br>       until one of its children terminates.  The call <i>wait(&amp;status)</i> is<br>       equivalent to:<br><br>           waitpid(-1, &amp;status, 0);<br><br>       The <b>waitpid</b>() system call suspends execution of the calling process<br>       until a child specified by <i>pid</i> argument has changed state.  By<br>       default, <b>waitpid</b>() waits only for terminated children, but this<br>       behavior is modifiable via the <i>options</i> argument, as described below.<br><br>       The value of <i>pid</i> can be:<br><br>       &lt; -1   meaning wait for any child process whose process group ID is<br>              equal to the absolute value of <i>pid</i>.<br><br>       -1     meaning wait for any child process.<br><br>       0      meaning wait for any child process whose process group ID is<br>              equal to that of the calling process.<br><br>       &gt; 0    meaning wait for the child whose process ID is equal to the<br>              value of <i>pid</i>.<br><br>       The value of <i>options</i> is an OR of zero or more of the following<br>       constants:<br><br>       <b>WNOHANG     </b>return immediately if no child has exited.<br><br>       <b>WUNTRACED   </b>also return if a child has stopped (but not traced via<br>                   ptrace(2)).  Status for <i>traced</i> children which have<br>                   stopped is provided even if this option is not specified.<br><br>       <b>WCONTINUED </b>(since Linux 2.6.10)<br>                   also return if a stopped child has been resumed by<br>                   delivery of <b>SIGCONT</b>.<br><br>       (For Linux-only options, see below.)<br><br>       If <i>status</i> is not NULL, <b>wait</b>() and <b>waitpid</b>() store status information<br>       in the <i>int</i> to which it points.  This integer can be inspected with<br>       the following macros (which take the integer itself as an argument,<br>       not a pointer to it, as is done in <b>wait</b>() and <b>waitpid</b>()!):<br><br>       <b>WIFEXITED(</b><i>status</i><b>)</b><br>              returns true if the child terminated normally, that is, by<br>              calling exit(3) or _exit(2), or by returning from main().<br><br>       <b>WEXITSTATUS(</b><i>status</i><b>)</b><br>              returns the exit status of the child.  This consists of the<br>              least significant 8 bits of the <i>status</i> argument that the child<br>              specified in a call to exit(3) or _exit(2) or as the argument<br>              for a return statement in main().  This macro should be<br>              employed only if <b>WIFEXITED </b>returned true.<br><br>       <b>WIFSIGNALED(</b><i>status</i><b>)</b><br>              returns true if the child process was terminated by a signal.<br><br>       <b>WTERMSIG(</b><i>status</i><b>)</b><br>              returns the number of the signal that caused the child process<br>              to terminate.  This macro should be employed only if<br>              <b>WIFSIGNALED </b>returned true.<br><br>       <b>WCOREDUMP(</b><i>status</i><b>)</b><br>              returns true if the child produced a core dump.  This macro<br>              should be employed only if <b>WIFSIGNALED </b>returned true.  This<br>              macro is not specified in POSIX.1-2001 and is not available on<br>              some UNIX implementations (e.g., AIX, SunOS).  Only use this<br>              enclosed in #ifdef WCOREDUMP ... #endif.<br><br>       <b>WIFSTOPPED(</b><i>status</i><b>)</b><br>              returns true if the child process was stopped by delivery of a<br>              signal; this is possible only if the call was done using<br>              <b>WUNTRACED </b>or when the child is being traced (see ptrace(2)).<br><br>       <b>WSTOPSIG(</b><i>status</i><b>)</b><br>              returns the number of the signal which caused the child to<br>              stop.  This macro should be employed only if <b>WIFSTOPPED</b><br>              returned true.<br><br>       <b>WIFCONTINUED(</b><i>status</i><b>)</b><br>              (since Linux 2.6.10) returns true if the child process was<br>              resumed by delivery of <b>SIGCONT</b>.<br><br>   <b>waitid()</b><br>       The <b>waitid</b>() system call (available since Linux 2.6.9) provides more<br>       precise control over which child state changes to wait for.<br><br>       The <i>idtype</i> and <i>id</i> arguments select the child(ren) to wait for, as<br>       follows:<br><br>       <i>idtype</i> == <b>P_PID</b><br>              Wait for the child whose process ID matches <i>id</i>.<br><br>       <i>idtype</i> == <b>P_PGID</b><br>              Wait for any child whose process group ID matches <i>id</i>.<br><br>       <i>idtype</i> == <b>P_ALL</b><br>              Wait for any child; <i>id</i> is ignored.<br><br>       The child state changes to wait for are specified by ORing one or<br>       more of the following flags in <i>options</i>:<br><br>       <b>WEXITED     </b>Wait for children that have terminated.<br><br>       <b>WSTOPPED    </b>Wait for children that have been stopped by delivery of a<br>                   signal.<br><br>       <b>WCONTINUED  </b>Wait for (previously stopped) children that have been<br>                   resumed by delivery of <b>SIGCONT</b>.<br><br>       The following flags may additionally be ORed in <i>options</i>:<br><br>       <b>WNOHANG     </b>As for <b>waitpid</b>().<br><br>       <b>WNOWAIT     </b>Leave the child in a waitable state; a later wait call<br>                   can be used to again retrieve the child status<br>                   information.<br><br>       Upon successful return, <b>waitid</b>() fills in the following fields of the<br>       <i>siginfo_t</i> structure pointed to by <i>infop</i>:<br><br>       <i>si_pid</i>      The process ID of the child.<br><br>       <i>si_uid</i>      The real user ID of the child.  (This field is not set on<br>                   most other implementations.)<br><br>       <i>si_signo</i>    Always set to <b>SIGCHLD</b>.<br><br>       <i>si_status</i>   Either the exit status of the child, as given to _exit(2)<br>                   (or exit(3)), or the signal that caused the child to<br>                   terminate, stop, or continue.  The <i>si_code</i> field can be<br>                   used to determine how to interpret this field.<br><br>       <i>si_code</i>     Set to one of: <b>CLD_EXITED </b>(child called _exit(2));<br>                   <b>CLD_KILLED </b>(child killed by signal); <b>CLD_DUMPED </b>(child<br>                   killed by signal, and dumped core); <b>CLD_STOPPED </b>(child<br>                   stopped by signal); <b>CLD_TRAPPED </b>(traced child has<br>                   trapped); or <b>CLD_CONTINUED </b>(child continued by <b>SIGCONT</b>).<br><br>       If <b>WNOHANG </b>was specified in <i>options</i> and there were no children in a<br>       waitable state, then <b>waitid</b>() returns 0 immediately and the state of<br>       the <i>siginfo_t</i> structure pointed to by <i>infop</i> is unspecified.  To<br>       distinguish this case from that where a child was in a waitable<br>       state, zero out the <i>si_pid</i> field before the call and check for a<br>       nonzero value in this field after the call returns.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       <b>wait</b>(): on success, returns the process ID of the terminated child;<br>       on error, -1 is returned.<br><br>       <b>waitpid</b>(): on success, returns the process ID of the child whose<br>       state has changed; if <b>WNOHANG </b>was specified and one or more<br>       child(ren) specified by <i>pid</i> exist, but have not yet changed state,<br>       then 0 is returned.  On error, -1 is returned.<br><br>       <b>waitid</b>(): returns 0 on success or if <b>WNOHANG </b>was specified and no<br>       child(ren) specified by <i>id</i> has yet changed state; on error, -1 is<br>       returned.<br><br>       Each of these calls sets <i>errno</i> to an appropriate value in the case of<br>       an error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>ECHILD </b>(for <b>wait</b>()) The calling process does not have any unwaited-<br>              for children.<br><br>       <b>ECHILD </b>(for <b>waitpid</b>() or <b>waitid</b>()) The process specified by <i>pid</i><br>              (<b>waitpid</b>()) or <i>idtype</i> and <i>id</i> (<b>waitid</b>()) does not exist or is<br>              not a child of the calling process.  (This can happen for<br>              one's own child if the action for <b>SIGCHLD </b>is set to <b>SIG_IGN</b>.<br>              See also the <i>Linux Notes</i> section about threads.)<br><br>       <b>EINTR  WNOHANG </b>was not set and an unblocked signal or a <b>SIGCHLD </b>was<br>              caught; see signal(7).<br><br>       <b>EINVAL </b>The <i>options</i> argument was invalid.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       SVr4, 4.3BSD, POSIX.1-2001.<br></pre><br><h2>NOTES  </h2><pre><br>       A child that terminates, but has not been waited for becomes a<br>       \"zombie\".  The kernel maintains a minimal set of information about<br>       the zombie process (PID, termination status, resource usage<br>       information) in order to allow the parent to later perform a wait to<br>       obtain information about the child.  As long as a zombie is not<br>       removed from the system via a wait, it will consume a slot in the<br>       kernel process table, and if this table fills, it will not be<br>       possible to create further processes.  If a parent process<br>       terminates, then its \"zombie\" children (if any) are adopted by<br>       init(1), which automatically performs a wait to remove the zombies.<br><br>       POSIX.1-2001 specifies that if the disposition of <b>SIGCHLD </b>is set to<br>       <b>SIG_IGN </b>or the <b>SA_NOCLDWAIT </b>flag is set for <b>SIGCHLD </b>(see<br>       sigaction(2)), then children that terminate do not become zombies and<br>       a call to <b>wait</b>() or <b>waitpid</b>() will block until all children have<br>       terminated, and then fail with <i>errno</i> set to <b>ECHILD</b>.  (The original<br>       POSIX standard left the behavior of setting <b>SIGCHLD </b>to <b>SIG_IGN</b><br>       unspecified.  Note that even though the default disposition of<br>       <b>SIGCHLD </b>is \"ignore\", explicitly setting the disposition to <b>SIG_IGN</b><br>       results in different treatment of zombie process children.)<br><br>       Linux 2.6 conforms to the POSIX requirements.  However, Linux 2.4<br>       (and earlier) does not: if a <b>wait</b>() or <b>waitpid</b>() call is made while<br>       <b>SIGCHLD </b>is being ignored, the call behaves just as though <b>SIGCHLD</b><br>       were not being ignored, that is, the call blocks until the next child<br>       terminates and then returns the process ID and status of that child.<br><br>   <b>Linux notes</b><br>       In the Linux kernel, a kernel-scheduled thread is not a distinct<br>       construct from a process.  Instead, a thread is simply a process that<br>       is created using the Linux-unique clone(2) system call; other<br>       routines such as the portable pthread_create(3) call are implemented<br>       using clone(2).  Before Linux 2.4, a thread was just a special case<br>       of a process, and as a consequence one thread could not wait on the<br>       children of another thread, even when the latter belongs to the same<br>       thread group.  However, POSIX prescribes such functionality, and<br>       since Linux 2.4 a thread can, and by default will, wait on children<br>       of other threads in the same thread group.<br><br>       The following Linux-specific <i>options</i> are for use with children<br>       created using clone(2); they cannot be used with <b>waitid</b>():<br><br>       <b>__WCLONE</b><br>              Wait for \"clone\" children only.  If omitted, then wait for<br>              \"non-clone\" children only.  (A \"clone\" child is one which<br>              delivers no signal, or a signal other than <b>SIGCHLD </b>to its<br>              parent upon termination.)  This option is ignored if <b>__WALL </b>is<br>              also specified.<br><br>       <b>__WALL </b>(since Linux 2.4)<br>              Wait for all children, regardless of type (\"clone\" or \"non-<br>              clone\").<br><br>       <b>__WNOTHREAD </b>(since Linux 2.4)<br>              Do not wait for children of other threads in the same thread<br>              group.  This was the default before Linux 2.4.<br><br>   <b>C library/kernel differences</b><br>       <b>wait</b>() is actually a library function that (in glibc) is implemented<br>       as a call to wait4(2).<br><br>       Within glibc, <b>waitpid</b>() is a wrapper function that invokes wait(2).<br><br>       The raw <b>waitid</b>() system call takes a fifth argument, of type <i>struct</i><br>       <i>rusage *</i>.  If this argument is non-NULL, then it is used to return<br>       resource usage information about the child, in the same manner as<br>       wait4(2).  See getrusage(2) for details.<br></pre><br><h2>BUGS  </h2><pre><br>       According to POSIX.1-2008, an application calling <b>waitid</b>() must<br>       ensure that <i>infop</i> points to a <i>siginfo_t</i> structure (i.e., that it is a<br>       non-null pointer).  On Linux, if <i>infop</i> is NULL, <b>waitid</b>() succeeds,<br>       and returns the process ID of the waited-for child.  Applications<br>       should avoid relying on this inconsistent, nonstandard, and<br>       unnecessary feature.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The following program demonstrates the use of fork(2) and <b>waitpid</b>().<br>       The program creates a child process.  If no command-line argument is<br>       supplied to the program, then the child suspends its execution using<br>       pause(2), to allow the user to send signals to the child.  Otherwise,<br>       if a command-line argument is supplied, then the child exits<br>       immediately, using the integer supplied on the command line as the<br>       exit status.  The parent process executes a loop that monitors the<br>       child using <b>waitpid</b>(), and uses the W*() macros described above to<br>       analyze the wait status value.<br><br>       The following shell session demonstrates the use of the program:<br><br>           $ <b>./a.out &amp;</b><br>           Child PID is 32360<br>           [1] 32359<br>           $ <b>kill -STOP 32360</b><br>           stopped by signal 19<br>           $ <b>kill -CONT 32360</b><br>           continued<br>           $ <b>kill -TERM 32360</b><br>           killed by signal 15<br>           [1]+  Done                    ./a.out<br>           $<br><br>   <b>Program source</b><br><br>       #include &lt;sys/wait.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;unistd.h&gt;<br>       #include &lt;stdio.h&gt;<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           pid_t cpid, w;<br>           int status;<br><br>           cpid = fork();<br>           if (cpid == -1) {<br>               perror(\"fork\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           if (cpid == 0) {            /* Code executed by child */<br>               printf(\"Child PID is %ld\\n\", (long) getpid());<br>               if (argc == 1)<br>                   pause();                    /* Wait for signals */<br>               _exit(atoi(argv[1]));<br><br>           } else {                    /* Code executed by parent */<br>               do {<br>                   w = waitpid(cpid, &amp;status, WUNTRACED | WCONTINUED);<br>                   if (w == -1) {<br>                       perror(\"waitpid\");<br>                       exit(EXIT_FAILURE);<br>                   }<br><br>                   if (WIFEXITED(status)) {<br>                       printf(\"exited, status=%d\\n\", WEXITSTATUS(status));<br>                   } else if (WIFSIGNALED(status)) {<br>                       printf(\"killed by signal %d\\n\", WTERMSIG(status));<br>                   } else if (WIFSTOPPED(status)) {<br>                       printf(\"stopped by signal %d\\n\", WSTOPSIG(status));<br>                   } else if (WIFCONTINUED(status)) {<br>                       printf(\"continued\\n\");<br>                   }<br>               } while (!WIFEXITED(status) &amp;&amp; !WIFSIGNALED(status));<br>               exit(EXIT_SUCCESS);<br>           }<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       _exit(2), clone(2), fork(2), kill(2), ptrace(2), sigaction(2),<br>       signal(2), wait4(2), pthread_create(3), credentials(7), signal(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                          WAIT(2)</span><br></pre><br>"}