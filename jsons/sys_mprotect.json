{"Man page": "<pre><br><span class=\"headline\">MPROTECT(2)               Linux Programmer's Manual              MPROTECT(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       mprotect - set protection on a region of memory<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/mman.h&gt;</b><br><br>       <b>int mprotect(void *</b><i>addr</i><b>, size_t </b><i>len</i><b>, int </b><i>prot</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>mprotect</b>() changes protection for the calling process's memory<br>       page(s) containing any part of the address range in the interval<br>       [<i>addr</i>, <i>addr</i>+<i>len</i>-1].  <i>addr</i> must be aligned to a page boundary.<br><br>       If the calling process tries to access memory in a manner that<br>       violates the protection, then the kernel generates a <b>SIGSEGV </b>signal<br>       for the process.<br><br>       <i>prot</i> is either <b>PROT_NONE </b>or a bitwise-or of the other values in the<br>       following list:<br><br>       <b>PROT_NONE  </b>The memory cannot be accessed at all.<br><br>       <b>PROT_READ  </b>The memory can be read.<br><br>       <b>PROT_WRITE </b>The memory can be modified.<br><br>       <b>PROT_EXEC  </b>The memory can be executed.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>mprotect</b>() returns zero.  On error, -1 is returned, and<br>       <i>errno</i> is set appropriately.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EACCES </b>The memory cannot be given the specified access.  This can<br>              happen, for example, if you mmap(2) a file to which you have<br>              read-only access, then ask <b>mprotect</b>() to mark it <b>PROT_WRITE</b>.<br><br>       <b>EINVAL </b><i>addr</i> is not a valid pointer, or not a multiple of the system<br>              page size.<br><br>       <b>ENOMEM </b>Internal kernel structures could not be allocated.<br><br>       <b>ENOMEM </b>Addresses in the range [<i>addr</i>, <i>addr</i>+<i>len</i>-1] are invalid for the<br>              address space of the process, or specify one or more pages<br>              that are not mapped.  (Before kernel 2.4.19, the error <b>EFAULT</b><br>              was incorrectly produced for these cases.)<br><br>       <b>ENOMEM </b>Changing the protection of a memory region would result in the<br>              total number of mappings with distinct attributes (e.g., read<br>              versus read/write protection) exceeding the allowed maximum.<br>              (For example, making the protection of a range <b>PROT_READ </b>in<br>              the middle of a region currently protected as<br>              <b>PROT_READ|PROT_WRITE </b>would result in three mappings: two<br>              read/write mappings at each end and a read-only mapping in the<br>              middle.)<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008, SVr4.  POSIX says that the behavior of<br>       <b>mprotect</b>() is unspecified if it is applied to a region of memory that<br>       was not obtained via mmap(2).<br></pre><br><h2>NOTES  </h2><pre><br>       On Linux it is always permissible to call <b>mprotect</b>() on any address<br>       in a process's address space (except for the kernel vsyscall area).<br>       In particular it can be used to change existing code mappings to be<br>       writable.<br><br>       Whether <b>PROT_EXEC </b>has any effect different from <b>PROT_READ </b>depends on<br>       processor architecture, kernel version, and process state.  If<br>       <b>READ_IMPLIES_EXEC </b>is set in the process's personality flags (see<br>       personality(2)), specifying <b>PROT_READ </b>will implicitly add <b>PROT_EXEC.</b><br><br>       On some hardware architectures (e.g., i386), <b>PROT_WRITE </b>implies<br>       <b>PROT_READ</b>.<br><br>       POSIX.1 says that an implementation may permit access other than that<br>       specified in <i>prot</i>, but at a minimum can allow write access only if<br>       <b>PROT_WRITE </b>has been set, and must not allow any access if <b>PROT_NONE</b><br>       has been set.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The program below allocates four pages of memory, makes the third of<br>       these pages read-only, and then executes a loop that walks upward<br>       through the allocated region modifying bytes.<br><br>       An example of what we might see when running the program is the<br>       following:<br><br>           $ <b>./a.out</b><br>           Start of region:        0x804c000<br>           Got SIGSEGV at address: 0x804e000<br><br>   <b>Program source</b><br><br>       #include &lt;unistd.h&gt;<br>       #include &lt;signal.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;malloc.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;errno.h&gt;<br>       #include &lt;sys/mman.h&gt;<br><br>       #define handle_error(msg) \\<br>           do { perror(msg); exit(EXIT_FAILURE); } while (0)<br><br>       static char *buffer;<br><br>       static void<br>       handler(int sig, siginfo_t *si, void *unused)<br>       {<br>           printf(\"Got SIGSEGV at address: 0x%lx\\n\",<br>                   (long) si-&gt;si_addr);<br>           exit(EXIT_FAILURE);<br>       }<br><br>       int<br>       main(int argc, char *argv[])<br>       {<br>           char *p;<br>           int pagesize;<br>           struct sigaction sa;<br><br>           sa.sa_flags = SA_SIGINFO;<br>           sigemptyset(&amp;sa.sa_mask);<br>           sa.sa_sigaction = handler;<br>           if (sigaction(SIGSEGV, &amp;sa, NULL) == -1)<br>               handle_error(\"sigaction\");<br><br>           pagesize = sysconf(_SC_PAGE_SIZE);<br>           if (pagesize == -1)<br>               handle_error(\"sysconf\");<br><br>           /* Allocate a buffer aligned on a page boundary;<br>              initial protection is PROT_READ | PROT_WRITE */<br><br>           buffer = memalign(pagesize, 4 * pagesize);<br>           if (buffer == NULL)<br>               handle_error(\"memalign\");<br><br>           printf(\"Start of region:        0x%lx\\n\", (long) buffer);<br><br>           if (mprotect(buffer + pagesize * 2, pagesize,<br>                       PROT_READ) == -1)<br>               handle_error(\"mprotect\");<br><br>           for (p = buffer ; ; )<br>               *(p++) = 'a';<br><br>           printf(\"Loop completed\\n\");     /* Should never happen */<br>           exit(EXIT_SUCCESS);<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       mmap(2), sysconf(3)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                      MPROTECT(2)</span><br></pre><br>"}