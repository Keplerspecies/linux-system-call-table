{"Man page": "<pre><br><span class=\"headline\">READ(2)                   Linux Programmer's Manual                  READ(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       read - read from a file descriptor<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;unistd.h&gt;</b><br><br>       <b>ssize_t read(int </b><i>fd</i><b>, void *</b><i>buf</i><b>, size_t </b><i>count</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>read</b>() attempts to read up to <i>count</i> bytes from file descriptor <i>fd</i><br>       into the buffer starting at <i>buf</i>.<br><br>       On files that support seeking, the read operation commences at the<br>       current file offset, and the file offset is incremented by the number<br>       of bytes read.  If the current file offset is at or past the end of<br>       file, no bytes are read, and <b>read</b>() returns zero.<br><br>       If <i>count</i> is zero, <b>read</b>() <i>may</i> detect the errors described below.  In<br>       the absence of any errors, or if <b>read</b>() does not check for errors, a<br>       <b>read</b>() with a <i>count</i> of 0 returns zero and has no other effects.<br><br>       If <i>count</i> is greater than <b>SSIZE_MAX</b>, the result is unspecified.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, the number of bytes read is returned (zero indicates end<br>       of file), and the file position is advanced by this number.  It is<br>       not an error if this number is smaller than the number of bytes<br>       requested; this may happen for example because fewer bytes are<br>       actually available right now (maybe because we were close to end-of-<br>       file, or because we are reading from a pipe, or from a terminal), or<br>       because <b>read</b>() was interrupted by a signal.  See also NOTES.<br><br>       On error, -1 is returned, and <i>errno</i> is set appropriately.  In this<br>       case, it is left unspecified whether the file position (if any)<br>       changes.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EAGAIN </b>The file descriptor <i>fd</i> refers to a file other than a socket<br>              and has been marked nonblocking (<b>O_NONBLOCK</b>), and the read<br>              would block.  See open(2) for further details on the<br>              <b>O_NONBLOCK </b>flag.<br><br>       <b>EAGAIN </b>or <b>EWOULDBLOCK</b><br>              The file descriptor <i>fd</i> refers to a socket and has been marked<br>              nonblocking (<b>O_NONBLOCK</b>), and the read would block.<br>              POSIX.1-2001 allows either error to be returned for this case,<br>              and does not require these constants to have the same value,<br>              so a portable application should check for both possibilities.<br><br>       <b>EBADF  </b><i>fd</i> is not a valid file descriptor or is not open for reading.<br><br>       <b>EFAULT </b><i>buf</i> is outside your accessible address space.<br><br>       <b>EINTR  </b>The call was interrupted by a signal before any data was read;<br>              see signal(7).<br><br>       <b>EINVAL </b><i>fd</i> is attached to an object which is unsuitable for reading;<br>              or the file was opened with the <b>O_DIRECT </b>flag, and either the<br>              address specified in <i>buf</i>, the value specified in <i>count</i>, or the<br>              current file offset is not suitably aligned.<br><br>       <b>EINVAL </b><i>fd</i> was created via a call to timerfd_create(2) and the wrong<br>              size buffer was given to <b>read</b>(); see timerfd_create(2) for<br>              further information.<br><br>       <b>EIO    </b>I/O error.  This will happen for example when the process is<br>              in a background process group, tries to read from its<br>              controlling terminal, and either it is ignoring or blocking<br>              <b>SIGTTIN </b>or its process group is orphaned.  It may also occur<br>              when there is a low-level I/O error while reading from a disk<br>              or tape.<br><br>       <b>EISDIR </b><i>fd</i> refers to a directory.<br><br>       Other errors may occur, depending on the object connected to <i>fd</i>.<br>       POSIX allows a <b>read</b>() that is interrupted after reading some data to<br>       return -1 (with <i>errno</i> set to <b>EINTR</b>) or to return the number of bytes<br>       already read.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       SVr4, 4.3BSD, POSIX.1-2001.<br></pre><br><h2>NOTES  </h2><pre><br>       On Linux, <b>read</b>() (and similar system calls) will transfer at most<br>       0x7ffff000 (2,147,479,552) bytes, returning the number of bytes<br>       actually transferred.  (This is true on both 32-bit and 64-bit<br>       systems.)<br><br>       On NFS filesystems, reading small amounts of data will update the<br>       timestamp only the first time, subsequent calls may not do so.  This<br>       is caused by client side attribute caching, because most if not all<br>       NFS clients leave <i>st_atime</i> (last file access time) updates to the<br>       server, and client side reads satisfied from the client's cache will<br>       not cause <i>st_atime</i> updates on the server as there are no server-side<br>       reads.  UNIX semantics can be obtained by disabling client-side<br>       attribute caching, but in most situations this will substantially<br>       increase server load and decrease performance.<br></pre><br><h2>BUGS  </h2><pre><br>       According to POSIX.1-2008/SUSv4 Section XSI 2.9.7 (\"Thread<br>       Interactions with Regular File Operations\"):<br><br>           All of the following functions shall be atomic with respect to<br>           each other in the effects specified in POSIX.1-2008 when they<br>           operate on regular files or symbolic links: ...<br><br>       Among the APIs subsequently listed are <b>read</b>() and readv(2).  And<br>       among the effects that should be atomic across threads (and<br>       processes) are updates of the file offset.  However, on Linux before<br>       version 3.14, this was not the case: if two processes that share an<br>       open file description (see open(2)) perform a <b>read</b>() (or readv(2)) at<br>       the same time, then the I/O operations were not atomic with respect<br>       updating the file offset, with the result that the reads in the two<br>       processes might (incorrectly) overlap in the blocks of data that they<br>       obtained.  This problem was fixed in Linux 3.14.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       close(2), fcntl(2), ioctl(2), lseek(2), open(2), pread(2),<br>       readdir(2), readlink(2), readv(2), select(2), write(2), fread(3)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-07-23                          READ(2)</span><br></pre><br>"}