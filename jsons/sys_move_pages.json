{"Man page": "<pre><br><span class=\"headline\">MOVE_PAGES(2)             Linux Programmer's Manual            MOVE_PAGES(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       move_pages - move individual pages of a process to another node<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;numaif.h&gt;</b><br><br>       <b>long move_pages(int </b><i>pid</i><b>, unsigned long count, void **</b><i>pages</i><b>,</b><br>                       <b>const int *</b><i>nodes</i><b>, int *</b><i>status</i><b>, int </b><i>flags</i><b>);</b><br><br>       Link with <i>-lnuma</i>.<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       <b>move_pages</b>() moves the specified <i>pages</i> of the process <i>pid</i> to the<br>       memory nodes specified by <i>nodes</i>.  The result of the move is reflected<br>       in <i>status</i>.  The <i>flags</i> indicate constraints on the pages to be moved.<br><br>       <i>pid</i> is the ID of the process in which pages are to be moved.  To move<br>       pages in another process, the caller must be privileged<br>       (<b>CAP_SYS_NICE</b>) or the real or effective user ID of the calling<br>       process must match the real or saved-set user ID of the target<br>       process.  If <i>pid</i> is 0, then <b>move_pages</b>() moves pages of the calling<br>       process.<br><br>       <i>count</i> is the number of pages to move.  It defines the size of the<br>       three arrays <i>pages</i>, <i>nodes</i>, and <i>status</i>.<br><br>       <i>pages</i> is an array of pointers to the pages that should be moved.<br>       These are pointers that should be aligned to page boundaries.<br>       Addresses are specified as seen by the process specified by <i>pid</i>.<br><br>       <i>nodes</i> is an array of integers that specify the desired location for<br>       each page.  Each element in the array is a node number.  <i>nodes</i> can<br>       also be NULL, in which case <b>move_pages</b>() does not move any pages but<br>       instead will return the node where each page currently resides, in<br>       the <i>status</i> array.  Obtaining the status of each page may be necessary<br>       to determine pages that need to be moved.<br><br>       <i>status</i> is an array of integers that return the status of each page.<br>       The array contains valid values only if <b>move_pages</b>() did not return<br>       an error.<br><br>       <i>flags</i> specify what types of pages to move.  <b>MPOL_MF_MOVE </b>means that<br>       only pages that are in exclusive use by the process are to be moved.<br>       <b>MPOL_MF_MOVE_ALL </b>means that pages shared between multiple processes<br>       can also be moved.  The process must be privileged (<b>CAP_SYS_NICE</b>) to<br>       use <b>MPOL_MF_MOVE_ALL</b>.<br><br>   <b>Page states in the status array</b><br>       The following values can be returned in each element of the <i>status</i><br>       array.<br><br>       <b>0..MAX_NUMNODES</b><br>              Identifies the node on which the page resides.<br><br>       <b>-EACCES</b><br>              The page is mapped by multiple processes and can be moved only<br>              if <b>MPOL_MF_MOVE_ALL </b>is specified.<br><br>       <b>-EBUSY </b>The page is currently busy and cannot be moved.  Try again<br>              later.  This occurs if a page is undergoing I/O or another<br>              kernel subsystem is holding a reference to the page.<br><br>       <b>-EFAULT</b><br>              This is a zero page or the memory area is not mapped by the<br>              process.<br><br>       <b>-EIO   </b>Unable to write back a page.  The page has to be written back<br>              in order to move it since the page is dirty and the filesystem<br>              does not provide a migration function that would allow the<br>              move of dirty pages.<br><br>       <b>-EINVAL</b><br>              A dirty page cannot be moved.  The filesystem does not provide<br>              a migration function and has no ability to write back pages.<br><br>       <b>-ENOENT</b><br>              The page is not present.<br><br>       <b>-ENOMEM</b><br>              Unable to allocate memory on target node.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success <b>move_pages</b>() returns zero.  On error, it returns -1, and<br>       sets <i>errno</i> to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>E2BIG  </b>Too many pages to move.<br><br>       <b>EACCES </b>One of the target nodes is not allowed by the current cpuset.<br><br>       <b>EFAULT </b>Parameter array could not be accessed.<br><br>       <b>EINVAL </b>Flags other than <b>MPOL_MF_MOVE </b>and <b>MPOL_MF_MOVE_ALL </b>was<br>              specified or an attempt was made to migrate pages of a kernel<br>              thread.<br><br>       <b>ENODEV </b>One of the target nodes is not online.<br><br>       <b>ENOENT </b>No pages were found that require moving.  All pages are either<br>              already on the target node, not present, had an invalid<br>              address or could not be moved because they were mapped by<br>              multiple processes.<br><br>       <b>EPERM  </b>The caller specified <b>MPOL_MF_MOVE_ALL </b>without sufficient<br>              privileges (<b>CAP_SYS_NICE</b>).  Or, the caller attempted to move<br>              pages of a process belonging to another user but did not have<br>              privilege to do so (<b>CAP_SYS_NICE</b>).<br><br>       <b>ESRCH  </b>Process does not exist.<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>move_pages</b>() first appeared on Linux in version 2.6.18.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       This system call is Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       For information on library support, see numa(7).<br><br>       Use get_mempolicy(2) with the <b>MPOL_F_MEMS_ALLOWED </b>flag to obtain the<br>       set of nodes that are allowed by the current cpuset.  Note that this<br>       information is subject to change at any time by manual or automatic<br>       reconfiguration of the cpuset.<br><br>       Use of this function may result in pages whose location (node)<br>       violates the memory policy established for the specified addresses<br>       (See mbind(2)) and/or the specified process (See set_mempolicy(2)).<br>       That is, memory policy does not constrain the destination nodes used<br>       by <b>move_pages</b>().<br><br>       The <i>&lt;numaif.h&gt;</i> header is not included with glibc, but requires<br>       installing <i>libnuma-devel</i> or a similar package.<br></pre><br><h2>SEE ALSO  </h2><pre><br>       get_mempolicy(2), mbind(2), set_mempolicy(2), numa(3), numa_maps(5),<br>       cpuset(7), numa(7), migratepages(8), numastat(8)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2010-06-11                    MOVE_PAGES(2)</span><br></pre><br>"}