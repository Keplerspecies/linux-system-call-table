{"Man page": "<pre><br><span class=\"headline\">ACCEPT(2)                 Linux Programmer's Manual                ACCEPT(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       accept, accept4 - accept a connection on a socket<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/types.h&gt;          </b>/* See NOTES */<br>       <b>#include &lt;sys/socket.h&gt;</b><br><br>       <b>int accept(int </b><i>sockfd</i><b>, struct sockaddr *</b><i>addr</i><b>, socklen_t *</b><i>addrlen</i><b>);</b><br><br>       <b>#define _GNU_SOURCE             </b>/* See feature_test_macros(7) */<br>       <b>#include &lt;sys/socket.h&gt;</b><br><br>       <b>int accept4(int </b><i>sockfd</i><b>, struct sockaddr *</b><i>addr</i><b>,</b><br>                   <b>socklen_t *</b><i>addrlen</i><b>, int </b><i>flags</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>accept</b>() system call is used with connection-based socket types<br>       (<b>SOCK_STREAM</b>, <b>SOCK_SEQPACKET</b>).  It extracts the first connection<br>       request on the queue of pending connections for the listening socket,<br>       <i>sockfd</i>, creates a new connected socket, and returns a new file<br>       descriptor referring to that socket.  The newly created socket is not<br>       in the listening state.  The original socket <i>sockfd</i> is unaffected by<br>       this call.<br><br>       The argument <i>sockfd</i> is a socket that has been created with socket(2),<br>       bound to a local address with bind(2), and is listening for<br>       connections after a listen(2).<br><br>       The argument <i>addr</i> is a pointer to a <i>sockaddr</i> structure.  This<br>       structure is filled in with the address of the peer socket, as known<br>       to the communications layer.  The exact format of the address<br>       returned <i>addr</i> is determined by the socket's address family (see<br>       socket(2) and the respective protocol man pages).  When <i>addr</i> is NULL,<br>       nothing is filled in; in this case, <i>addrlen</i> is not used, and should<br>       also be NULL.<br><br>       The <i>addrlen</i> argument is a value-result argument: the caller must<br>       initialize it to contain the size (in bytes) of the structure pointed<br>       to by <i>addr</i>; on return it will contain the actual size of the peer<br>       address.<br><br>       The returned address is truncated if the buffer provided is too<br>       small; in this case, <i>addrlen</i> will return a value greater than was<br>       supplied to the call.<br><br>       If no pending connections are present on the queue, and the socket is<br>       not marked as nonblocking, <b>accept</b>() blocks the caller until a<br>       connection is present.  If the socket is marked nonblocking and no<br>       pending connections are present on the queue, <b>accept</b>() fails with the<br>       error <b>EAGAIN </b>or <b>EWOULDBLOCK</b>.<br><br>       In order to be notified of incoming connections on a socket, you can<br>       use select(2) or poll(2).  A readable event will be delivered when a<br>       new connection is attempted and you may then call <b>accept</b>() to get a<br>       socket for that connection.  Alternatively, you can set the socket to<br>       deliver <b>SIGIO </b>when activity occurs on a socket; see socket(7) for<br>       details.<br><br>       For certain protocols which require an explicit confirmation, such as<br>       DECNet, <b>accept</b>() can be thought of as merely dequeuing the next<br>       connection request and not implying confirmation.  Confirmation can<br>       be implied by a normal read or write on the new file descriptor, and<br>       rejection can be implied by closing the new socket.  Currently only<br>       DECNet has these semantics on Linux.<br><br>       If <i>flags</i> is 0, then <b>accept4</b>() is the same as <b>accept</b>().  The following<br>       values can be bitwise ORed in <i>flags</i> to obtain different behavior:<br><br>       <b>SOCK_NONBLOCK   </b>Set the <b>O_NONBLOCK </b>file status flag on the new open<br>                       file description.  Using this flag saves extra calls<br>                       to fcntl(2) to achieve the same result.<br><br>       <b>SOCK_CLOEXEC    </b>Set the close-on-exec (<b>FD_CLOEXEC</b>) flag on the new<br>                       file descriptor.  See the description of the<br>                       <b>O_CLOEXEC </b>flag in open(2) for reasons why this may be<br>                       useful.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, these system calls return a nonnegative integer that is a<br>       descriptor for the accepted socket.  On error, -1 is returned, and<br>       <i>errno</i> is set appropriately.<br><br>   <b>Error handling</b><br>       Linux <b>accept</b>() (and <b>accept4</b>()) passes already-pending network errors<br>       on the new socket as an error code from <b>accept</b>().  This behavior<br>       differs from other BSD socket implementations.  For reliable<br>       operation the application should detect the network errors defined<br>       for the protocol after <b>accept</b>() and treat them like <b>EAGAIN </b>by<br>       retrying.  In the case of TCP/IP, these are <b>ENETDOWN</b>, <b>EPROTO</b>,<br>       <b>ENOPROTOOPT</b>, <b>EHOSTDOWN</b>, <b>ENONET</b>, <b>EHOSTUNREACH</b>, <b>EOPNOTSUPP</b>, and<br>       <b>ENETUNREACH</b>.<br></pre><br><h2>ERRORS  </h2><pre><br>       <b>EAGAIN </b>or <b>EWOULDBLOCK</b><br>              The socket is marked nonblocking and no connections are<br>              present to be accepted.  POSIX.1-2001 and POSIX.1-2008 allow<br>              either error to be returned for this case, and do not require<br>              these constants to have the same value, so a portable<br>              application should check for both possibilities.<br><br>       <b>EBADF  </b>The descriptor is invalid.<br><br>       <b>ECONNABORTED</b><br>              A connection has been aborted.<br><br>       <b>EFAULT </b>The <i>addr</i> argument is not in a writable part of the user<br>              address space.<br><br>       <b>EINTR  </b>The system call was interrupted by a signal that was caught<br>              before a valid connection arrived; see signal(7).<br><br>       <b>EINVAL </b>Socket is not listening for connections, or <i>addrlen</i> is invalid<br>              (e.g., is negative).<br><br>       <b>EINVAL </b>(<b>accept4</b>()) invalid value in <i>flags</i>.<br><br>       <b>EMFILE </b>The per-process limit of open file descriptors has been<br>              reached.<br><br>       <b>ENFILE </b>The system limit on the total number of open files has been<br>              reached.<br><br>       <b>ENOBUFS</b>, <b>ENOMEM</b><br>              Not enough free memory.  This often means that the memory<br>              allocation is limited by the socket buffer limits, not by the<br>              system memory.<br><br>       <b>ENOTSOCK</b><br>              The descriptor references a file, not a socket.<br><br>       <b>EOPNOTSUPP</b><br>              The referenced socket is not of type <b>SOCK_STREAM</b>.<br><br>       <b>EPROTO </b>Protocol error.<br><br>       In addition, Linux <b>accept</b>() may fail if:<br><br>       <b>EPERM  </b>Firewall rules forbid connection.<br><br>       In addition, network errors for the new socket and as defined for the<br>       protocol may be returned.  Various Linux kernels can return other<br>       errors such as <b>ENOSR</b>, <b>ESOCKTNOSUPPORT</b>, <b>EPROTONOSUPPORT</b>, <b>ETIMEDOUT</b>.<br>       The value <b>ERESTARTSYS </b>may be seen during a trace.<br></pre><br><h2>VERSIONS  </h2><pre><br>       The <b>accept4</b>() system call is available starting with Linux 2.6.28;<br>       support in glibc is available starting with version 2.10.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>accept</b>(): POSIX.1-2001, POSIX.1-2008, SVr4, 4.4BSD (<b>accept</b>() first<br>       appeared in 4.2BSD).<br><br>       <b>accept4</b>() is a nonstandard Linux extension.<br><br>       On Linux, the new socket returned by <b>accept</b>() does <i>not</i> inherit file<br>       status flags such as <b>O_NONBLOCK </b>and <b>O_ASYNC </b>from the listening<br>       socket.  This behavior differs from the canonical BSD sockets<br>       implementation.  Portable programs should not rely on inheritance or<br>       noninheritance of file status flags and always explicitly set all<br>       required flags on the socket returned from <b>accept</b>().<br></pre><br><h2>NOTES  </h2><pre><br>       POSIX.1-2001 does not require the inclusion of <i>&lt;sys/types.h&gt;</i>, and<br>       this header file is not required on Linux.  However, some historical<br>       (BSD) implementations required this header file, and portable<br>       applications are probably wise to include it.<br><br>       There may not always be a connection waiting after a <b>SIGIO </b>is<br>       delivered or select(2) or poll(2) return a readability event because<br>       the connection might have been removed by an asynchronous network<br>       error or another thread before <b>accept</b>() is called.  If this happens,<br>       then the call will block waiting for the next connection to arrive.<br>       To ensure that <b>accept</b>() never blocks, the passed socket <i>sockfd</i> needs<br>       to have the <b>O_NONBLOCK </b>flag set (see socket(7)).<br><br>   <b>The socklen_t type</b><br>       The third argument of <b>accept</b>() was originally declared as an <i>int *</i><br>       (and is that under libc4 and libc5 and on many other systems like 4.x<br>       BSD, SunOS 4, SGI); a POSIX.1g draft standard wanted to change it<br>       into a <i>size_t *</i>, and that is what it is for SunOS 5.  Later POSIX<br>       drafts have <i>socklen_t *</i>, and so do the Single UNIX Specification and<br>       glibc2.  Quoting Linus Torvalds:<br><br>       \"_Any_ sane library _must_ have \"socklen_t\" be the same size as int.<br>       Anything else breaks any BSD socket layer stuff.  POSIX initially <i>did</i><br>       make it a size_t, and I (and hopefully others, but obviously not too<br>       many) complained to them very loudly indeed.  Making it a size_t is<br>       completely broken, exactly because size_t very seldom is the same<br>       size as \"int\" on 64-bit architectures, for example.  And it <i>has</i> to be<br>       the same size as \"int\" because that's what the BSD socket interface<br>       is.  Anyway, the POSIX people eventually got a clue, and created<br>       \"socklen_t\".  They shouldn't have touched it in the first place, but<br>       once they did they felt it had to have a named type for some<br>       unfathomable reason (probably somebody didn't like losing face over<br>       having done the original stupid thing, so they silently just renamed<br>       their blunder).\"<br></pre><br><h2>EXAMPLE  </h2><pre><br>       See bind(2).<br></pre><br><h2>SEE ALSO  </h2><pre><br>       bind(2), connect(2), listen(2), select(2), socket(2), socket(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-08-08                        ACCEPT(2)</span><br></pre><br>"}