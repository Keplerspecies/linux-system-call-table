{"Man page": "<pre><br><span class=\"headline\">SEMOP(2)                  Linux Programmer's Manual                 SEMOP(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       semop, semtimedop - System V semaphore operations<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#include &lt;sys/types.h&gt;</b><br>       <b>#include &lt;sys/ipc.h&gt;</b><br>       <b>#include &lt;sys/sem.h&gt;</b><br><br>       <b>int semop(int </b><i>semid</i><b>, struct sembuf *</b><i>sops</i><b>, size_t </b><i>nsops</i><b>);</b><br><br>       <b>int semtimedop(int </b><i>semid</i><b>, struct sembuf *</b><i>sops</i><b>, size_t </b><i>nsops</i><b>,</b><br>                      <b>const struct timespec *</b><i>timeout</i><b>);</b><br><br>   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):<br><br>       <b>semtimedop</b>(): _GNU_SOURCE<br></pre><br><h2>DESCRIPTION  </h2><pre><br>       Each semaphore in a System V semaphore set has the following<br>       associated values:<br><br>           unsigned short  semval;   /* semaphore value */<br>           unsigned short  semzcnt;  /* # waiting for zero */<br>           unsigned short  semncnt;  /* # waiting for increase */<br>           pid_t           sempid;   /* ID of process that did last op */<br><br>       <b>semop</b>() performs operations on selected semaphores in the set<br>       indicated by <i>semid</i>.  Each of the <i>nsops</i> elements in the array pointed<br>       to by <i>sops</i> is a structure that specifies an operation to be performed<br>       on a single semaphore.  The elements of this structure are of type<br>       <i>struct sembuf</i>, containing the following members:<br><br>           unsigned short sem_num;  /* semaphore number */<br>           short          sem_op;   /* semaphore operation */<br>           short          sem_flg;  /* operation flags */<br><br>       Flags recognized in <i>sem_flg</i> are <b>IPC_NOWAIT </b>and <b>SEM_UNDO</b>.  If an<br>       operation specifies <b>SEM_UNDO</b>, it will be automatically undone when<br>       the process terminates.<br><br>       The set of operations contained in <i>sops</i> is performed in <i>array order</i>,<br>       and <i>atomically</i>, that is, the operations are performed either as a<br>       complete unit, or not at all.  The behavior of the system call if not<br>       all operations can be performed immediately depends on the presence<br>       of the <b>IPC_NOWAIT </b>flag in the individual <i>sem_flg</i> fields, as noted<br>       below.<br><br>       Each operation is performed on the <i>sem_num</i>-th semaphore of the<br>       semaphore set, where the first semaphore of the set is numbered 0.<br>       There are three types of operation, distinguished by the value of<br>       <i>sem_op</i>.<br><br>       If <i>sem_op</i> is a positive integer, the operation adds this value to the<br>       semaphore value (<i>semval</i>).  Furthermore, if <b>SEM_UNDO </b>is specified for<br>       this operation, the system subtracts the value <i>sem_op</i> from the<br>       semaphore adjustment (<i>semadj</i>) value for this semaphore.  This<br>       operation can always proceed&#8212;it never forces a thread to wait.  The<br>       calling process must have alter permission on the semaphore set.<br><br>       If <i>sem_op</i> is zero, the process must have read permission on the<br>       semaphore set.  This is a \"wait-for-zero\" operation: if <i>semval</i> is<br>       zero, the operation can immediately proceed.  Otherwise, if<br>       <b>IPC_NOWAIT </b>is specified in <i>sem_flg</i>, <b>semop</b>() fails with <i>errno</i> set to<br>       <b>EAGAIN </b>(and none of the operations in <i>sops</i> is performed).  Otherwise,<br>       <i>semzcnt</i> (the count of threads waiting until this semaphore's value<br>       becomes zero) is incremented by one and the thread sleeps until one<br>       of the following occurs:<br><br>       &#183;  <i>semval</i> becomes 0, at which time the value of <i>semzcnt</i> is<br>          decremented.<br><br>       &#183;  The semaphore set is removed: <b>semop</b>() fails, with <i>errno</i> set to<br>          <b>EIDRM</b>.<br><br>       &#183;  The calling thread catches a signal: the value of <i>semzcnt</i> is<br>          decremented and <b>semop</b>() fails, with <i>errno</i> set to <b>EINTR</b>.<br><br>       If <i>sem_op</i> is less than zero, the process must have alter permission<br>       on the semaphore set.  If <i>semval</i> is greater than or equal to the<br>       absolute value of <i>sem_op</i>, the operation can proceed immediately: the<br>       absolute value of <i>sem_op</i> is subtracted from <i>semval</i>, and, if <b>SEM_UNDO</b><br>       is specified for this operation, the system adds the absolute value<br>       of <i>sem_op</i> to the semaphore adjustment (<i>semadj</i>) value for this<br>       semaphore.  If the absolute value of <i>sem_op</i> is greater than <i>semval</i>,<br>       and <b>IPC_NOWAIT </b>is specified in <i>sem_flg</i>, <b>semop</b>() fails, with <i>errno</i> set<br>       to <b>EAGAIN </b>(and none of the operations in <i>sops</i> is performed).<br>       Otherwise, <i>semncnt</i> (the counter of threads waiting for this<br>       semaphore's value to increase) is incremented by one and the thread<br>       sleeps until one of the following occurs:<br><br>       &#183;  <i>semval</i> becomes greater than or equal to the absolute value of<br>          <i>sem_op</i>: the operation now proceeds, as described above.<br><br>       &#183;  The semaphore set is removed from the system: <b>semop</b>() fails, with<br>          <i>errno</i> set to <b>EIDRM</b>.<br><br>       &#183;  The calling thread catches a signal: the value of <i>semncnt</i> is<br>          decremented and <b>semop</b>() fails, with <i>errno</i> set to <b>EINTR</b>.<br><br>       On successful completion, the <i>sempid</i> value for each semaphore<br>       specified in the array pointed to by <i>sops</i> is set to the caller's<br>       process ID.  In addition, the <i>sem_otime</i> is set to the current time.<br><br>   <b>semtimedop()</b><br>       <b>semtimedop</b>() behaves identically to <b>semop</b>() except that in those<br>       cases where the calling thread would sleep, the duration of that<br>       sleep is limited by the amount of elapsed time specified by the<br>       <i>timespec</i> structure whose address is passed in the <i>timeout</i> argument.<br>       (This sleep interval will be rounded up to the system clock<br>       granularity, and kernel scheduling delays mean that the interval may<br>       overrun by a small amount.)  If the specified time limit has been<br>       reached, <b>semtimedop</b>() fails with <i>errno</i> set to <b>EAGAIN </b>(and none of the<br>       operations in <i>sops</i> is performed).  If the <i>timeout</i> argument is NULL,<br>       then <b>semtimedop</b>() behaves exactly like <b>semop</b>().<br><br>       Note that if <b>semtimeop</b>() is interrupted by a signal, causing the call<br>       to fail with the error <b>EINTR</b>, the contents of <i>timeout</i> are left<br>       unchanged.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       If successful, <b>semop</b>() and <b>semtimedop</b>() return 0; otherwise they<br>       return -1 with <i>errno</i> indicating the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       On failure, <i>errno</i> is set to one of the following:<br><br>       <b>E2BIG  </b>The argument <i>nsops</i> is greater than <b>SEMOPM</b>, the maximum number<br>              of operations allowed per system call.<br><br>       <b>EACCES </b>The calling process does not have the permissions required to<br>              perform the specified semaphore operations, and does not have<br>              the <b>CAP_IPC_OWNER </b>capability.<br><br>       <b>EAGAIN </b>An operation could not proceed immediately and either<br>              <b>IPC_NOWAIT </b>was specified in <i>sem_flg</i> or the time limit<br>              specified in <i>timeout</i> expired.<br><br>       <b>EFAULT </b>An address specified in either the <i>sops</i> or the <i>timeout</i><br>              argument isn't accessible.<br><br>       <b>EFBIG  </b>For some operation the value of <i>sem_num</i> is less than 0 or<br>              greater than or equal to the number of semaphores in the set.<br><br>       <b>EIDRM  </b>The semaphore set was removed.<br><br>       <b>EINTR  </b>While blocked in this system call, the thread caught a signal;<br>              see signal(7).<br><br>       <b>EINVAL </b>The semaphore set doesn't exist, or <i>semid</i> is less than zero,<br>              or <i>nsops</i> has a nonpositive value.<br><br>       <b>ENOMEM </b>The <i>sem_flg</i> of some operation specified <b>SEM_UNDO </b>and the<br>              system does not have enough memory to allocate the undo<br>              structure.<br><br>       <b>ERANGE </b>For some operation <i>sem_op+semval</i> is greater than <b>SEMVMX</b>, the<br>              implementation dependent maximum value for <i>semval</i>.<br></pre><br><h2>VERSIONS  </h2><pre><br>       <b>semtimedop</b>() first appeared in Linux 2.5.52, and was subsequently<br>       backported into kernel 2.4.22.  Glibc support for <b>semtimedop</b>() first<br>       appeared in version 2.3.3.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       POSIX.1-2001, POSIX.1-2008, SVr4.<br></pre><br><h2>NOTES  </h2><pre><br>       The inclusion of <i>&lt;sys/types.h&gt;</i> and <i>&lt;sys/ipc.h&gt;</i> isn't required on<br>       Linux or by any version of POSIX.  However, some old implementations<br>       required the inclusion of these header files, and the SVID also<br>       documented their inclusion.  Applications intended to be portable to<br>       such old systems may need to include these header files.<br><br>       The <i>sem_undo</i> structures of a process aren't inherited by the child<br>       produced by fork(2), but they are inherited across an execve(2)<br>       system call.<br><br>       <b>semop</b>() is never automatically restarted after being interrupted by a<br>       signal handler, regardless of the setting of the <b>SA_RESTART </b>flag when<br>       establishing a signal handler.<br><br>       A semaphore adjustment (<i>semadj</i>) value is a per-process, per-semaphore<br>       integer that is the negated sum of all operations performed on a<br>       semaphore specifying the <b>SEM_UNDO </b>flag.  Each process has a list of<br>       <i>semadj</i> values&#8212;one value for each semaphore on which it has operated<br>       using <b>SEM_UNDO</b>.  When a process terminates, each of its per-semaphore<br>       <i>semadj</i> values is added to the corresponding semaphore, thus undoing<br>       the effect of that process's operations on the semaphore (but see<br>       BUGS below).  When a semaphore's value is directly set using the<br>       <b>SETVAL </b>or <b>SETALL </b>request to semctl(2), the corresponding <i>semadj</i><br>       values in all processes are cleared.  The clone(2) <b>CLONE_SYSVSEM </b>flag<br>       allows more than one process to share a <i>semadj</i> list; see clone(2) for<br>       details.<br><br>       The <i>semval</i>, <i>sempid</i>, <i>semzcnt</i>, and <i>semnct</i> values for a semaphore can<br>       all be retrieved using appropriate semctl(2) calls.<br><br>   <b>Semaphore limits</b><br>       The following limits on semaphore set resources affect the <b>semop</b>()<br>       call:<br><br>       <b>SEMOPM </b>Maximum number of operations allowed for one <b>semop</b>() call.<br>              Before Linux 3.19, the default value for this limit was 32.<br>              Since Linux 3.19, the default value is 500.  On Linux, this<br>              limit can be read and modified via the third field of<br>              <i>/proc/sys/kernel/sem</i>.  <i>Note</i>: this limit should not be raised<br>              above 1000, because of the risk of that semop(2) fails due to<br>              kernel memory fragmentation when allocating memory to copy the<br>              <i>sops</i> array.<br><br>       <b>SEMVMX </b>Maximum allowable value for <i>semval</i>: implementation dependent<br>              (32767).<br><br>       The implementation has no intrinsic limits for the adjust on exit<br>       maximum value (<b>SEMAEM</b>), the system wide maximum number of undo<br>       structures (<b>SEMMNU</b>) and the per-process maximum number of undo<br>       entries system parameters.<br></pre><br><h2>BUGS  </h2><pre><br>       When a process terminates, its set of associated <i>semadj</i> structures is<br>       used to undo the effect of all of the semaphore operations it<br>       performed with the <b>SEM_UNDO </b>flag.  This raises a difficulty: if one<br>       (or more) of these semaphore adjustments would result in an attempt<br>       to decrease a semaphore's value below zero, what should an<br>       implementation do?  One possible approach would be to block until all<br>       the semaphore adjustments could be performed.  This is however<br>       undesirable since it could force process termination to block for<br>       arbitrarily long periods.  Another possibility is that such semaphore<br>       adjustments could be ignored altogether (somewhat analogously to<br>       failing when <b>IPC_NOWAIT </b>is specified for a semaphore operation).<br>       Linux adopts a third approach: decreasing the semaphore value as far<br>       as possible (i.e., to zero) and allowing process termination to<br>       proceed immediately.<br><br>       In kernels 2.6.x, x &lt;= 10, there is a bug that in some circumstances<br>       prevents a thread that is waiting for a semaphore value to become<br>       zero from being woken up when the value does actually become zero.<br>       This bug is fixed in kernel 2.6.11.<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The following code segment uses <b>semop</b>() to atomically wait for the<br>       value of semaphore 0 to become zero, and then increment the semaphore<br>       value by one.<br><br>           struct sembuf sops[2];<br>           int semid;<br><br>           /* Code to set <i>semid</i> omitted */<br><br>           sops[0].sem_num = 0;        /* Operate on semaphore 0 */<br>           sops[0].sem_op = 0;         /* Wait for value to equal 0 */<br>           sops[0].sem_flg = 0;<br><br>           sops[1].sem_num = 0;        /* Operate on semaphore 0 */<br>           sops[1].sem_op = 1;         /* Increment value by one */<br>           sops[1].sem_flg = 0;<br><br>           if (semop(semid, sops, 2) == -1) {<br>               perror(\"semop\");<br>               exit(EXIT_FAILURE);<br>           }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       clone(2), semctl(2), semget(2), sigaction(2), capabilities(7),<br>       sem_overview(7), svipc(7), time(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2015-08-08                         SEMOP(2)</span><br></pre><br>"}