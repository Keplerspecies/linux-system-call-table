{"Man page": "<pre><br><span class=\"headline\">SENDMMSG(2)               Linux Programmer's Manual              SENDMMSG(2)</span><br></pre><br><h2>NAME  </h2><pre><br>       sendmmsg - send multiple messages on a socket<br></pre><br><h2>SYNOPSIS  </h2><pre><br>       <b>#define _GNU_SOURCE         </b>/* See feature_test_macros(7) */<br>       <b>#include &lt;sys/socket.h&gt;</b><br><br>       <b>int sendmmsg(int </b><i>sockfd</i><b>, struct mmsghdr *</b><i>msgvec</i><b>, unsigned int </b><i>vlen</i><b>,</b><br>                    <b>unsigned int </b><i>flags</i><b>);</b><br></pre><br><h2>DESCRIPTION  </h2><pre><br>       The <b>sendmmsg</b>() system call is an extension of sendmsg(2) that allows<br>       the caller to transmit multiple messages on a socket using a single<br>       system call.  (This has performance benefits for some applications.)<br><br>       The <i>sockfd</i> argument is the file descriptor of the socket on which<br>       data is to be transmitted.<br><br>       The <i>msgvec</i> argument is a pointer to an array of <i>mmsghdr</i> structures.<br>       The size of this array is specified in <i>vlen</i>.<br><br>       The <i>mmsghdr</i> structure is defined in <i>&lt;sys/socket.h&gt;</i> as:<br><br>           struct mmsghdr {<br>               struct msghdr msg_hdr;  /* Message header */<br>               unsigned int  msg_len;  /* Number of bytes transmitted */<br>           };<br><br>       The <i>msg_hdr</i> field is a <i>msghdr</i> structure, as described in sendmsg(2).<br>       The <i>msg_len</i> field is used to return the number of bytes sent from the<br>       message in <i>msg_hdr</i> (i.e., the same as the return value from a single<br>       sendmsg(2) call).<br><br>       The <i>flags</i> argument contains flags ORed together.  The flags are the<br>       same as for sendmsg(2).<br><br>       A blocking <b>sendmmsg</b>() call blocks until <i>vlen</i> messages have been sent.<br>       A nonblocking call sends as many messages as possible (up to the<br>       limit specified by <i>vlen</i>) and returns immediately.<br><br>       On return from <b>sendmmsg</b>(), the <i>msg_len</i> fields of successive elements<br>       of <i>msgvec</i> are updated to contain the number of bytes transmitted from<br>       the corresponding <i>msg_hdr</i>.  The return value of the call indicates<br>       the number of elements of <i>msgvec</i> that have been updated.<br></pre><br><h2>RETURN VALUE  </h2><pre><br>       On success, <b>sendmmsg</b>() returns the number of messages sent from<br>       <i>msgvec</i>; if this is less than <i>vlen</i>, the caller can retry with a<br>       further <b>sendmmsg</b>() call to send the remaining messages.<br><br>       On error, -1 is returned, and <i>errno</i> is set to indicate the error.<br></pre><br><h2>ERRORS  </h2><pre><br>       Errors are as for sendmsg(2).  An error is returned only if no<br>       datagrams could be sent.<br></pre><br><h2>VERSIONS  </h2><pre><br>       The <b>sendmmsg</b>() system call was added in Linux 3.0.  Support in glibc<br>       was added in version 2.14.<br></pre><br><h2>CONFORMING TO  </h2><pre><br>       <b>sendmmsg</b>() is Linux-specific.<br></pre><br><h2>NOTES  </h2><pre><br>       The value specified in <i>vlen</i> is capped to <b>UIO_MAXIOV </b>(1024).<br></pre><br><h2>EXAMPLE  </h2><pre><br>       The example below uses <b>sendmmsg</b>() to send <i>onetwo</i> and <i>three</i> in two<br>       distinct UDP datagrams using one system call.  The contents of the<br>       first datagram originates from a pair of buffers.<br><br>       #define _GNU_SOURCE<br>       #include &lt;netinet/ip.h&gt;<br>       #include &lt;stdio.h&gt;<br>       #include &lt;stdlib.h&gt;<br>       #include &lt;string.h&gt;<br>       #include &lt;sys/types.h&gt;<br>       #include &lt;sys/socket.h&gt;<br><br>       int<br>       main(void)<br>       {<br>           int sockfd;<br>           struct sockaddr_in sa;<br>           struct mmsghdr msg[2];<br>           struct iovec msg1[2], msg2;<br>           int retval;<br><br>           sockfd = socket(AF_INET, SOCK_DGRAM, 0);<br>           if (sockfd == -1) {<br>               perror(\"socket()\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           sa.sin_family = AF_INET;<br>           sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);<br>           sa.sin_port = htons(1234);<br>           if (connect(sockfd, (struct sockaddr *) &amp;sa, sizeof(sa)) == -1) {<br>               perror(\"connect()\");<br>               exit(EXIT_FAILURE);<br>           }<br><br>           memset(msg1, 0, sizeof(msg1));<br>           msg1[0].iov_base = \"one\";<br>           msg1[0].iov_len = 3;<br>           msg1[1].iov_base = \"two\";<br>           msg1[1].iov_len = 3;<br><br>           memset(&amp;msg2, 0, sizeof(msg2));<br>           msg2.iov_base = \"three\";<br>           msg2.iov_len = 5;<br><br>           memset(msg, 0, sizeof(msg));<br>           msg[0].msg_hdr.msg_iov = msg1;<br>           msg[0].msg_hdr.msg_iovlen = 2;<br><br>           msg[1].msg_hdr.msg_iov = &amp;msg2;<br>           msg[1].msg_hdr.msg_iovlen = 1;<br><br>           retval = sendmmsg(sockfd, msg, 2, 0);<br>           if (retval == -1)<br>               perror(\"sendmmsg()\");<br>           else<br>               printf(\"%d messages sent\\n\", retval);<br><br>           exit(0);<br>       }<br></pre><br><h2>SEE ALSO  </h2><pre><br>       recvmmsg(2), sendmsg(2), socket(2), socket(7)<br></pre><br><h2>COLOPHON  </h2><pre><br>       This page is part of release 4.02 of the Linux <i>man-pages</i> project.  A<br>       description of the project, information about reporting bugs, and the<br>       latest version of this page, can be found at<br>       http://www.kernel.org/doc/man-pages/.<br><br><span class=\"footline\">Linux                            2014-07-08                      SENDMMSG(2)</span><br></pre><br>"}